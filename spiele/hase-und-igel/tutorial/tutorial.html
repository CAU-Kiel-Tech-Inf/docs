<!DOCTYPE html><html lang="de"><head><meta charSet="utf-8"/><meta name="viewport" content="width=device-width"/><meta name="next-head-count" content="2"/><style>:root {
            --color-brand: #3276AD;
            --color-brand-dark: #3276AD;
            --color-brand-text: white;
          }</style><link rel="preload" href="/_next/static/css/d1ffa3b5ce191da2.css" as="style"/><link rel="stylesheet" href="/_next/static/css/d1ffa3b5ce191da2.css" data-n-g=""/><noscript data-n-css=""></noscript><script defer="" nomodule="" src="/_next/static/chunks/polyfills-c67a75d1b6f99dc8.js"></script><script src="/_next/static/chunks/webpack-d41077ae8592d6b6.js" defer=""></script><script src="/_next/static/chunks/framework-0ba0ddd33199226d.js" defer=""></script><script src="/_next/static/chunks/main-8e0ce2fba6738b9c.js" defer=""></script><script src="/_next/static/chunks/pages/_app-979293a0013eae3b.js" defer=""></script><script src="/_next/static/chunks/664-e8ab225d314330bf.js" defer=""></script><script src="/_next/static/chunks/26-fab400e816303f7e.js" defer=""></script><script src="/_next/static/chunks/pages/%5B%5B...page%5D%5D-e8b962b845809beb.js" defer=""></script><script src="/_next/static/op0C_lU0uCwQl16EjqkoY/_buildManifest.js" defer=""></script><script src="/_next/static/op0C_lU0uCwQl16EjqkoY/_ssgManifest.js" defer=""></script></head><body><div id="__next"><div class="loading">...</div></div><script id="__NEXT_DATA__" type="application/json">{"props":{"pageProps":{"markdown":"[PDF-Version dieses Dokumentes](tutorial.pdf)\n\n# Start zum Schreiben einer KI\n\nAm einfachsten ist es die KI auf Grundlage des Zufallsspielers zu\nschreiben:\n\n-   Als erstes muss der Zufallsspieler heruntergeladen werden\n    (\u003chttp://www.software-challenge.de/downloads/\u003e bitte den\n    Zufallsspieler als „Quellcode“ downloaden)\n\n-   Dieser muss nun in Eclips eingebunden werden:\n    \u003chttps://docs.software-challenge.de/#einrichtung-von-eclipse\u003e\n\n## Wo schreibe ich die KI?\n\nIst dies getan befindet sich im entsprechenden Projekt das Package\n„sc.player2018.logic“ mit einer Datei namens **„RandomLogic.java“**.\nDiese Datei müssen wir nun editieren.\n\nIn der Datei gibt es eine Funktion mit der Bezeichnung *public void\nonRequestAction()*. Diese ist wie Folgt aufgebaut:\n\n    public void onRequestAction(){\n      // optional: Laufzeitmessung\n      long startTime = System.nanoTime();\n\n\n      // Quellcode der KI, welche eine Zug (move) erstellt\n\n\n      long nowTime = System.nanoTime();\n\n      // sende Move. Danach gibt es kein zurück mehr:\n      sendAction(move);\n\n      // optional: LOG-Eintrag mit Zeit:\n      log.warn(\"Time needed for turn: {}\", (nowTime - startTime) / 1000000);\n    }\n\nEs ist sehr wichtig, dass alle Funktionen, welche die KI verwendet,\nihren ursprünglichen Aufruf in der Funktion onRequestAction haben.\nDadurch wird sichergestellt, dass alle Membervariablen aktuell sind.\n\n## Wichtige Membervariablen\n\nIn der Klasse befinden sich auch drei sehr wichtige Membervariablen:\n\n    private Starter client; // Intern für den Server wichtig. Bitte nicht modifizieren\n\n    private GameState gameState; // Gibt u.a Infos über mögliche Züge und das Spielbrett\n\n    private Player currentPlayer; // Infos über den aktuellen Spieler, welchen man steuert\n\nIn den Folgenden Dokumenten werden Grundlagen zum erstellen einer KI\ngezeigt. Hierbei werden wir oft die Variablen **gameState** und\n**currentPlayer** verwenden.\n\nDie **API-Dokumentation** befindet sich im Ordner „doc“ im Verzeichnis\ndes Zufallsspielers.\n\n## Aufgaben\n\n1.  Arbeite alle anderen Dokumente durch.\n\n2.  Analysiere die Herangehensweise der Zufallsspieler-KI.\n\n3.  Schreibe eine KI.\n\n# Spielbrett Informationen\n\n## Die Klasse „FieldType“\n\nBevor wir mit der Klasse Board also dem Spielbrett arbeiten können,\nmüssen wir das Enum „FieldType“ kennenlernen. Dieses Enum definiert die\neinzelnen Felder des Bretts. Es gibt:\n\n\u003ctable\u003e\n\u003ccolgroup\u003e\n\u003ccol style=\"width: 50%\" /\u003e\n\u003ccol style=\"width: 50%\" /\u003e\n\u003c/colgroup\u003e\n\u003ctbody\u003e\n\u003ctr class=\"odd\"\u003e\n\u003ctd style=\"text-align: left;\"\u003e\u003cp\u003eCARROT\u003c/p\u003e\u003c/td\u003e\n\u003ctd style=\"text-align: left;\"\u003e\u003cp\u003eKarottenfeld\u003c/p\u003e\u003c/td\u003e\n\u003c/tr\u003e\n\u003ctr class=\"even\"\u003e\n\u003ctd style=\"text-align: left;\"\u003e\u003cp\u003eGOAL\u003c/p\u003e\u003c/td\u003e\n\u003ctd style=\"text-align: left;\"\u003e\u003cp\u003eZielfeld\u003c/p\u003e\u003c/td\u003e\n\u003c/tr\u003e\n\u003ctr class=\"odd\"\u003e\n\u003ctd style=\"text-align: left;\"\u003e\u003cp\u003eHARE\u003c/p\u003e\u003c/td\u003e\n\u003ctd style=\"text-align: left;\"\u003e\u003cp\u003eHasenfeld\u003c/p\u003e\u003c/td\u003e\n\u003c/tr\u003e\n\u003ctr class=\"even\"\u003e\n\u003ctd style=\"text-align: left;\"\u003e\u003cp\u003eHEDGEHOG\u003c/p\u003e\u003c/td\u003e\n\u003ctd style=\"text-align: left;\"\u003e\u003cp\u003eIgelfeld\u003c/p\u003e\u003c/td\u003e\n\u003c/tr\u003e\n\u003ctr class=\"odd\"\u003e\n\u003ctd style=\"text-align: left;\"\u003e\u003cp\u003eSALAD\u003c/p\u003e\u003c/td\u003e\n\u003ctd style=\"text-align: left;\"\u003e\u003cp\u003eSalatfeld\u003c/p\u003e\u003c/td\u003e\n\u003c/tr\u003e\n\u003ctr class=\"even\"\u003e\n\u003ctd style=\"text-align: left;\"\u003e\u003cp\u003eSTART\u003c/p\u003e\u003c/td\u003e\n\u003ctd style=\"text-align: left;\"\u003e\u003cp\u003eStart\u003c/p\u003e\u003c/td\u003e\n\u003c/tr\u003e\n\u003ctr class=\"odd\"\u003e\n\u003ctd style=\"text-align: left;\"\u003e\u003cp\u003ePOSITION_1\u003c/p\u003e\u003c/td\u003e\n\u003ctd style=\"text-align: left;\"\u003e\u003cp\u003ePositionsfelder\u003c/p\u003e\u003c/td\u003e\n\u003c/tr\u003e\n\u003ctr class=\"even\"\u003e\n\u003ctd style=\"text-align: left;\"\u003e\u003cp\u003ePOSITION_2\u003c/p\u003e\u003c/td\u003e\n\u003ctd style=\"text-align: left;\"\u003e\u003c/td\u003e\n\u003c/tr\u003e\n\u003ctr class=\"odd\"\u003e\n\u003ctd style=\"text-align: left;\"\u003e\u003cp\u003eINVALID\u003c/p\u003e\u003c/td\u003e\n\u003ctd style=\"text-align: left;\"\u003e\u003cp\u003eUngültig\u003c/p\u003e\u003c/td\u003e\n\u003c/tr\u003e\n\u003c/tbody\u003e\n\u003c/table\u003e\n\nDie Dokumentation für FieldType ist in /doc/sc/plugin2018/FieldType.html\nzu finden.\n\n## Funktionen der Klasse „Board“\n\nDas Spielbrett kann man sich wie einer Art modifizieren „Array“ [1]\nvorstellen. Mithilfe der FieldTypes können wir die Funktionen des Boards\nverwenden. Zunächst stellt sich allerdings die Frage, wie wir überhaupt\ndas Spielbrett bekommen können. Das Spielbrett bekommen wir durch den\nGameState. Mit Hilfe der Methode *gameState.getBoard()*.\n\nUnsere Eigene Position können wir mithilfe von **currentPlayer** oder\n**gameState** herausfinden:\n\n    // Es wird immer ein Integer zwischen 0 bis 64 zurückgegeben:\n    currentPlayer.getFieldIndex();\n    // dasselbe wie oben:\n    gameState.getCurrentPlayer().getFieldIndex();\n\n    if (currentPlayer.getFieldIndex() == gameState.getCurrentPlayer().getFieldIndex()) {\n      //wird immer ausgeführt\n    }\n\n### public final int getNextFieldByType(FieldType type,int pos)\n\nDieser Funktion übergeben wir eine Position und ein FieldType. Es gibt\ndie Position des nächsten FieldType an, welches **nach** der angegeben\nPosition liegt. Hat das Feld mit der angegeben Position, den gleichen\nFieldType, so wird dennoch die Position des nächsten Felds angegeben\n(siehe zweites Beispiel). Gibt es diesen FieldType nicht mehr wird -1\nzurückgegeben.\n\n    gameState.getBoard().getNextFieldByType(FieldType.GOAL,\n                                            currentPlayer.getFieldIndex());\n\nDies würde in einem normalen Spiel immer 64 zurückgeben, außer man\nbefindet sich auf dem Ziel. Im diesem Fall wäre das Ergebnis -1.\n\n    // Damit man nicht immer gameState.getBoard() schreiben muss:\n    Board b = gameState.getBoard();\n    final int index = currentPlayer.getFieldIndex(); // Index des Spielers\n\n    if (index == b.getNextFieldByType(b.getTypeAt(index), index)) {\n      System.out.println(\"Geht nicht\");\n    }\n\nDies liegt daran, dass der verwendete Index nie der Rückgabewert von\n**getNextFieldByType** sein kann.\n\n    int next_hedgehog = b.getNextFieldByType(FieldType.HEDGEHOG,\n                                             currentPlayer.getFieldIndex());\n    int next_next_hedgehog = b.getNextFieldByType(FieldType.HEDGEHOG, next_hedgehog);\n\nDies würde die Postion des nächste und vom übernächste Igelfeld\nbestimmen. Achtung es wird hierbei nicht überprüft, ob es so ein Feld\nüberhaupt gibt. Dies kann zu Fehlern führen. Steht man z.B auf dem\nletzten Igelfeld, so hat **next\\_next\\_hedgehog** den Wert 11, anstelle\nvon -1 (Siehe Übung 2).\n\n### public final int getPreviousFieldByType(FieldType type,int pos)\n\nAnalog zu getNextFieldByType. Allerdings bezieht sich die Funktion auf\ndas vorherige Feld mit dem entsprechenden FieldType.\n\n### public final FieldType getTypeAt(int pos)\n\nMit dieser Funktionen kann man den FieldType eines bestimmten Feldes\nermitteln.\n\n    FieldType my_field = gameState.getBoard().getTypeAt(currentPlayer.getFieldIndex());\n    FieldType field_42 = gameState.getBoard().getTypeAt(42);\n\nSpeichert den aktuelle FieldType auf welchen man steht und den FieldType\ndes Feldes 42.\n\n    if (gameState.getBoard().getTypeAt(-1) == FieldType.INVALID) {\n      // Wird immer ausgeführt, da es das Feld an der Position -1 nicht gibt\n    }\n\nDieses Beispiel zeigt auf, dass es durch getTypeAt nie zu einer\nIndexOutOfBoundsException kommen kann. Es gibt nur Felder im Intervall\nvon 0 – 64. Sollte man nach einem Feld außerhalb diese Intervalls\nfragen, so wird immer INVALID zurückgegeben.\n\nDie komplette API-Dokumentation ist in /doc/sc/plugin2018/Board.html zu\nfinden.\n\n## Aufgaben\n\n1.  Gib die Entfernung des Gegners zum Startfeld aus. Verwende dabei\n    keine Variablen oder Literale. Die Ausnahme ist der Rückgabewert.\n    Dieser darf eine Literale sein (z.B. return 127;). Tipp: Suche in\n    der API von GameState nach einer Funktion, welchen den anderen\n    Spieler zurückgibt oder lese das Dokument „Hase\\_Igel\\_Player“.\n\n2.  Erkläre warum **next\\_next\\_hedgehog** den Wert 11 hätte, wenn wir\n    auf den letzten Igelfeld stehen würden.\n\n        int next_hedgehog = b.getNextFieldByType(FieldType.HEDGEHOG,\n                                                 currentPlayer.getFieldIndex());\n        int next_next_hedgehog = b.getNextFieldByType(FieldType.HEDGEHOG, next_hedgehog);\n\n3.  Schreibe eine Funktion, welche das übernächste Igelfeld ausgibt.\n    Gibt es solch ein Feld nicht, so soll immer -1 zurückgegeben werden.\n\n# Die Klasse Player\n\nDie Klasse Player repräsentiert einen Spieler. Der eigene Spieler kann\nin der RandomLogic durch die Variable **currentPlayer** oder mithilfe\nder GameState Funktion *getCurrentPlayer()* abgefragt werden. Der\ngegnerische Spieler kann ebenfalls mithilfe einer Methode von GameState\nbestimmt werden (*gameState.getOtherPlayer()*).\n\nDie Klasse Player besitzt viele Funktionen, welche einen Informationen\nüber den Spieler geben:\n\n\u003ctable\u003e\n\u003ccolgroup\u003e\n\u003ccol style=\"width: 50%\" /\u003e\n\u003ccol style=\"width: 50%\" /\u003e\n\u003c/colgroup\u003e\n\u003ctbody\u003e\n\u003ctr class=\"odd\"\u003e\n\u003ctd style=\"text-align: left;\"\u003e\u003cp\u003ejava.util.List\u0026lt;CardType\u0026gt;\u003c/p\u003e\u003c/td\u003e\n\u003ctd style=\"text-align: left;\"\u003e\u003cp\u003e\u003cem\u003egetCards()\u003c/em\u003e\u003cbr /\u003e\nGibt die für diesen Spieler verfügbaren Hasenkarten zurück.\u003c/p\u003e\u003c/td\u003e\n\u003c/tr\u003e\n\u003ctr class=\"even\"\u003e\n\u003ctd style=\"text-align: left;\"\u003e\u003cp\u003ejava.util.List\u0026lt;CardType\u0026gt;\u003c/p\u003e\u003c/td\u003e\n\u003ctd style=\"text-align: left;\"\u003e\u003cp\u003e\u003cem\u003egetCardsWithout(CardType\ntype)\u003c/em\u003e\u003cbr /\u003e\nGibt Karten ohne bestimmten Typ zurück.\u003c/p\u003e\u003c/td\u003e\n\u003c/tr\u003e\n\u003ctr class=\"odd\"\u003e\n\u003ctd style=\"text-align: left;\"\u003e\u003cp\u003eint\u003c/p\u003e\u003c/td\u003e\n\u003ctd style=\"text-align: left;\"\u003e\u003cp\u003e\u003cem\u003egetCarrots()\u003c/em\u003e\u003cbr /\u003e\nDie Anzahl an Karotten die der Spieler zur Zeit auf der Hand\nhat.\u003c/p\u003e\u003c/td\u003e\n\u003c/tr\u003e\n\u003ctr class=\"even\"\u003e\n\u003ctd style=\"text-align: left;\"\u003e\u003cp\u003eint\u003c/p\u003e\u003c/td\u003e\n\u003ctd style=\"text-align: left;\"\u003e\u003cp\u003e\u003cem\u003egetFieldIndex()\u003c/em\u003e\u003cbr /\u003e\nDie aktuelle Position der Figur auf dem Spielfeld.\u003c/p\u003e\u003c/td\u003e\n\u003c/tr\u003e\n\u003ctr class=\"odd\"\u003e\n\u003ctd style=\"text-align: left;\"\u003e\u003cp\u003eAction\u003c/p\u003e\u003c/td\u003e\n\u003ctd style=\"text-align: left;\"\u003e\u003cp\u003e\u003cem\u003egetLastNonSkipAction\u003c/em\u003e\u003cbr /\u003e\nGibt letzte Aktion des Spielers zurück.\u003c/p\u003e\u003c/td\u003e\n\u003c/tr\u003e\n\u003ctr class=\"even\"\u003e\n\u003ctd style=\"text-align: left;\"\u003e\u003cp\u003esc.shared.PlayerColor\u003c/p\u003e\u003c/td\u003e\n\u003ctd style=\"text-align: left;\"\u003e\u003cp\u003e\u003cem\u003egetPlayerColor()\u003c/em\u003e\u003cbr /\u003e\nDie Farbe dieses Spielers auf dem Spielbrett\u003c/p\u003e\u003c/td\u003e\n\u003c/tr\u003e\n\u003ctr class=\"odd\"\u003e\n\u003ctd style=\"text-align: left;\"\u003e\u003cp\u003eint\u003c/p\u003e\u003c/td\u003e\n\u003ctd style=\"text-align: left;\"\u003e\u003cp\u003e\u003cem\u003egetSalads()\u003c/em\u003e\u003cbr /\u003e\nDie Anzahl der Salate, die dieser Spieler noch verspeisen muss.\u003c/p\u003e\u003c/td\u003e\n\u003c/tr\u003e\n\u003ctr class=\"even\"\u003e\n\u003ctd style=\"text-align: left;\"\u003e\u003cp\u003eboolean\u003c/p\u003e\u003c/td\u003e\n\u003ctd style=\"text-align: left;\"\u003e\u003cp\u003e\u003cem\u003einGoal()\u003c/em\u003e\u003cbr /\u003e\nÜberprüft, ob Spieler im Ziel.\u003c/p\u003e\u003c/td\u003e\n\u003c/tr\u003e\n\u003ctr class=\"odd\"\u003e\n\u003ctd style=\"text-align: left;\"\u003e\u003cp\u003eboolean\u003c/p\u003e\u003c/td\u003e\n\u003ctd style=\"text-align: left;\"\u003e\u003cp\u003e\u003cem\u003eownsCardOfType(CardType\ntype)\u003c/em\u003e\u003cbr /\u003e\nÜberprüft ob Spieler bestimmte Karte noch besitzt\u003c/p\u003e\u003c/td\u003e\n\u003c/tr\u003e\n\u003c/tbody\u003e\n\u003c/table\u003e\n\nDie Vollständige API ist in /doc/sc/plugin2018/Player.html zu finden.\n\nDie Meisten dieser Funktionen sind selbsterklärend. Dennoch sind hier\neinige Beispiele angegeben:\n\n    System.out.print(\"Du hast noch folgende Karten: \");\n    for (CardType c : currentPlayer.getCards()) {\n        System.out.print(c + \" \");\n    }\n    System.out.println();\n\nDies würde alle Karten ausgeben, welche man noch hat.\n\n    if (currentPlayer.inGoal() \u0026\u0026 !currentPlayer.getCards().isEmpty()) {\n        System.out.println(\"Was fuer eine Verschwendung.\");\n    }\n\nDie If-Bedingung würde dann ausgeführt werden, wenn man im Ziel ist,\nallerdings noch Karten hat.\n\nEine weitere wichtige Funktion ist *getFieldIndex*. Diese Funktion wird\nhäufig im Dokument „Hase\\_Igel\\_Spielbrett“ verwendet.\n\nNeben diesen Funktionen existieren noch einige „Setter“. Diese sind\nallerdings hauptsächlich für den Server notwendig und haben einen\ngeringen praktischen Nutzten für uns.\n\n## Aufgabe\n\nSchreibe eine If-Bedingung, welche abfragt, ob beide Spieler auf dem\nselben Feld sind. Da dies nur möglich ist, wenn man auf dem Start-\nZielfeld ist, soll zunächst abgefragt werden, ob der aktuelle Spieler\nauf dem Start- Zielfeld ist. Tipp: Es gibt die Funktion getTypeAt der\nKlasse Board. Weiter Informationen sind im Dokument\n„Hase\\_Igel\\_Spielbrett“ zu finden.\n\n# GameRuleLogic: Hilfreiche Hilfsfunktionen\n\nDie Klasse GameRuleLogic hat viele Hilfsfunktionen, mit welchen man die\nRegeln des Spieles überprüfen kann. Hierbei sind alle Funktionen static.\nD.h., dass man sie ohne eine Instanz aufrufen kann.\n\n\u003ctable\u003e\n\u003ccolgroup\u003e\n\u003ccol style=\"width: 50%\" /\u003e\n\u003ccol style=\"width: 50%\" /\u003e\n\u003c/colgroup\u003e\n\u003ctbody\u003e\n\u003ctr class=\"odd\"\u003e\n\u003ctd style=\"text-align: left;\"\u003e\u003cp\u003estatic int\u003c/p\u003e\u003c/td\u003e\n\u003ctd style=\"text-align: left;\"\u003e\u003cp\u003e\u003cem\u003ecalculateCarrots(int\nmoveCount)\u003c/em\u003e\u003cbr /\u003e\nBerechnet wie viele Karotten für einen Zug der Länge moveCount benötigt\nwerden.\u003c/p\u003e\u003c/td\u003e\n\u003c/tr\u003e\n\u003ctr class=\"even\"\u003e\n\u003ctd style=\"text-align: left;\"\u003e\u003cp\u003estatic int\u003c/p\u003e\u003c/td\u003e\n\u003ctd style=\"text-align: left;\"\u003e\u003cp\u003e\u003cem\u003ecalculateMoveableFields(int\ncarrots)\u003c/em\u003e\u003cbr /\u003e\nBerechnet, wie weit man mit carrots Karotten gehen kann. Beispiel: Mit\n68 Karotten kann man 11 Felder weit gehen.\u003c/p\u003e\u003c/td\u003e\n\u003c/tr\u003e\n\u003ctr class=\"odd\"\u003e\n\u003ctd style=\"text-align: left;\"\u003e\u003cp\u003estatic boolean\u003c/p\u003e\u003c/td\u003e\n\u003ctd style=\"text-align: left;\"\u003e\u003cp\u003e\u003cem\u003ecanPlayCard(GameState\nstate)*\u003c/em\u003e\u003cbr /\u003e\nGibt zurück, ob der derzeitige Spieler eine Karte spielen kann.\u003c/p\u003e\u003c/td\u003e\n\u003c/tr\u003e\n\u003ctr class=\"even\"\u003e\n\u003ctd style=\"text-align: left;\"\u003e\u003cp\u003estatic boolean\u003c/p\u003e\u003c/td\u003e\n\u003ctd style=\"text-align: left;\"\u003e\u003cp\u003e\u003cem\u003eisValidToAdvance(GameState state,\nint distance)\u003c/em\u003e\u003cbr /\u003e\nÜberprüft \u003cem\u003eAdvance\u003c/em\u003e Aktionen auf ihre Korrektheit.\n\u003cem\u003eDistance\u003c/em\u003e steht für die Distanz die man zurücklegen\nwill.Three\u003c/p\u003e\u003c/td\u003e\n\u003c/tr\u003e\n\u003ctr class=\"odd\"\u003e\n\u003ctd style=\"text-align: left;\"\u003e\u003cp\u003estatic boolean\u003c/p\u003e\u003c/td\u003e\n\u003ctd style=\"text-align: left;\"\u003e\u003cp\u003e\u003cem\u003eisValidToEat(GameState\nstate)\u003c/em\u003e\u003cbr /\u003e\nÜberprüft \u003cem\u003eEatSalad\u003c/em\u003e Züge auf Korrektheit. Diese Funktion bezieht\nsich \u003cstrong\u003enicht\u003c/strong\u003e auf die Karte\n\u003cem\u003eTAKE_OR_DROP_CARROTS\u003c/em\u003e\u003c/p\u003e\u003c/td\u003e\n\u003c/tr\u003e\n\u003ctr class=\"even\"\u003e\n\u003ctd style=\"text-align: left;\"\u003e\u003cp\u003estatic boolean\u003c/p\u003e\u003c/td\u003e\n\u003ctd style=\"text-align: left;\"\u003e\u003cp\u003e\u003cem\u003eisValidToExchangeCarrots(GameState\nstate, int n)\u003c/em\u003e\u003cbr /\u003e\nÜberprüft ob der derzeitige Spieler 10 Karotten nehmen oder abgeben\nkann. „n“ kann entweder 10 oder -10 sein. Je nachdem ob man annehmen\noder abgeben will. Diese Funktion bezieht sich \u003cstrong\u003enicht\u003c/strong\u003e\nauf die Karte \u003cem\u003eEAT_SALAD\u003c/em\u003e.\u003c/p\u003e\u003c/td\u003e\n\u003c/tr\u003e\n\u003ctr class=\"odd\"\u003e\n\u003ctd style=\"text-align: left;\"\u003e\u003cp\u003estatic boolean\u003c/p\u003e\u003c/td\u003e\n\u003ctd style=\"text-align: left;\"\u003e\u003cp\u003e\u003cem\u003eisValidToFallBack(GameState\nstate)\u003c/em\u003e\u003cbr /\u003e\nÜberprüft \u003cem\u003eFallBack\u003c/em\u003e Züge auf Korrektheit\u003c/p\u003e\u003c/td\u003e\n\u003c/tr\u003e\n\u003ctr class=\"even\"\u003e\n\u003ctd style=\"text-align: left;\"\u003e\u003cp\u003estatic boolean\u003c/p\u003e\u003c/td\u003e\n\u003ctd style=\"text-align: left;\"\u003e\u003cp\u003e\u003cem\u003eisValidToPlayCard(GameState state,\nCardType c,int n)*\u003c/em\u003e\u003cbr /\u003e\nÜberprüft ob der derzeitige Spieler die Karte spielen kann. „n“ wird für\ndie \u003cem\u003eTAKE_OR_DROP_CARROTS\u003c/em\u003e Karte benötigt (s.u). „n“ kann die\nWert 0, 20 oder -20 annehmen.\u003c/p\u003e\u003c/td\u003e\n\u003c/tr\u003e\n\u003ctr class=\"odd\"\u003e\n\u003ctd style=\"text-align: left;\"\u003e\u003cp\u003estatic boolean\u003c/p\u003e\u003c/td\u003e\n\u003ctd style=\"text-align: left;\"\u003e\u003cp\u003e\u003cem\u003eisValidToPlayEatSalad(GameState\nstate)*\u003c/em\u003e\u003cbr /\u003e\nÜberprüft ob der derzeitige Spieler die \u003cem\u003eEAT_SALAD\u003c/em\u003e Karte spielen\ndarf.\u003c/p\u003e\u003c/td\u003e\n\u003c/tr\u003e\n\u003ctr class=\"even\"\u003e\n\u003ctd style=\"text-align: left;\"\u003e\u003cp\u003estatic boolean\u003c/p\u003e\u003c/td\u003e\n\u003ctd style=\"text-align: left;\"\u003e\u003cp\u003e\u003cem\u003eisValidToPlayFallBack(GameState\nstate)*\u003c/em\u003e\u003cbr /\u003e\nÜberprüft ob der derzeitige Spieler die \u003cem\u003eFALL_BACK\u003c/em\u003e Karte spielen\ndarf.\u003c/p\u003e\u003c/td\u003e\n\u003c/tr\u003e\n\u003ctr class=\"odd\"\u003e\n\u003ctd style=\"text-align: left;\"\u003e\u003cp\u003estatic boolean\u003c/p\u003e\u003c/td\u003e\n\u003ctd style=\"text-align: left;\"\u003e\u003cp\u003e\u003cem\u003eisValidToPlayHurryAhead(GameState\nstate) *\u003c/em\u003e\u003cbr /\u003e\nÜberprüft ob der derzeitige Spieler die \u003cem\u003eHURRY_AHEAD\u003c/em\u003e Karte\nspielen darf.\u003c/p\u003e\u003c/td\u003e\n\u003c/tr\u003e\n\u003ctr class=\"even\"\u003e\n\u003ctd style=\"text-align: left;\"\u003e\u003cp\u003estatic boolean\u003c/p\u003e\u003c/td\u003e\n\u003ctd\nstyle=\"text-align: left;\"\u003e\u003cp\u003e\u003cem\u003eisValidToPlayTakeOrDropCarrots(GameState\nstate,int n)*\u003c/em\u003e\u003cbr /\u003e\nÜberprüft ob der derzeitige Spieler die \u003cem\u003eTAKE_OR_DROP_CARROTS\u003c/em\u003e\nKarte spielen darf. „n“ kann entweder 0, 20 oder -20 sein.\u003c/p\u003e\u003c/td\u003e\n\u003c/tr\u003e\n\u003ctr class=\"odd\"\u003e\n\u003ctd style=\"text-align: left;\"\u003e\u003cp\u003estatic boolean\u003c/p\u003e\u003c/td\u003e\n\u003ctd style=\"text-align: left;\"\u003e\u003cp\u003e\u003cem\u003eisValidToSkip(GameState\nstate)\u003c/em\u003e\u003cbr /\u003e\nÜberprüft, ob der derzeitige Spieler aussetzen darf.\u003c/p\u003e\u003c/td\u003e\n\u003c/tr\u003e\n\u003ctr class=\"even\"\u003e\n\u003ctd style=\"text-align: left;\"\u003e\u003cp\u003estatic boolean\u003c/p\u003e\u003c/td\u003e\n\u003ctd style=\"text-align: left;\"\u003e\u003cp\u003e\u003cem\u003emustEatSalad(GameState\nstate)\u003c/em\u003e\u003cbr /\u003e\nÜberprüft ob man einen Salat fressen muss. Dies ist immer der Fall, wenn\nman in der vorherigen Runde ein Salatfeld betreten hat.\u003c/p\u003e\u003c/td\u003e\n\u003c/tr\u003e\n\u003ctr class=\"odd\"\u003e\n\u003ctd style=\"text-align: left;\"\u003e\u003cp\u003estatic boolean\u003c/p\u003e\u003c/td\u003e\n\u003ctd style=\"text-align: left;\"\u003e\u003cp\u003e\u003cem\u003emustPlayCard(GameState state)\n*\u003c/em\u003e\u003cbr /\u003e\nÜberprüft ob eine Karte gespielt werden muss.\u003c/p\u003e\u003c/td\u003e\n\u003c/tr\u003e\n\u003ctr class=\"even\"\u003e\n\u003ctd style=\"text-align: left;\"\u003e\u003cp\u003estatic boolean\u003c/p\u003e\u003c/td\u003e\n\u003ctd style=\"text-align: left;\"\u003e\u003cp\u003e\u003cem\u003eplayerMustAdvance(GameState\nstate)\u003c/em\u003e\u003cbr /\u003e\nÜberprüft ab der derzeitige Spieler im nächsten Zug einen Vorwärtszug\nmachen muss.\u003c/p\u003e\u003c/td\u003e\n\u003c/tr\u003e\n\u003c/tbody\u003e\n\u003c/table\u003e\n\n\\*Diese Funktionen werden im Kapitel „Erweiterte Beispiele“ besprochen.\n\nDie komplette API-Dokumentation ist in\ndoc/sc/plugin2018/util/GameRuleLogic.html zu finden.\n\n## Simulation des Gegners\n\nNatürlich kann man alle diese Funktionen auch auf den Gegenspieler\nanwenden. Dafür müssen wir allerdings eine Kopie des GameState\nerstellen:\n\n    try {\n      GameState otherGame = gameState.clone(); // Deep-Copy\n      // Rundenanzahl hochsetzten für switch Befehl:\n      otherGame.setTurn(gameState.getTurn()+1);\n      // Tausche currentPlayer (hängt von der Rundenanzahl ab):\n      otherGame.switchCurrentPlayer();\n      // Gib Informationen über den Gegner aus:\n      System.out.println(\"CurrentPlayer von otherGame:\" + otherGame.getCurrentPlayer());\n    } catch (CloneNotSupportedException e1) { // Fehlerbehandlung\n      e1.printStackTrace();\n    }\n\nAlle Funktionen von GameRuleLogic können wir nun, mithilfe der Variable\notherGame, auf den Gegner anwenden.\n\n## Einführende Beispiele\n\nDie meisten Funktionen dieser Klasse sind selbsterklärend. Dennoch\nwerden einige der häufig verwendeten Funktionen mit kleinen Beispielen\nvorgestellt.\n\n    if (GameRuleLogic.isValidToEat(gameState) != GameRuleLogic.mustEatSalad(gameState)) {\n      System.out.println(\"Unmöglich\");\n    }\n\nNach den Regeln muss man immer ein Salat essen, wenn man im vorherigen\nZug ein Salatfeld betreten hat. Außerdem ist dies die einzige\nMöglichkeit die Aktion EatSalad auszuführen (nicht mit dem Spielen der\nEAT\\_SALAD Karte verwechseln).\n\nDadurch wird auch die Unerfüllbarkeit des folgenden Ausdrucks\nimpliziert:\n\n    if (GameRuleLogic.isValidToEat(gameState) \u0026\u0026\n        (GameRuleLogic.isValidToFallBack(gameState) || GameRuleLogic.canMove(gameState))) {\n      System.out.println(\"Unmöglich\");\n    }\n\nEine weiter hilfreiche Funktion ist *isValidToAdvance*. Mit dieser\nFunktion wird überprüft, ob ein Vorwärtszug mit der übergeben Distanz\nüberhaupt möglich ist:\n\n    // berechne die maximale Entfernung, welche man laufen darf\n    int max_move = GameRuleLogic.calculateMoveableFields(currentPlayer.getCarrots());\n\n    if (GameRuleLogic.isValidToAdvance(gameState, max_move +1)) {\n      System.out.println(\"Unmöglich\");\n    }\n\nDie Funktion *calculateMoveableFields* gibt hierbei die maximale\nEntfernung zurück, welche man mit den übergebenen Karotten laufen darf.\nDiese maximale Entfernung wird immer um 1 erhöht, was dazu führt, dass\nder Zug immer unmöglich ist.\n\n## Erweitertes Beispiel\n\nAlle Funktionen die mit einem \\* markiert wurden (s.o) haben eine\nGemeinsamkeit. Sie beziehen sich auf das Spielen von Karten. Das Spielen\nvon Karten ist allerdings nur erlaubt, wenn man das entsprechende\nHasenfeld in der selben Zug betreten hat. Deshalb müssen wir GameState\nbearbeiten, damit diese Funktionen überhaupt Sinn haben. Das folgende\nBeispiel gibt eine Möglichkeit an, wie man diese Funktionen einsetzten\nkann:\n\n    int nextHareFieldIndex = gameState.getNextFieldByType(FieldType.HARE,\n                                                          currentPlayer.getFieldIndex())\n    // wenn es ein nächstes Hasenfeld gibt\n    if (nextHareFieldIndex \u003e 0) {\n      try {\n\n        GameState gameHare = gameState.clone(); // erstelle Deep-Copy\n        Player harePlayer = gameHare.getCurrentPlayer(); // erstelle Shallow-Copy\n\n        //setzte den aktuellen Spieler auf ein Hasenfeld\n        harePlayer.setFieldIndex(nextHareFieldIndex);\n        System.out.println(gameHare.getCurrentPlayer().getCards()); // gib alle Karten aus\n\n        // Welche Karten kann man spielen?\n        System.out.println(\"Play EatSalad: \" +\n                           GameRuleLogic.isValidToPlayEatSalad(gameHare));\n        System.out.println(\"Play TakeOrDropCarrots: \" +\n                           GameRuleLogic.isValidToPlayTakeOrDropCarrots(gameHare,20));\n        System.out.println(\"Play HurryAhead: \" +\n                           GameRuleLogic.isValidToPlayHurryAhead(gameHare));\n        System.out.println(\"Play FallBack: \" +\n                           GameRuleLogic.isValidToPlayFallBack(gameHare));\n\n      } catch (CloneNotSupportedException e1) {\n        e1.printStackTrace();\n      }\n    }\n\nHierfür müssen wir den Spieler einfach nur auf das Hasenfeld setzten.\nAllerdings wird nicht überprüft, ob der Spieler überhaupt bis zum\nnächsten Hasenfeld laufen kann.\n\n## Aufgaben\n\n1.  Ist das Ausführen der inneren If-Bedingung wirklich unmöglich.\n    Erkläre warum oder gib ein Gegenbeispiel an:\n\n\u003c!-- --\u003e\n\n    int dif = gameState.getOtherPlayer().getFieldIndex() - currentPlayer.getFieldIndex();\n\n    if (dif \u003e= 0 \u0026\u0026\n        dif \u003c= GameRuleLogic.calculateMoveableFields(currentPlayer.getCarrots())) {\n      if (GameRuleLogic.isValidToAdvance(gameState, dif)) {\n        System.out.println(\"Unmöglich\");\n      }\n    }\n\n1.  Erweiterte das Beispiel aus dem Kapitel „Erweitertes Beispiel“ so,\n    dass sicher gestellt wird, dass der aktuelle Spieler auf ein\n    Hasenfeld gesetzt wird, welches er wirklich erreichen kann.\n\n[1] Technisch gesehen hat die Klasse eine private Liste von Feldern.\nAllerdings ähnelt ein Aufruf der Funktion getTypeAt sehr den Aufruf\neines Arrays. Auch wenn der Rückgabewert kein Feld sonder ein FieldType\nist.\n","toc":{"headings":[{"level":1,"label":"Start zum Schreiben einer KI","anchor":"start-zum-schreiben-einer-ki"},{"level":2,"label":"Wo schreibe ich die KI?","anchor":"wo-schreibe-ich-die-ki"},{"level":2,"label":"Wichtige Membervariablen","anchor":"wichtige-membervariablen"},{"level":2,"label":"Aufgaben","anchor":"aufgaben"},{"level":1,"label":"Spielbrett Informationen","anchor":"spielbrett-informationen"},{"level":2,"label":"Die Klasse „FieldType“","anchor":"die-klasse-fieldtype"},{"level":2,"label":"Funktionen der Klasse „Board“","anchor":"funktionen-der-klasse-board"},{"level":3,"label":"public final int getNextFieldByType(FieldType type,int pos)","anchor":"public-final-int-getnextfieldbytypefieldtype-typeint-pos"},{"level":3,"label":"public final int getPreviousFieldByType(FieldType type,int pos)","anchor":"public-final-int-getpreviousfieldbytypefieldtype-typeint-pos"},{"level":3,"label":"public final FieldType getTypeAt(int pos)","anchor":"public-final-fieldtype-gettypeatint-pos"},{"level":2,"label":"Aufgaben","anchor":"aufgaben"},{"level":1,"label":"Die Klasse Player","anchor":"die-klasse-player"},{"level":2,"label":"Aufgabe","anchor":"aufgabe"},{"level":1,"label":"GameRuleLogic: Hilfreiche Hilfsfunktionen","anchor":"gamerulelogic-hilfreiche-hilfsfunktionen"},{"level":2,"label":"Simulation des Gegners","anchor":"simulation-des-gegners"},{"level":2,"label":"Einführende Beispiele","anchor":"einfhrende-beispiele"},{"level":2,"label":"Erweitertes Beispiel","anchor":"erweitertes-beispiel"},{"level":2,"label":"Aufgaben","anchor":"aufgaben"}]},"navigation":{"next":{"href":"/spiele/hase-und-igel/xml-dokumentation/einleitung-xml","repo":"https://github.com/software-challenge/docs/tree/main/hyperbook/book/spiele/hase-und-igel/xml-dokumentation/einleitung-xml.md"},"current":{"href":"/spiele/hase-und-igel/tutorial/tutorial","repo":"https://github.com/software-challenge/docs/tree/main/hyperbook/book/spiele/hase-und-igel/tutorial/tutorial.md"},"previous":{"href":"/spiele/hase-und-igel/tutorial/start","repo":"https://github.com/software-challenge/docs/tree/main/hyperbook/book/spiele/hase-und-igel/tutorial/start.md"},"sections":[{"name":"Die Software-Challenge","index":0,"href":"/allgemein","isEmpty":false,"pages":[{"name":"Wettkampfmodalitäten","index":2,"href":"/allgemein/wettkampf","repo":"https://github.com/software-challenge/docs/tree/main/hyperbook/book/allgemein/wettkampf.md"},{"name":"Das Spiel kennenlernen","index":3,"href":"/allgemein/spiel","repo":"https://github.com/software-challenge/docs/tree/main/hyperbook/book/allgemein/spiel.md"}],"sections":[],"repo":"https://github.com/software-challenge/docs/tree/main/hyperbook/book/allgemein/index.md"},{"name":"Spiele","index":1,"virtual":true,"href":"/spiele","isEmpty":true,"pages":[],"sections":[{"name":"Blokus","hide":true,"href":"/spiele/blokus","isEmpty":false,"pages":[],"sections":[{"name":"Spielregeln","hide":true,"href":"/spiele/blokus/spielregeln","isEmpty":true,"pages":[{"href":"/spiele/blokus/spielregeln/content","repo":"https://github.com/software-challenge/docs/tree/main/hyperbook/book/spiele/blokus/spielregeln/content.md"},{"href":"/spiele/blokus/spielregeln/regeln","repo":"https://github.com/software-challenge/docs/tree/main/hyperbook/book/spiele/blokus/spielregeln/regeln.md"}],"sections":[],"repo":"https://github.com/software-challenge/docs/tree/main/hyperbook/book/spiele/blokus/spielregeln/index.md"},{"name":"XML-Dokumentation","hide":true,"href":"/spiele/blokus/xml-dokumentation","isEmpty":true,"pages":[{"href":"/spiele/blokus/xml-dokumentation/einleitung-xml","repo":"https://github.com/software-challenge/docs/tree/main/hyperbook/book/spiele/blokus/xml-dokumentation/einleitung-xml.md"},{"href":"/spiele/blokus/xml-dokumentation/spiel-betreten","repo":"https://github.com/software-challenge/docs/tree/main/hyperbook/book/spiele/blokus/xml-dokumentation/spiel-betreten.md"},{"href":"/spiele/blokus/xml-dokumentation/spiel-verlassen","repo":"https://github.com/software-challenge/docs/tree/main/hyperbook/book/spiele/blokus/xml-dokumentation/spiel-verlassen.md"},{"href":"/spiele/blokus/xml-dokumentation/spielergebnis","repo":"https://github.com/software-challenge/docs/tree/main/hyperbook/book/spiele/blokus/xml-dokumentation/spielergebnis.md"},{"href":"/spiele/blokus/xml-dokumentation/spielstatus","repo":"https://github.com/software-challenge/docs/tree/main/hyperbook/book/spiele/blokus/xml-dokumentation/spielstatus.md"},{"href":"/spiele/blokus/xml-dokumentation/spielsteine","repo":"https://github.com/software-challenge/docs/tree/main/hyperbook/book/spiele/blokus/xml-dokumentation/spielsteine.md"},{"href":"/spiele/blokus/xml-dokumentation/spielverlauf","repo":"https://github.com/software-challenge/docs/tree/main/hyperbook/book/spiele/blokus/xml-dokumentation/spielverlauf.md"},{"href":"/spiele/blokus/xml-dokumentation/xml-dokumentation","repo":"https://github.com/software-challenge/docs/tree/main/hyperbook/book/spiele/blokus/xml-dokumentation/xml-dokumentation.md"},{"href":"/spiele/blokus/xml-dokumentation/zuege-senden","repo":"https://github.com/software-challenge/docs/tree/main/hyperbook/book/spiele/blokus/xml-dokumentation/zuege-senden.md"},{"href":"/spiele/blokus/xml-dokumentation/zug-anforderung","repo":"https://github.com/software-challenge/docs/tree/main/hyperbook/book/spiele/blokus/xml-dokumentation/zug-anforderung.md"}],"sections":[],"repo":"https://github.com/software-challenge/docs/tree/main/hyperbook/book/spiele/blokus/xml-dokumentation/index.md"}],"repo":"https://github.com/software-challenge/docs/tree/main/hyperbook/book/spiele/blokus/index.md"},{"name":"Hase und Igel","hide":true,"href":"/spiele/hase-und-igel","isEmpty":false,"pages":[],"sections":[{"name":"Spielregeln","hide":true,"href":"/spiele/hase-und-igel/spielregeln","isEmpty":true,"pages":[{"href":"/spiele/hase-und-igel/spielregeln/beispiel","repo":"https://github.com/software-challenge/docs/tree/main/hyperbook/book/spiele/hase-und-igel/spielregeln/beispiel.md"},{"href":"/spiele/hase-und-igel/spielregeln/felder","repo":"https://github.com/software-challenge/docs/tree/main/hyperbook/book/spiele/hase-und-igel/spielregeln/felder.md"},{"href":"/spiele/hase-und-igel/spielregeln/regeln","repo":"https://github.com/software-challenge/docs/tree/main/hyperbook/book/spiele/hase-und-igel/spielregeln/regeln.md"},{"href":"/spiele/hase-und-igel/spielregeln/spielbeginn","repo":"https://github.com/software-challenge/docs/tree/main/hyperbook/book/spiele/hase-und-igel/spielregeln/spielbeginn.md"},{"href":"/spiele/hase-und-igel/spielregeln/spielende","repo":"https://github.com/software-challenge/docs/tree/main/hyperbook/book/spiele/hase-und-igel/spielregeln/spielende.md"},{"href":"/spiele/hase-und-igel/spielregeln/zuege","repo":"https://github.com/software-challenge/docs/tree/main/hyperbook/book/spiele/hase-und-igel/spielregeln/zuege.md"}],"sections":[],"repo":"https://github.com/software-challenge/docs/tree/main/hyperbook/book/spiele/hase-und-igel/spielregeln/index.md"},{"name":"Tutorial","hide":true,"href":"/spiele/hase-und-igel/tutorial","isEmpty":true,"pages":[{"href":"/spiele/hase-und-igel/tutorial/board","repo":"https://github.com/software-challenge/docs/tree/main/hyperbook/book/spiele/hase-und-igel/tutorial/board.md"},{"href":"/spiele/hase-und-igel/tutorial/game-rule-logic","repo":"https://github.com/software-challenge/docs/tree/main/hyperbook/book/spiele/hase-und-igel/tutorial/game-rule-logic.md"},{"href":"/spiele/hase-und-igel/tutorial/player","repo":"https://github.com/software-challenge/docs/tree/main/hyperbook/book/spiele/hase-und-igel/tutorial/player.md"},{"href":"/spiele/hase-und-igel/tutorial/start","repo":"https://github.com/software-challenge/docs/tree/main/hyperbook/book/spiele/hase-und-igel/tutorial/start.md"},{"href":"/spiele/hase-und-igel/tutorial/tutorial","repo":"https://github.com/software-challenge/docs/tree/main/hyperbook/book/spiele/hase-und-igel/tutorial/tutorial.md"}],"sections":[],"repo":"https://github.com/software-challenge/docs/tree/main/hyperbook/book/spiele/hase-und-igel/tutorial/index.md"},{"name":"XML-Dokumentation","hide":true,"href":"/spiele/hase-und-igel/xml-dokumentation","isEmpty":true,"pages":[{"href":"/spiele/hase-und-igel/xml-dokumentation/einleitung-xml","repo":"https://github.com/software-challenge/docs/tree/main/hyperbook/book/spiele/hase-und-igel/xml-dokumentation/einleitung-xml.md"},{"href":"/spiele/hase-und-igel/xml-dokumentation/fehler","repo":"https://github.com/software-challenge/docs/tree/main/hyperbook/book/spiele/hase-und-igel/xml-dokumentation/fehler.md"},{"href":"/spiele/hase-und-igel/xml-dokumentation/spiel-betreten","repo":"https://github.com/software-challenge/docs/tree/main/hyperbook/book/spiele/hase-und-igel/xml-dokumentation/spiel-betreten.md"},{"href":"/spiele/hase-und-igel/xml-dokumentation/spiel-verlassen","repo":"https://github.com/software-challenge/docs/tree/main/hyperbook/book/spiele/hase-und-igel/xml-dokumentation/spiel-verlassen.md"},{"href":"/spiele/hase-und-igel/xml-dokumentation/spielergebnis","repo":"https://github.com/software-challenge/docs/tree/main/hyperbook/book/spiele/hase-und-igel/xml-dokumentation/spielergebnis.md"},{"href":"/spiele/hase-und-igel/xml-dokumentation/spielstatus","repo":"https://github.com/software-challenge/docs/tree/main/hyperbook/book/spiele/hase-und-igel/xml-dokumentation/spielstatus.md"},{"href":"/spiele/hase-und-igel/xml-dokumentation/spielverlauf","repo":"https://github.com/software-challenge/docs/tree/main/hyperbook/book/spiele/hase-und-igel/xml-dokumentation/spielverlauf.md"},{"href":"/spiele/hase-und-igel/xml-dokumentation/xml-dokumentation","repo":"https://github.com/software-challenge/docs/tree/main/hyperbook/book/spiele/hase-und-igel/xml-dokumentation/xml-dokumentation.md"},{"href":"/spiele/hase-und-igel/xml-dokumentation/zuege-senden","repo":"https://github.com/software-challenge/docs/tree/main/hyperbook/book/spiele/hase-und-igel/xml-dokumentation/zuege-senden.md"},{"href":"/spiele/hase-und-igel/xml-dokumentation/zug-anforderung","repo":"https://github.com/software-challenge/docs/tree/main/hyperbook/book/spiele/hase-und-igel/xml-dokumentation/zug-anforderung.md"}],"sections":[],"repo":"https://github.com/software-challenge/docs/tree/main/hyperbook/book/spiele/hase-und-igel/xml-dokumentation/index.md"}],"repo":"https://github.com/software-challenge/docs/tree/main/hyperbook/book/spiele/hase-und-igel/index.md"},{"name":"Hive","hide":true,"href":"/spiele/hive","isEmpty":false,"pages":[],"sections":[{"name":"Spielregeln","hide":true,"href":"/spiele/hive/spielregeln","isEmpty":true,"pages":[{"href":"/spiele/hive/spielregeln/regeln","repo":"https://github.com/software-challenge/docs/tree/main/hyperbook/book/spiele/hive/spielregeln/regeln.md"}],"sections":[],"repo":"https://github.com/software-challenge/docs/tree/main/hyperbook/book/spiele/hive/spielregeln/index.md"},{"name":"XML-Dokumention","hide":true,"href":"/spiele/hive/xml-dokumentation","isEmpty":true,"pages":[{"href":"/spiele/hive/xml-dokumentation/einleitung-xml","repo":"https://github.com/software-challenge/docs/tree/main/hyperbook/book/spiele/hive/xml-dokumentation/einleitung-xml.md"},{"href":"/spiele/hive/xml-dokumentation/fehler","repo":"https://github.com/software-challenge/docs/tree/main/hyperbook/book/spiele/hive/xml-dokumentation/fehler.md"},{"href":"/spiele/hive/xml-dokumentation/spiel-betreten","repo":"https://github.com/software-challenge/docs/tree/main/hyperbook/book/spiele/hive/xml-dokumentation/spiel-betreten.md"},{"href":"/spiele/hive/xml-dokumentation/spiel-verlassen","repo":"https://github.com/software-challenge/docs/tree/main/hyperbook/book/spiele/hive/xml-dokumentation/spiel-verlassen.md"},{"href":"/spiele/hive/xml-dokumentation/spielergebnis","repo":"https://github.com/software-challenge/docs/tree/main/hyperbook/book/spiele/hive/xml-dokumentation/spielergebnis.md"},{"href":"/spiele/hive/xml-dokumentation/spielstatus","repo":"https://github.com/software-challenge/docs/tree/main/hyperbook/book/spiele/hive/xml-dokumentation/spielstatus.md"},{"href":"/spiele/hive/xml-dokumentation/spielverlauf","repo":"https://github.com/software-challenge/docs/tree/main/hyperbook/book/spiele/hive/xml-dokumentation/spielverlauf.md"},{"href":"/spiele/hive/xml-dokumentation/xml-dokumentation","repo":"https://github.com/software-challenge/docs/tree/main/hyperbook/book/spiele/hive/xml-dokumentation/xml-dokumentation.md"},{"href":"/spiele/hive/xml-dokumentation/zuege-senden","repo":"https://github.com/software-challenge/docs/tree/main/hyperbook/book/spiele/hive/xml-dokumentation/zuege-senden.md"},{"href":"/spiele/hive/xml-dokumentation/zug-anforderung","repo":"https://github.com/software-challenge/docs/tree/main/hyperbook/book/spiele/hive/xml-dokumentation/zug-anforderung.md"}],"sections":[],"repo":"https://github.com/software-challenge/docs/tree/main/hyperbook/book/spiele/hive/xml-dokumentation/index.md"}],"repo":"https://github.com/software-challenge/docs/tree/main/hyperbook/book/spiele/hive/index.md"},{"name":"Ostseeschach","hide":true,"href":"/spiele/ostseeschach","isEmpty":false,"pages":[{"href":"/spiele/ostseeschach/regeln","repo":"https://github.com/software-challenge/docs/tree/main/hyperbook/book/spiele/ostseeschach/regeln.md"},{"href":"/spiele/ostseeschach/xml-dokumentation","repo":"https://github.com/software-challenge/docs/tree/main/hyperbook/book/spiele/ostseeschach/xml-dokumentation.md"}],"sections":[],"repo":"https://github.com/software-challenge/docs/tree/main/hyperbook/book/spiele/ostseeschach/index.md"},{"name":"Hey, Danke für den Fisch!","index":1,"href":"/spiele/penguins","isEmpty":false,"pages":[{"name":"Spielregeln","index":1,"href":"/spiele/penguins/regeln","repo":"https://github.com/software-challenge/docs/tree/main/hyperbook/book/spiele/penguins/regeln.md"},{"name":"XML-Schnittstelle","href":"/spiele/penguins/xml","repo":"https://github.com/software-challenge/docs/tree/main/hyperbook/book/spiele/penguins/xml.md"}],"sections":[],"repo":"https://github.com/software-challenge/docs/tree/main/hyperbook/book/spiele/penguins/index.md"},{"name":"Piranhas","hide":true,"href":"/spiele/piranhas","isEmpty":false,"pages":[],"sections":[{"name":"Spielregeln","hide":true,"href":"/spiele/piranhas/spielregeln","isEmpty":true,"pages":[{"href":"/spiele/piranhas/spielregeln/regeln","repo":"https://github.com/software-challenge/docs/tree/main/hyperbook/book/spiele/piranhas/spielregeln/regeln.md"}],"sections":[],"repo":"https://github.com/software-challenge/docs/tree/main/hyperbook/book/spiele/piranhas/spielregeln/index.md"},{"name":"XML-Dokumentation","hide":true,"href":"/spiele/piranhas/xml-dokumentation","isEmpty":true,"pages":[{"href":"/spiele/piranhas/xml-dokumentation/einleitung-xml","repo":"https://github.com/software-challenge/docs/tree/main/hyperbook/book/spiele/piranhas/xml-dokumentation/einleitung-xml.md"},{"href":"/spiele/piranhas/xml-dokumentation/fehler","repo":"https://github.com/software-challenge/docs/tree/main/hyperbook/book/spiele/piranhas/xml-dokumentation/fehler.md"},{"href":"/spiele/piranhas/xml-dokumentation/spiel-betreten","repo":"https://github.com/software-challenge/docs/tree/main/hyperbook/book/spiele/piranhas/xml-dokumentation/spiel-betreten.md"},{"href":"/spiele/piranhas/xml-dokumentation/spiel-verlassen","repo":"https://github.com/software-challenge/docs/tree/main/hyperbook/book/spiele/piranhas/xml-dokumentation/spiel-verlassen.md"},{"href":"/spiele/piranhas/xml-dokumentation/spielergebnis","repo":"https://github.com/software-challenge/docs/tree/main/hyperbook/book/spiele/piranhas/xml-dokumentation/spielergebnis.md"},{"href":"/spiele/piranhas/xml-dokumentation/spielstatus","repo":"https://github.com/software-challenge/docs/tree/main/hyperbook/book/spiele/piranhas/xml-dokumentation/spielstatus.md"},{"href":"/spiele/piranhas/xml-dokumentation/spielverlauf","repo":"https://github.com/software-challenge/docs/tree/main/hyperbook/book/spiele/piranhas/xml-dokumentation/spielverlauf.md"},{"href":"/spiele/piranhas/xml-dokumentation/xml-dokumentation","repo":"https://github.com/software-challenge/docs/tree/main/hyperbook/book/spiele/piranhas/xml-dokumentation/xml-dokumentation.md"},{"href":"/spiele/piranhas/xml-dokumentation/zuege-senden","repo":"https://github.com/software-challenge/docs/tree/main/hyperbook/book/spiele/piranhas/xml-dokumentation/zuege-senden.md"},{"href":"/spiele/piranhas/xml-dokumentation/zug-anforderung","repo":"https://github.com/software-challenge/docs/tree/main/hyperbook/book/spiele/piranhas/xml-dokumentation/zug-anforderung.md"}],"sections":[],"repo":"https://github.com/software-challenge/docs/tree/main/hyperbook/book/spiele/piranhas/xml-dokumentation/index.md"}],"repo":"https://github.com/software-challenge/docs/tree/main/hyperbook/book/spiele/piranhas/index.md"}],"repo":"https://github.com/software-challenge/docs/tree/main/hyperbook/book/spiele/index.md"},{"name":"Entwicklung","index":2,"href":"/entwicklung","isEmpty":false,"pages":[{"name":"Objektorientierte Programmierung","index":3,"href":"/entwicklung/einfuehrung-oop","repo":"https://github.com/software-challenge/docs/tree/main/hyperbook/book/entwicklung/einfuehrung-oop.md"},{"name":"Sauberer Programmierstil","index":4,"href":"/entwicklung/sauberer-programmierstil","repo":"https://github.com/software-challenge/docs/tree/main/hyperbook/book/entwicklung/sauberer-programmierstil.md"},{"name":"Installation von Java","index":5,"href":"/entwicklung/installation-von-java","repo":"https://github.com/software-challenge/docs/tree/main/hyperbook/book/entwicklung/installation-von-java.md"},{"name":"Einrichtung der Entwicklungsumgebung","index":6,"href":"/entwicklung/einrichtung-der-entwicklungsumgebung","repo":"https://github.com/software-challenge/docs/tree/main/hyperbook/book/entwicklung/einrichtung-der-entwicklungsumgebung.md"},{"name":"Bedienung von Eclipse","index":7,"href":"/entwicklung/bedienung-von-eclipse","repo":"https://github.com/software-challenge/docs/tree/main/hyperbook/book/entwicklung/bedienung-von-eclipse.md"},{"name":"Spielervorlage erweitern","index":7,"href":"/entwicklung/simpleclient-erweitern","repo":"https://github.com/software-challenge/docs/tree/main/hyperbook/book/entwicklung/simpleclient-erweitern.md"},{"name":"Idee implementieren","index":8,"href":"/entwicklung/eine-idee-implementieren","repo":"https://github.com/software-challenge/docs/tree/main/hyperbook/book/entwicklung/eine-idee-implementieren.md"},{"name":"Computerspieler abgabefertig machen","index":9,"href":"/entwicklung/abgabe","repo":"https://github.com/software-challenge/docs/tree/main/hyperbook/book/entwicklung/abgabe.md"}],"sections":[],"repo":"https://github.com/software-challenge/docs/tree/main/hyperbook/book/entwicklung/index.md"}],"pages":[{"name":"Start","index":1,"href":"/","repo":"https://github.com/software-challenge/docs/tree/main/hyperbook/book/index.md"},{"name":"Technische Grundlagen","index":10,"href":"/glossar","repo":"https://github.com/software-challenge/docs/tree/main/hyperbook/book/glossar.md"}]}},"__N_SSG":true},"page":"/[[...page]]","query":{"page":["spiele","hase-und-igel","tutorial","tutorial"]},"buildId":"op0C_lU0uCwQl16EjqkoY","isFallback":false,"gsp":true,"scriptLoader":[]}</script></body></html>