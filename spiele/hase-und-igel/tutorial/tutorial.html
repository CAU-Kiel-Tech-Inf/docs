<!DOCTYPE html><html lang="de"><head><meta charSet="utf-8"/><meta name="viewport" content="width=device-width"/><title>tutorial - Software-Challenge Dokumentation</title><meta property="og:title" content="tutorial - Software-Challenge Dokumentation"/><meta name="description" content="Dokumentation der Software-Challenge Germany. Alle Informationen zu dem Ablauf, den technischen Grundlagen und Hilfestellungen."/><meta name="og:description" content="Dokumentation der Software-Challenge Germany. Alle Informationen zu dem Ablauf, den technischen Grundlagen und Hilfestellungen."/><meta name="next-head-count" content="6"/><link data-next-font="" rel="preconnect" href="/" crossorigin="anonymous"/><link rel="preload" href="/_next/static/css/3439ac9db3e6b67b.css" as="style"/><link rel="stylesheet" href="/_next/static/css/3439ac9db3e6b67b.css" data-n-g=""/><noscript data-n-css=""></noscript><script defer="" nomodule="" src="/_next/static/chunks/polyfills-78c92fac7aa8fdd8.js"></script><script src="/_next/static/chunks/webpack-2f1f77e8550e6a72.js" defer=""></script><script src="/_next/static/chunks/framework-ce84985cd166733a.js" defer=""></script><script src="/_next/static/chunks/main-7828853baa8ec358.js" defer=""></script><script src="/_next/static/chunks/pages/_app-558775a13df2305b.js" defer=""></script><script src="/_next/static/chunks/175675d1-03f9945557e50186.js" defer=""></script><script src="/_next/static/chunks/57e613a8-9355bccbe9da6c24.js" defer=""></script><script src="/_next/static/chunks/7834-787c6e51cd4aaa43.js" defer=""></script><script src="/_next/static/chunks/9178-67efca4cdf656709.js" defer=""></script><script src="/_next/static/chunks/pages/%5B%5B...page%5D%5D-a036fac385acb5ca.js" defer=""></script><script src="/_next/static/gJRxG6W-71yU5ToWtMTf6/_buildManifest.js" defer=""></script><script src="/_next/static/gJRxG6W-71yU5ToWtMTf6/_ssgManifest.js" defer=""></script></head><body><div id="__next"><style>:root {
            --color-brand: #3276AD;
            --color-brand-dark: #3276AD;
            --color-brand-text: white;
          }</style><style>
@font-face {
  font-family: hyperbook-body;
  src: url(/fonts/Inter-Regular.ttf);
}
</style><style>
@font-face {
  font-family: hyperbook-heading;
  src: url(/fonts/Inter-Regular.ttf);
}
</style><style>
@font-face {
  font-family: hyperbook-code;
  src: url(/fonts/SourceCodePro-Regular.ttf);
}
</style><style>
:root {
  --color-background: white;
  --color-text: black;
  --color-text-deactivated: #242428;
  --color-nav: #f5f5f5;
  --color-nav-border: #3c3c3c;
  --color-author-background: #d6d6d6;
  --color-author-color: #3c3c3c;
  --color-spacer: #a4a4a4;
}
        </style><style>
@media (prefers-color-scheme: dark) {
  :root {
    --color-background: #1e1e1e;
    --color-text: #f5f5f5;
    --color-text-deactivated: #d6d6d6;
    --color-nav: #222222;
    --color-nav-border: #464646;
    --color-author-background: #2c2c2c;
    --color-author-color: #d6d6d6;
    --color-spacer: #3c3c3c;
    --color-brand: var(--color-brand-dark);
  }

  header {
    background: var(--color-nav);
  }

  .branding {
    color: var(--color-brand);
  }

  .toggle .bar1,
  .toggle .bar2,
  .toggle .bar3 {
    background-color: var(--color-brand);
  }
}</style><div class="main-grid"><header><div class="mobile-nav"><button aria-label="Nav Toggle" class="toggle"><div class="bar1"></div><div class="bar2"></div><div class="bar3"></div></button></div><a class="branding" href="/"><div class="logo"><img alt="Logo" src="/logo.svg"/></div><div class="name">Software-Challenge Dokumentation</div></a></header><div class="sidebar"><nav><ul><li><a class="page" href="/">Start</a></li><li><a class="page" href="/glossar">Technische Grundlagen</a></li><li><a class="page" href="/bookmark">Lesezeichen</a></li><li><a class="page" href="/faq">F.A.Q.</a></li></ul><div class="section"><div class="name "><a class="label" href="/allgemein">Die Software-Challenge</a><button class="toggle" id="react-collapsed-toggle-:Rpl6:" aria-controls="react-collapsed-panel-:Rpl6:" aria-expanded="true" type="button" role="button" tabindex="0" aria-label="Close">âž–</button></div><div class="links" id="react-collapsed-panel-:Rpl6:" aria-hidden="false" role="region" style="box-sizing:border-box"><ul class="pages"><li><a class="page" href="/allgemein/wettkampf">WettkampfmodalitÃ¤ten</a></li><li><a class="page" href="/allgemein/spiel">Das Spiel kennenlernen</a></li></ul></div></div><div class="virtual-section"><div class="links"><div class="section"><div class="name "><a class="label" href="/spiele/mississippi-queen">Mississippi Queen</a><button class="toggle" id="react-collapsed-toggle-:R3b9l6:" aria-controls="react-collapsed-panel-:R3b9l6:" aria-expanded="true" type="button" role="button" tabindex="0" aria-label="Close">âž–</button></div><div class="links" id="react-collapsed-panel-:R3b9l6:" aria-hidden="false" role="region" style="box-sizing:border-box"><ul class="pages"><li><a class="page" href="/spiele/mississippi-queen/regeln">Spielregeln</a></li></ul></div></div></div></div><div class="section"><div class="name "><a class="label" href="/entwicklung">Entwicklung</a><button class="toggle" id="react-collapsed-toggle-:R1pl6:" aria-controls="react-collapsed-panel-:R1pl6:" aria-expanded="false" type="button" role="button" tabindex="0" aria-label="Open">âž•</button></div><div class="links" id="react-collapsed-panel-:R1pl6:" aria-hidden="true" role="region" style="box-sizing:border-box;display:none;height:0px;overflow:hidden"><ul class="pages"><li><a class="page" href="/entwicklung/einfuehrung-oop">Objektorientierte Programmierung</a></li><li><a class="page" href="/entwicklung/sauberer-programmierstil">Sauberer Programmierstil</a></li><li><a class="page" href="/entwicklung/installation-von-java">Installation von Java</a></li><li><a class="page" href="/entwicklung/einrichtung-der-entwicklungsumgebung">Einrichtung der Entwicklungsumgebung</a></li><li><a class="page" href="/entwicklung/bedienung-von-eclipse">Bedienung von Eclipse</a></li><li><a class="page" href="/entwicklung/simpleclient-erweitern">Spielervorlage erweitern</a></li><li><a class="page" href="/entwicklung/eine-idee-implementieren">Idee implementieren</a></li><li><a class="page" href="/entwicklung/abgabe">Computerspieler abgabefertig machen</a></li></ul></div></div></nav><a class="author" href="https://hyperbook.openpatch.org">Powered by <b>Hyperbook</b></a></div><main><article><div class="hyperbook-markdown"><button class="toc-toggle" title="Table of Contents"><div class="bar1"></div><div class="bar2"></div><div class="bar3"></div><div class="bar4"></div></button><p><a href="/tutorial.pdf">PDF-Version dieses Dokumentes</a></p>
<h1><a class="heading" id="start-zum-schreiben-einer-ki" href="#start-zum-schreiben-einer-ki"><span>Start zum Schreiben einer KI</span></a><button class="bookmark" title="Bookmark">ðŸ”–</button></h1>
<p>Am einfachsten ist es die KI auf Grundlage des Zufallsspielers zu
schreiben:</p>
<ul>
<li>
<p>Als erstes muss der Zufallsspieler heruntergeladen werden
(<a href="http://www.software-challenge.de/downloads/">http://www.software-challenge.de/downloads/</a> bitte den
Zufallsspieler als â€žQuellcodeâ€œ downloaden)</p>
</li>
<li>
<p>Dieser muss nun in Eclips eingebunden werden:
<a href="https://docs.software-challenge.de/#einrichtung-von-eclipse">https://docs.software-challenge.de/#einrichtung-von-eclipse</a></p>
</li>
</ul>
<h2><a class="heading" id="wo-schreibe-ich-die-ki" href="#wo-schreibe-ich-die-ki"><span>Wo schreibe ich die KI?</span></a><button class="bookmark" title="Bookmark">ðŸ”–</button></h2>
<p>Ist dies getan befindet sich im entsprechenden Projekt das Package
â€žsc.player2018.logicâ€œ mit einer Datei namens <strong>â€žRandomLogic.javaâ€œ</strong>.
Diese Datei mÃ¼ssen wir nun editieren.</p>
<p>In der Datei gibt es eine Funktion mit der Bezeichnung <em>public void
onRequestAction()</em>. Diese ist wie Folgt aufgebaut:</p>
<pre><code class="hljs language-scss">public void <span class="hljs-built_in">onRequestAction</span>(){
  <span class="hljs-comment">// optional: Laufzeitmessung</span>
  long startTime = System<span class="hljs-selector-class">.nanoTime</span>();


  <span class="hljs-comment">// Quellcode der KI, welche eine Zug (move) erstellt</span>


  long nowTime = System<span class="hljs-selector-class">.nanoTime</span>();

  <span class="hljs-comment">// sende Move. Danach gibt es kein zurÃ¼ck mehr:</span>
  <span class="hljs-built_in">sendAction</span>(move);

  <span class="hljs-comment">// optional: LOG-Eintrag mit Zeit:</span>
  log<span class="hljs-selector-class">.warn</span>(&quot;Time needed for turn: {}&quot;, (nowTime - startTime) / <span class="hljs-number">1000000</span>);
}
</code><button class="copy" aria-label="Copy Code"><svg xmlns="http://www.w3.org/2000/svg" stroke="currentColor" fill="currentColor" stroke-width="0" height="1em" width="1em" viewBox="0 0 24 24"><path d="M0 0h24v24H0z" fill="none"></path><path d="M16 1H4c-1.1 0-2 .9-2 2v14h2V3h12V1zm3 4H8c-1.1 0-2 .9-2 2v14c0 1.1.9 2 2 2h11c1.1 0 2-.9 2-2V7c0-1.1-.9-2-2-2zm0 16H8V7h11v14z"></path></svg></button></pre>
<p>Es ist sehr wichtig, dass alle Funktionen, welche die KI verwendet,
ihren ursprÃ¼nglichen Aufruf in der Funktion onRequestAction haben.
Dadurch wird sichergestellt, dass alle Membervariablen aktuell sind.</p>
<h2><a class="heading" id="wichtige-membervariablen" href="#wichtige-membervariablen"><span>Wichtige Membervariablen</span></a><button class="bookmark" title="Bookmark">ðŸ”–</button></h2>
<p>In der Klasse befinden sich auch drei sehr wichtige Membervariablen:</p>
<pre><code class="hljs language-arduino"><span class="hljs-keyword">private</span> Starter client; <span class="hljs-comment">// Intern fÃ¼r den Server wichtig. Bitte nicht modifizieren</span>

<span class="hljs-keyword">private</span> GameState gameState; <span class="hljs-comment">// Gibt u.a Infos Ã¼ber mÃ¶gliche ZÃ¼ge und das Spielbrett</span>

<span class="hljs-keyword">private</span> Player currentPlayer; <span class="hljs-comment">// Infos Ã¼ber den aktuellen Spieler, welchen man steuert</span>
</code><button class="copy" aria-label="Copy Code"><svg xmlns="http://www.w3.org/2000/svg" stroke="currentColor" fill="currentColor" stroke-width="0" height="1em" width="1em" viewBox="0 0 24 24"><path d="M0 0h24v24H0z" fill="none"></path><path d="M16 1H4c-1.1 0-2 .9-2 2v14h2V3h12V1zm3 4H8c-1.1 0-2 .9-2 2v14c0 1.1.9 2 2 2h11c1.1 0 2-.9 2-2V7c0-1.1-.9-2-2-2zm0 16H8V7h11v14z"></path></svg></button></pre>
<p>In den Folgenden Dokumenten werden Grundlagen zum erstellen einer KI
gezeigt. Hierbei werden wir oft die Variablen <strong>gameState</strong> und
<strong>currentPlayer</strong> verwenden.</p>
<p>Die <strong>API-Dokumentation</strong> befindet sich im Ordner â€ždocâ€œ im Verzeichnis
des Zufallsspielers.</p>
<h2><a class="heading" id="aufgaben" href="#aufgaben"><span>Aufgaben</span></a><button class="bookmark" title="Bookmark">ðŸ”–</button></h2>
<ol>
<li>
<p>Arbeite alle anderen Dokumente durch.</p>
</li>
<li>
<p>Analysiere die Herangehensweise der Zufallsspieler-KI.</p>
</li>
<li>
<p>Schreibe eine KI.</p>
</li>
</ol>
<h1><a class="heading" id="spielbrett-informationen" href="#spielbrett-informationen"><span>Spielbrett Informationen</span></a><button class="bookmark" title="Bookmark">ðŸ”–</button></h1>
<h2><a class="heading" id="die-klasse-fieldtype" href="#die-klasse-fieldtype"><span>Die Klasse â€žFieldTypeâ€œ</span></a><button class="bookmark" title="Bookmark">ðŸ”–</button></h2>
<p>Bevor wir mit der Klasse Board also dem Spielbrett arbeiten kÃ¶nnen,
mÃ¼ssen wir das Enum â€žFieldTypeâ€œ kennenlernen. Dieses Enum definiert die
einzelnen Felder des Bretts. Es gibt:</p>
<p>Die Dokumentation fÃ¼r FieldType ist in /doc/sc/plugin2018/FieldType.html
zu finden.</p>
<h2><a class="heading" id="funktionen-der-klasse-board" href="#funktionen-der-klasse-board"><span>Funktionen der Klasse â€žBoardâ€œ</span></a><button class="bookmark" title="Bookmark">ðŸ”–</button></h2>
<p>Das Spielbrett kann man sich wie einer Art modifizieren â€žArrayâ€œ [1]
vorstellen. Mithilfe der FieldTypes kÃ¶nnen wir die Funktionen des Boards
verwenden. ZunÃ¤chst stellt sich allerdings die Frage, wie wir Ã¼berhaupt
das Spielbrett bekommen kÃ¶nnen. Das Spielbrett bekommen wir durch den
GameState. Mit Hilfe der Methode <em>gameState.getBoard()</em>.</p>
<p>Unsere Eigene Position kÃ¶nnen wir mithilfe von <strong>currentPlayer</strong> oder
<strong>gameState</strong> herausfinden:</p>
<pre><code class="hljs language-scss"><span class="hljs-comment">// Es wird immer ein Integer zwischen 0 bis 64 zurÃ¼ckgegeben:</span>
currentPlayer<span class="hljs-selector-class">.getFieldIndex</span>();
<span class="hljs-comment">// dasselbe wie oben:</span>
gameState<span class="hljs-selector-class">.getCurrentPlayer</span>()<span class="hljs-selector-class">.getFieldIndex</span>();

if (currentPlayer.getFieldIndex() == gameState<span class="hljs-selector-class">.getCurrentPlayer</span>()<span class="hljs-selector-class">.getFieldIndex</span>()) {
  <span class="hljs-comment">//wird immer ausgefÃ¼hrt</span>
}
</code><button class="copy" aria-label="Copy Code"><svg xmlns="http://www.w3.org/2000/svg" stroke="currentColor" fill="currentColor" stroke-width="0" height="1em" width="1em" viewBox="0 0 24 24"><path d="M0 0h24v24H0z" fill="none"></path><path d="M16 1H4c-1.1 0-2 .9-2 2v14h2V3h12V1zm3 4H8c-1.1 0-2 .9-2 2v14c0 1.1.9 2 2 2h11c1.1 0 2-.9 2-2V7c0-1.1-.9-2-2-2zm0 16H8V7h11v14z"></path></svg></button></pre>
<h3><a class="heading" id="public-final-int-getnextfieldbytypefieldtype-typeint-pos" href="#public-final-int-getnextfieldbytypefieldtype-typeint-pos"><span>public final int getNextFieldByType(FieldType type,int pos)</span></a><button class="bookmark" title="Bookmark">ðŸ”–</button></h3>
<p>Dieser Funktion Ã¼bergeben wir eine Position und ein FieldType. Es gibt
die Position des nÃ¤chsten FieldType an, welches <strong>nach</strong> der angegeben
Position liegt. Hat das Feld mit der angegeben Position, den gleichen
FieldType, so wird dennoch die Position des nÃ¤chsten Felds angegeben
(siehe zweites Beispiel). Gibt es diesen FieldType nicht mehr wird -1
zurÃ¼ckgegeben.</p>
<pre><code class="hljs language-scss">gameState<span class="hljs-selector-class">.getBoard</span>()<span class="hljs-selector-class">.getNextFieldByType</span>(FieldType.GOAL,
                                        currentPlayer.getFieldIndex());
</code><button class="copy" aria-label="Copy Code"><svg xmlns="http://www.w3.org/2000/svg" stroke="currentColor" fill="currentColor" stroke-width="0" height="1em" width="1em" viewBox="0 0 24 24"><path d="M0 0h24v24H0z" fill="none"></path><path d="M16 1H4c-1.1 0-2 .9-2 2v14h2V3h12V1zm3 4H8c-1.1 0-2 .9-2 2v14c0 1.1.9 2 2 2h11c1.1 0 2-.9 2-2V7c0-1.1-.9-2-2-2zm0 16H8V7h11v14z"></path></svg></button></pre>
<p>Dies wÃ¼rde in einem normalen Spiel immer 64 zurÃ¼ckgeben, auÃŸer man
befindet sich auf dem Ziel. Im diesem Fall wÃ¤re das Ergebnis -1.</p>
<pre><code class="hljs language-ini">// Damit man nicht immer gameState.getBoard() schreiben muss:
Board <span class="hljs-attr">b</span> = gameState.getBoard()<span class="hljs-comment">;</span>
final int <span class="hljs-attr">index</span> = currentPlayer.getFieldIndex()<span class="hljs-comment">; // Index des Spielers</span>

if (<span class="hljs-attr">index</span> == b.getNextFieldByType(b.getTypeAt(index), index)) {
  System.out.println(&quot;Geht nicht&quot;)<span class="hljs-comment">;</span>
}
</code><button class="copy" aria-label="Copy Code"><svg xmlns="http://www.w3.org/2000/svg" stroke="currentColor" fill="currentColor" stroke-width="0" height="1em" width="1em" viewBox="0 0 24 24"><path d="M0 0h24v24H0z" fill="none"></path><path d="M16 1H4c-1.1 0-2 .9-2 2v14h2V3h12V1zm3 4H8c-1.1 0-2 .9-2 2v14c0 1.1.9 2 2 2h11c1.1 0 2-.9 2-2V7c0-1.1-.9-2-2-2zm0 16H8V7h11v14z"></path></svg></button></pre>
<p>Dies liegt daran, dass der verwendete Index nie der RÃ¼ckgabewert von
<strong>getNextFieldByType</strong> sein kann.</p>
<pre><code class="hljs language-ini">int <span class="hljs-attr">next_hedgehog</span> = b.getNextFieldByType(FieldType.HEDGEHOG,
                                         currentPlayer.getFieldIndex())<span class="hljs-comment">;</span>
int <span class="hljs-attr">next_next_hedgehog</span> = b.getNextFieldByType(FieldType.HEDGEHOG, next_hedgehog)<span class="hljs-comment">;</span>
</code><button class="copy" aria-label="Copy Code"><svg xmlns="http://www.w3.org/2000/svg" stroke="currentColor" fill="currentColor" stroke-width="0" height="1em" width="1em" viewBox="0 0 24 24"><path d="M0 0h24v24H0z" fill="none"></path><path d="M16 1H4c-1.1 0-2 .9-2 2v14h2V3h12V1zm3 4H8c-1.1 0-2 .9-2 2v14c0 1.1.9 2 2 2h11c1.1 0 2-.9 2-2V7c0-1.1-.9-2-2-2zm0 16H8V7h11v14z"></path></svg></button></pre>
<p>Dies wÃ¼rde die Postion des nÃ¤chste und vom Ã¼bernÃ¤chste Igelfeld
bestimmen. Achtung es wird hierbei nicht Ã¼berprÃ¼ft, ob es so ein Feld
Ã¼berhaupt gibt. Dies kann zu Fehlern fÃ¼hren. Steht man z.B auf dem
letzten Igelfeld, so hat <strong>next_next_hedgehog</strong> den Wert 11, anstelle
von -1 (Siehe Ãœbung 2).</p>
<h3><a class="heading" id="public-final-int-getpreviousfieldbytypefieldtype-typeint-pos" href="#public-final-int-getpreviousfieldbytypefieldtype-typeint-pos"><span>public final int getPreviousFieldByType(FieldType type,int pos)</span></a><button class="bookmark" title="Bookmark">ðŸ”–</button></h3>
<p>Analog zu getNextFieldByType. Allerdings bezieht sich die Funktion auf
das vorherige Feld mit dem entsprechenden FieldType.</p>
<h3><a class="heading" id="public-final-fieldtype-gettypeatint-pos" href="#public-final-fieldtype-gettypeatint-pos"><span>public final FieldType getTypeAt(int pos)</span></a><button class="bookmark" title="Bookmark">ðŸ”–</button></h3>
<p>Mit dieser Funktionen kann man den FieldType eines bestimmten Feldes
ermitteln.</p>
<pre><code class="hljs language-ini">FieldType <span class="hljs-attr">my_field</span> = gameState.getBoard().getTypeAt(currentPlayer.getFieldIndex())<span class="hljs-comment">;</span>
FieldType <span class="hljs-attr">field_42</span> = gameState.getBoard().getTypeAt(<span class="hljs-number">42</span>)<span class="hljs-comment">;</span>
</code><button class="copy" aria-label="Copy Code"><svg xmlns="http://www.w3.org/2000/svg" stroke="currentColor" fill="currentColor" stroke-width="0" height="1em" width="1em" viewBox="0 0 24 24"><path d="M0 0h24v24H0z" fill="none"></path><path d="M16 1H4c-1.1 0-2 .9-2 2v14h2V3h12V1zm3 4H8c-1.1 0-2 .9-2 2v14c0 1.1.9 2 2 2h11c1.1 0 2-.9 2-2V7c0-1.1-.9-2-2-2zm0 16H8V7h11v14z"></path></svg></button></pre>
<p>Speichert den aktuelle FieldType auf welchen man steht und den FieldType
des Feldes 42.</p>
<pre><code class="hljs language-less"><span class="hljs-selector-tag">if</span> (gameState.<span class="hljs-built_in">getBoard</span>().<span class="hljs-built_in">getTypeAt</span>(-<span class="hljs-number">1</span>) == FieldType.INVALID) {
  <span class="hljs-comment">// Wird immer ausgefÃ¼hrt, da es das Feld an der Position -1 nicht gibt</span>
}
</code><button class="copy" aria-label="Copy Code"><svg xmlns="http://www.w3.org/2000/svg" stroke="currentColor" fill="currentColor" stroke-width="0" height="1em" width="1em" viewBox="0 0 24 24"><path d="M0 0h24v24H0z" fill="none"></path><path d="M16 1H4c-1.1 0-2 .9-2 2v14h2V3h12V1zm3 4H8c-1.1 0-2 .9-2 2v14c0 1.1.9 2 2 2h11c1.1 0 2-.9 2-2V7c0-1.1-.9-2-2-2zm0 16H8V7h11v14z"></path></svg></button></pre>
<p>Dieses Beispiel zeigt auf, dass es durch getTypeAt nie zu einer
IndexOutOfBoundsException kommen kann. Es gibt nur Felder im Intervall
von 0 â€“ 64. Sollte man nach einem Feld auÃŸerhalb diese Intervalls
fragen, so wird immer INVALID zurÃ¼ckgegeben.</p>
<p>Die komplette API-Dokumentation ist in /doc/sc/plugin2018/Board.html zu
finden.</p>
<h2><a class="heading" id="aufgaben" href="#aufgaben"><span>Aufgaben</span></a><button class="bookmark" title="Bookmark">ðŸ”–</button></h2>
<ol>
<li>
<p>Gib die Entfernung des Gegners zum Startfeld aus. Verwende dabei
keine Variablen oder Literale. Die Ausnahme ist der RÃ¼ckgabewert.
Dieser darf eine Literale sein (z.B. return 127;). Tipp: Suche in
der API von GameState nach einer Funktion, welchen den anderen
Spieler zurÃ¼ckgibt oder lese das Dokument â€žHase_Igel_Playerâ€œ.</p>
</li>
<li>
<p>ErklÃ¤re warum <strong>next_next_hedgehog</strong> den Wert 11 hÃ¤tte, wenn wir
auf den letzten Igelfeld stehen wÃ¼rden.</p>
<pre><code class="hljs language-ini">int <span class="hljs-attr">next_hedgehog</span> = b.getNextFieldByType(FieldType.HEDGEHOG,
                                         currentPlayer.getFieldIndex())<span class="hljs-comment">;</span>
int <span class="hljs-attr">next_next_hedgehog</span> = b.getNextFieldByType(FieldType.HEDGEHOG, next_hedgehog)<span class="hljs-comment">;</span>
</code><button class="copy" aria-label="Copy Code"><svg xmlns="http://www.w3.org/2000/svg" stroke="currentColor" fill="currentColor" stroke-width="0" height="1em" width="1em" viewBox="0 0 24 24"><path d="M0 0h24v24H0z" fill="none"></path><path d="M16 1H4c-1.1 0-2 .9-2 2v14h2V3h12V1zm3 4H8c-1.1 0-2 .9-2 2v14c0 1.1.9 2 2 2h11c1.1 0 2-.9 2-2V7c0-1.1-.9-2-2-2zm0 16H8V7h11v14z"></path></svg></button></pre>
</li>
<li>
<p>Schreibe eine Funktion, welche das Ã¼bernÃ¤chste Igelfeld ausgibt.
Gibt es solch ein Feld nicht, so soll immer -1 zurÃ¼ckgegeben werden.</p>
</li>
</ol>
<h1><a class="heading" id="die-klasse-player" href="#die-klasse-player"><span>Die Klasse Player</span></a><button class="bookmark" title="Bookmark">ðŸ”–</button></h1>
<p>Die Klasse Player reprÃ¤sentiert einen Spieler. Der eigene Spieler kann
in der RandomLogic durch die Variable <strong>currentPlayer</strong> oder mithilfe
der GameState Funktion <em>getCurrentPlayer()</em> abgefragt werden. Der
gegnerische Spieler kann ebenfalls mithilfe einer Methode von GameState
bestimmt werden (<em>gameState.getOtherPlayer()</em>).</p>
<p>Die Klasse Player besitzt viele Funktionen, welche einen Informationen
Ã¼ber den Spieler geben:</p>
<p>Die VollstÃ¤ndige API ist in /doc/sc/plugin2018/Player.html zu finden.</p>
<p>Die Meisten dieser Funktionen sind selbsterklÃ¤rend. Dennoch sind hier
einige Beispiele angegeben:</p>
<pre><code class="hljs language-csharp">System.<span class="hljs-keyword">out</span>.print(<span class="hljs-string">&quot;Du hast noch folgende Karten: &quot;</span>);
<span class="hljs-keyword">for</span> (CardType c : currentPlayer.getCards()) {
    System.<span class="hljs-keyword">out</span>.print(c + <span class="hljs-string">&quot; &quot;</span>);
}
System.<span class="hljs-keyword">out</span>.println();
</code><button class="copy" aria-label="Copy Code"><svg xmlns="http://www.w3.org/2000/svg" stroke="currentColor" fill="currentColor" stroke-width="0" height="1em" width="1em" viewBox="0 0 24 24"><path d="M0 0h24v24H0z" fill="none"></path><path d="M16 1H4c-1.1 0-2 .9-2 2v14h2V3h12V1zm3 4H8c-1.1 0-2 .9-2 2v14c0 1.1.9 2 2 2h11c1.1 0 2-.9 2-2V7c0-1.1-.9-2-2-2zm0 16H8V7h11v14z"></path></svg></button></pre>
<p>Dies wÃ¼rde alle Karten ausgeben, welche man noch hat.</p>
<pre><code class="hljs language-less"><span class="hljs-selector-tag">if</span> (currentPlayer.<span class="hljs-built_in">inGoal</span>() &amp;&amp; !currentPlayer.<span class="hljs-built_in">getCards</span>().<span class="hljs-built_in">isEmpty</span>()) {
    <span class="hljs-selector-tag">System</span><span class="hljs-selector-class">.out</span><span class="hljs-selector-class">.println</span>(<span class="hljs-string">&quot;Was fuer eine Verschwendung.&quot;</span>);
}
</code><button class="copy" aria-label="Copy Code"><svg xmlns="http://www.w3.org/2000/svg" stroke="currentColor" fill="currentColor" stroke-width="0" height="1em" width="1em" viewBox="0 0 24 24"><path d="M0 0h24v24H0z" fill="none"></path><path d="M16 1H4c-1.1 0-2 .9-2 2v14h2V3h12V1zm3 4H8c-1.1 0-2 .9-2 2v14c0 1.1.9 2 2 2h11c1.1 0 2-.9 2-2V7c0-1.1-.9-2-2-2zm0 16H8V7h11v14z"></path></svg></button></pre>
<p>Die If-Bedingung wÃ¼rde dann ausgefÃ¼hrt werden, wenn man im Ziel ist,
allerdings noch Karten hat.</p>
<p>Eine weitere wichtige Funktion ist <em>getFieldIndex</em>. Diese Funktion wird
hÃ¤ufig im Dokument â€žHase_Igel_Spielbrettâ€œ verwendet.</p>
<p>Neben diesen Funktionen existieren noch einige â€žSetterâ€œ. Diese sind
allerdings hauptsÃ¤chlich fÃ¼r den Server notwendig und haben einen
geringen praktischen Nutzten fÃ¼r uns.</p>
<h2><a class="heading" id="aufgabe" href="#aufgabe"><span>Aufgabe</span></a><button class="bookmark" title="Bookmark">ðŸ”–</button></h2>
<p>Schreibe eine If-Bedingung, welche abfragt, ob beide Spieler auf dem
selben Feld sind. Da dies nur mÃ¶glich ist, wenn man auf dem Start-
Zielfeld ist, soll zunÃ¤chst abgefragt werden, ob der aktuelle Spieler
auf dem Start- Zielfeld ist. Tipp: Es gibt die Funktion getTypeAt der
Klasse Board. Weiter Informationen sind im Dokument
â€žHase_Igel_Spielbrettâ€œ zu finden.</p>
<h1><a class="heading" id="gamerulelogic-hilfreiche-hilfsfunktionen" href="#gamerulelogic-hilfreiche-hilfsfunktionen"><span>GameRuleLogic: Hilfreiche Hilfsfunktionen</span></a><button class="bookmark" title="Bookmark">ðŸ”–</button></h1>
<p>Die Klasse GameRuleLogic hat viele Hilfsfunktionen, mit welchen man die
Regeln des Spieles Ã¼berprÃ¼fen kann. Hierbei sind alle Funktionen static.
D.h., dass man sie ohne eine Instanz aufrufen kann.</p>
<p>*Diese Funktionen werden im Kapitel â€žErweiterte Beispieleâ€œ besprochen.</p>
<p>Die komplette API-Dokumentation ist in
doc/sc/plugin2018/util/GameRuleLogic.html zu finden.</p>
<h2><a class="heading" id="simulation-des-gegners" href="#simulation-des-gegners"><span>Simulation des Gegners</span></a><button class="bookmark" title="Bookmark">ðŸ”–</button></h2>
<p>NatÃ¼rlich kann man alle diese Funktionen auch auf den Gegenspieler
anwenden. DafÃ¼r mÃ¼ssen wir allerdings eine Kopie des GameState
erstellen:</p>
<pre><code class="hljs language-scss">try {
  GameState otherGame = gameState<span class="hljs-selector-class">.clone</span>(); <span class="hljs-comment">// Deep-Copy</span>
  <span class="hljs-comment">// Rundenanzahl hochsetzten fÃ¼r switch Befehl:</span>
  otherGame<span class="hljs-selector-class">.setTurn</span>(gameState.getTurn()+<span class="hljs-number">1</span>);
  <span class="hljs-comment">// Tausche currentPlayer (hÃ¤ngt von der Rundenanzahl ab):</span>
  otherGame<span class="hljs-selector-class">.switchCurrentPlayer</span>();
  <span class="hljs-comment">// Gib Informationen Ã¼ber den Gegner aus:</span>
  System<span class="hljs-selector-class">.out</span><span class="hljs-selector-class">.println</span>(&quot;CurrentPlayer von otherGame:&quot; + otherGame.getCurrentPlayer());
} catch (CloneNotSupportedException e1) { <span class="hljs-comment">// Fehlerbehandlung</span>
  e1<span class="hljs-selector-class">.printStackTrace</span>();
}
</code><button class="copy" aria-label="Copy Code"><svg xmlns="http://www.w3.org/2000/svg" stroke="currentColor" fill="currentColor" stroke-width="0" height="1em" width="1em" viewBox="0 0 24 24"><path d="M0 0h24v24H0z" fill="none"></path><path d="M16 1H4c-1.1 0-2 .9-2 2v14h2V3h12V1zm3 4H8c-1.1 0-2 .9-2 2v14c0 1.1.9 2 2 2h11c1.1 0 2-.9 2-2V7c0-1.1-.9-2-2-2zm0 16H8V7h11v14z"></path></svg></button></pre>
<p>Alle Funktionen von GameRuleLogic kÃ¶nnen wir nun, mithilfe der Variable
otherGame, auf den Gegner anwenden.</p>
<h2><a class="heading" id="einfhrende-beispiele" href="#einfhrende-beispiele"><span>EinfÃ¼hrende Beispiele</span></a><button class="bookmark" title="Bookmark">ðŸ”–</button></h2>
<p>Die meisten Funktionen dieser Klasse sind selbsterklÃ¤rend. Dennoch
werden einige der hÃ¤ufig verwendeten Funktionen mit kleinen Beispielen
vorgestellt.</p>
<pre><code class="hljs language-less"><span class="hljs-selector-tag">if</span> (GameRuleLogic.<span class="hljs-built_in">isValidToEat</span>(gameState) != GameRuleLogic.<span class="hljs-built_in">mustEatSalad</span>(gameState)) {
  <span class="hljs-selector-tag">System</span><span class="hljs-selector-class">.out</span><span class="hljs-selector-class">.println</span>(<span class="hljs-string">&quot;UnmÃ¶glich&quot;</span>);
}
</code><button class="copy" aria-label="Copy Code"><svg xmlns="http://www.w3.org/2000/svg" stroke="currentColor" fill="currentColor" stroke-width="0" height="1em" width="1em" viewBox="0 0 24 24"><path d="M0 0h24v24H0z" fill="none"></path><path d="M16 1H4c-1.1 0-2 .9-2 2v14h2V3h12V1zm3 4H8c-1.1 0-2 .9-2 2v14c0 1.1.9 2 2 2h11c1.1 0 2-.9 2-2V7c0-1.1-.9-2-2-2zm0 16H8V7h11v14z"></path></svg></button></pre>
<p>Nach den Regeln muss man immer ein Salat essen, wenn man im vorherigen
Zug ein Salatfeld betreten hat. AuÃŸerdem ist dies die einzige
MÃ¶glichkeit die Aktion EatSalad auszufÃ¼hren (nicht mit dem Spielen der
EAT_SALAD Karte verwechseln).</p>
<p>Dadurch wird auch die UnerfÃ¼llbarkeit des folgenden Ausdrucks
impliziert:</p>
<pre><code class="hljs language-less"><span class="hljs-selector-tag">if</span> (GameRuleLogic.<span class="hljs-built_in">isValidToEat</span>(gameState) &amp;&amp;
    (GameRuleLogic.<span class="hljs-built_in">isValidToFallBack</span>(gameState) || GameRuleLogic.<span class="hljs-built_in">canMove</span>(gameState))) {
  <span class="hljs-selector-tag">System</span><span class="hljs-selector-class">.out</span><span class="hljs-selector-class">.println</span>(<span class="hljs-string">&quot;UnmÃ¶glich&quot;</span>);
}
</code><button class="copy" aria-label="Copy Code"><svg xmlns="http://www.w3.org/2000/svg" stroke="currentColor" fill="currentColor" stroke-width="0" height="1em" width="1em" viewBox="0 0 24 24"><path d="M0 0h24v24H0z" fill="none"></path><path d="M16 1H4c-1.1 0-2 .9-2 2v14h2V3h12V1zm3 4H8c-1.1 0-2 .9-2 2v14c0 1.1.9 2 2 2h11c1.1 0 2-.9 2-2V7c0-1.1-.9-2-2-2zm0 16H8V7h11v14z"></path></svg></button></pre>
<p>Eine weiter hilfreiche Funktion ist <em>isValidToAdvance</em>. Mit dieser
Funktion wird Ã¼berprÃ¼ft, ob ein VorwÃ¤rtszug mit der Ã¼bergeben Distanz
Ã¼berhaupt mÃ¶glich ist:</p>
<pre><code class="hljs language-csharp"><span class="hljs-comment">// berechne die maximale Entfernung, welche man laufen darf</span>
<span class="hljs-built_in">int</span> max_move = GameRuleLogic.calculateMoveableFields(currentPlayer.getCarrots());

<span class="hljs-keyword">if</span> (GameRuleLogic.isValidToAdvance(gameState, max_move +<span class="hljs-number">1</span>)) {
  System.<span class="hljs-keyword">out</span>.println(<span class="hljs-string">&quot;UnmÃ¶glich&quot;</span>);
}
</code><button class="copy" aria-label="Copy Code"><svg xmlns="http://www.w3.org/2000/svg" stroke="currentColor" fill="currentColor" stroke-width="0" height="1em" width="1em" viewBox="0 0 24 24"><path d="M0 0h24v24H0z" fill="none"></path><path d="M16 1H4c-1.1 0-2 .9-2 2v14h2V3h12V1zm3 4H8c-1.1 0-2 .9-2 2v14c0 1.1.9 2 2 2h11c1.1 0 2-.9 2-2V7c0-1.1-.9-2-2-2zm0 16H8V7h11v14z"></path></svg></button></pre>
<p>Die Funktion <em>calculateMoveableFields</em> gibt hierbei die maximale
Entfernung zurÃ¼ck, welche man mit den Ã¼bergebenen Karotten laufen darf.
Diese maximale Entfernung wird immer um 1 erhÃ¶ht, was dazu fÃ¼hrt, dass
der Zug immer unmÃ¶glich ist.</p>
<h2><a class="heading" id="erweitertes-beispiel" href="#erweitertes-beispiel"><span>Erweitertes Beispiel</span></a><button class="bookmark" title="Bookmark">ðŸ”–</button></h2>
<p>Alle Funktionen die mit einem * markiert wurden (s.o) haben eine
Gemeinsamkeit. Sie beziehen sich auf das Spielen von Karten. Das Spielen
von Karten ist allerdings nur erlaubt, wenn man das entsprechende
Hasenfeld in der selben Zug betreten hat. Deshalb mÃ¼ssen wir GameState
bearbeiten, damit diese Funktionen Ã¼berhaupt Sinn haben. Das folgende
Beispiel gibt eine MÃ¶glichkeit an, wie man diese Funktionen einsetzten
kann:</p>
<pre><code class="hljs language-scss">int nextHareFieldIndex = gameState<span class="hljs-selector-class">.getNextFieldByType</span>(FieldType.HARE,
                                                      currentPlayer.getFieldIndex())
<span class="hljs-comment">// wenn es ein nÃ¤chstes Hasenfeld gibt</span>
if (nextHareFieldIndex &gt; <span class="hljs-number">0</span>) {
  try {

    GameState gameHare = gameState<span class="hljs-selector-class">.clone</span>(); <span class="hljs-comment">// erstelle Deep-Copy</span>
    Player harePlayer = gameHare<span class="hljs-selector-class">.getCurrentPlayer</span>(); <span class="hljs-comment">// erstelle Shallow-Copy</span>

    <span class="hljs-comment">//setzte den aktuellen Spieler auf ein Hasenfeld</span>
    harePlayer<span class="hljs-selector-class">.setFieldIndex</span>(nextHareFieldIndex);
    System<span class="hljs-selector-class">.out</span><span class="hljs-selector-class">.println</span>(gameHare.getCurrentPlayer()<span class="hljs-selector-class">.getCards</span>()); <span class="hljs-comment">// gib alle Karten aus</span>

    <span class="hljs-comment">// Welche Karten kann man spielen?</span>
    System<span class="hljs-selector-class">.out</span><span class="hljs-selector-class">.println</span>(&quot;Play EatSalad: &quot; +
                       GameRuleLogic.isValidToPlayEatSalad(gameHare));
    System<span class="hljs-selector-class">.out</span><span class="hljs-selector-class">.println</span>(&quot;Play TakeOrDropCarrots: &quot; +
                       GameRuleLogic.isValidToPlayTakeOrDropCarrots(gameHare,<span class="hljs-number">20</span>));
    System<span class="hljs-selector-class">.out</span><span class="hljs-selector-class">.println</span>(&quot;Play HurryAhead: &quot; +
                       GameRuleLogic.isValidToPlayHurryAhead(gameHare));
    System<span class="hljs-selector-class">.out</span><span class="hljs-selector-class">.println</span>(&quot;Play FallBack: &quot; +
                       GameRuleLogic.isValidToPlayFallBack(gameHare));

  } catch (CloneNotSupportedException e1) {
    e1<span class="hljs-selector-class">.printStackTrace</span>();
  }
}
</code><button class="copy" aria-label="Copy Code"><svg xmlns="http://www.w3.org/2000/svg" stroke="currentColor" fill="currentColor" stroke-width="0" height="1em" width="1em" viewBox="0 0 24 24"><path d="M0 0h24v24H0z" fill="none"></path><path d="M16 1H4c-1.1 0-2 .9-2 2v14h2V3h12V1zm3 4H8c-1.1 0-2 .9-2 2v14c0 1.1.9 2 2 2h11c1.1 0 2-.9 2-2V7c0-1.1-.9-2-2-2zm0 16H8V7h11v14z"></path></svg></button></pre>
<p>HierfÃ¼r mÃ¼ssen wir den Spieler einfach nur auf das Hasenfeld setzten.
Allerdings wird nicht Ã¼berprÃ¼ft, ob der Spieler Ã¼berhaupt bis zum
nÃ¤chsten Hasenfeld laufen kann.</p>
<h2><a class="heading" id="aufgaben" href="#aufgaben"><span>Aufgaben</span></a><button class="bookmark" title="Bookmark">ðŸ”–</button></h2>
<ol>
<li>Ist das AusfÃ¼hren der inneren If-Bedingung wirklich unmÃ¶glich.
ErklÃ¤re warum oder gib ein Gegenbeispiel an:</li>
</ol>
<pre><code class="hljs language-scss">int dif = gameState<span class="hljs-selector-class">.getOtherPlayer</span>()<span class="hljs-selector-class">.getFieldIndex</span>() - currentPlayer<span class="hljs-selector-class">.getFieldIndex</span>();

if (dif &gt;= <span class="hljs-number">0</span> &amp;&amp;
    dif &lt;= GameRuleLogic.calculateMoveableFields(currentPlayer.getCarrots())) {
  if (GameRuleLogic.isValidToAdvance(gameState, dif)) {
    System<span class="hljs-selector-class">.out</span><span class="hljs-selector-class">.println</span>(&quot;UnmÃ¶glich&quot;);
  }
}
</code><button class="copy" aria-label="Copy Code"><svg xmlns="http://www.w3.org/2000/svg" stroke="currentColor" fill="currentColor" stroke-width="0" height="1em" width="1em" viewBox="0 0 24 24"><path d="M0 0h24v24H0z" fill="none"></path><path d="M16 1H4c-1.1 0-2 .9-2 2v14h2V3h12V1zm3 4H8c-1.1 0-2 .9-2 2v14c0 1.1.9 2 2 2h11c1.1 0 2-.9 2-2V7c0-1.1-.9-2-2-2zm0 16H8V7h11v14z"></path></svg></button></pre>
<ol>
<li>Erweiterte das Beispiel aus dem Kapitel â€žErweitertes Beispielâ€œ so,
dass sicher gestellt wird, dass der aktuelle Spieler auf ein
Hasenfeld gesetzt wird, welches er wirklich erreichen kann.</li>
</ol>
<p>[1] Technisch gesehen hat die Klasse eine private Liste von Feldern.
Allerdings Ã¤hnelt ein Aufruf der Funktion getTypeAt sehr den Aufruf
eines Arrays. Auch wenn der RÃ¼ckgabewert kein Feld sonder ein FieldType
ist.</p></div></article><div class="jump-container"><a class="jump previous" href="/spiele/hase-und-igel/tutorial/start">start</a><a class="jump next" href="/spiele/hase-und-igel/xml-dokumentation/einleitung-xml">einleitung-xml</a></div><div class="meta"><a class="edit-github" href="https://github.com/software-challenge/docs/tree/main/hyperbook/book/spiele/hase-und-igel/tutorial/tutorial.md">âœŽ GitHub</a><span class="copyright"><a rel="license" href="https://creativecommons.org/licenses/by-nc-sa/4.0">Licensed under <!-- -->CC BY-NC-SA</a> by <a href="https://software-challenge.de">Software-Challenge Germany</a>.</span></div></main></div></div><script id="__NEXT_DATA__" type="application/json">{"props":{"pageProps":{"locale":"de","markdown":"[PDF-Version dieses Dokumentes](tutorial.pdf)\n\n# Start zum Schreiben einer KI\n\nAm einfachsten ist es die KI auf Grundlage des Zufallsspielers zu\nschreiben:\n\n-   Als erstes muss der Zufallsspieler heruntergeladen werden\n    (\u003chttp://www.software-challenge.de/downloads/\u003e bitte den\n    Zufallsspieler als â€žQuellcodeâ€œ downloaden)\n\n-   Dieser muss nun in Eclips eingebunden werden:\n    \u003chttps://docs.software-challenge.de/#einrichtung-von-eclipse\u003e\n\n## Wo schreibe ich die KI?\n\nIst dies getan befindet sich im entsprechenden Projekt das Package\nâ€žsc.player2018.logicâ€œ mit einer Datei namens **â€žRandomLogic.javaâ€œ**.\nDiese Datei mÃ¼ssen wir nun editieren.\n\nIn der Datei gibt es eine Funktion mit der Bezeichnung *public void\nonRequestAction()*. Diese ist wie Folgt aufgebaut:\n\n    public void onRequestAction(){\n      // optional: Laufzeitmessung\n      long startTime = System.nanoTime();\n\n\n      // Quellcode der KI, welche eine Zug (move) erstellt\n\n\n      long nowTime = System.nanoTime();\n\n      // sende Move. Danach gibt es kein zurÃ¼ck mehr:\n      sendAction(move);\n\n      // optional: LOG-Eintrag mit Zeit:\n      log.warn(\"Time needed for turn: {}\", (nowTime - startTime) / 1000000);\n    }\n\nEs ist sehr wichtig, dass alle Funktionen, welche die KI verwendet,\nihren ursprÃ¼nglichen Aufruf in der Funktion onRequestAction haben.\nDadurch wird sichergestellt, dass alle Membervariablen aktuell sind.\n\n## Wichtige Membervariablen\n\nIn der Klasse befinden sich auch drei sehr wichtige Membervariablen:\n\n    private Starter client; // Intern fÃ¼r den Server wichtig. Bitte nicht modifizieren\n\n    private GameState gameState; // Gibt u.a Infos Ã¼ber mÃ¶gliche ZÃ¼ge und das Spielbrett\n\n    private Player currentPlayer; // Infos Ã¼ber den aktuellen Spieler, welchen man steuert\n\nIn den Folgenden Dokumenten werden Grundlagen zum erstellen einer KI\ngezeigt. Hierbei werden wir oft die Variablen **gameState** und\n**currentPlayer** verwenden.\n\nDie **API-Dokumentation** befindet sich im Ordner â€ždocâ€œ im Verzeichnis\ndes Zufallsspielers.\n\n## Aufgaben\n\n1.  Arbeite alle anderen Dokumente durch.\n\n2.  Analysiere die Herangehensweise der Zufallsspieler-KI.\n\n3.  Schreibe eine KI.\n\n# Spielbrett Informationen\n\n## Die Klasse â€žFieldTypeâ€œ\n\nBevor wir mit der Klasse Board also dem Spielbrett arbeiten kÃ¶nnen,\nmÃ¼ssen wir das Enum â€žFieldTypeâ€œ kennenlernen. Dieses Enum definiert die\neinzelnen Felder des Bretts. Es gibt:\n\n\u003ctable\u003e\n\u003ccolgroup\u003e\n\u003ccol style=\"width: 50%\" /\u003e\n\u003ccol style=\"width: 50%\" /\u003e\n\u003c/colgroup\u003e\n\u003ctbody\u003e\n\u003ctr class=\"odd\"\u003e\n\u003ctd style=\"text-align: left;\"\u003e\u003cp\u003eCARROT\u003c/p\u003e\u003c/td\u003e\n\u003ctd style=\"text-align: left;\"\u003e\u003cp\u003eKarottenfeld\u003c/p\u003e\u003c/td\u003e\n\u003c/tr\u003e\n\u003ctr class=\"even\"\u003e\n\u003ctd style=\"text-align: left;\"\u003e\u003cp\u003eGOAL\u003c/p\u003e\u003c/td\u003e\n\u003ctd style=\"text-align: left;\"\u003e\u003cp\u003eZielfeld\u003c/p\u003e\u003c/td\u003e\n\u003c/tr\u003e\n\u003ctr class=\"odd\"\u003e\n\u003ctd style=\"text-align: left;\"\u003e\u003cp\u003eHARE\u003c/p\u003e\u003c/td\u003e\n\u003ctd style=\"text-align: left;\"\u003e\u003cp\u003eHasenfeld\u003c/p\u003e\u003c/td\u003e\n\u003c/tr\u003e\n\u003ctr class=\"even\"\u003e\n\u003ctd style=\"text-align: left;\"\u003e\u003cp\u003eHEDGEHOG\u003c/p\u003e\u003c/td\u003e\n\u003ctd style=\"text-align: left;\"\u003e\u003cp\u003eIgelfeld\u003c/p\u003e\u003c/td\u003e\n\u003c/tr\u003e\n\u003ctr class=\"odd\"\u003e\n\u003ctd style=\"text-align: left;\"\u003e\u003cp\u003eSALAD\u003c/p\u003e\u003c/td\u003e\n\u003ctd style=\"text-align: left;\"\u003e\u003cp\u003eSalatfeld\u003c/p\u003e\u003c/td\u003e\n\u003c/tr\u003e\n\u003ctr class=\"even\"\u003e\n\u003ctd style=\"text-align: left;\"\u003e\u003cp\u003eSTART\u003c/p\u003e\u003c/td\u003e\n\u003ctd style=\"text-align: left;\"\u003e\u003cp\u003eStart\u003c/p\u003e\u003c/td\u003e\n\u003c/tr\u003e\n\u003ctr class=\"odd\"\u003e\n\u003ctd style=\"text-align: left;\"\u003e\u003cp\u003ePOSITION_1\u003c/p\u003e\u003c/td\u003e\n\u003ctd style=\"text-align: left;\"\u003e\u003cp\u003ePositionsfelder\u003c/p\u003e\u003c/td\u003e\n\u003c/tr\u003e\n\u003ctr class=\"even\"\u003e\n\u003ctd style=\"text-align: left;\"\u003e\u003cp\u003ePOSITION_2\u003c/p\u003e\u003c/td\u003e\n\u003ctd style=\"text-align: left;\"\u003e\u003c/td\u003e\n\u003c/tr\u003e\n\u003ctr class=\"odd\"\u003e\n\u003ctd style=\"text-align: left;\"\u003e\u003cp\u003eINVALID\u003c/p\u003e\u003c/td\u003e\n\u003ctd style=\"text-align: left;\"\u003e\u003cp\u003eUngÃ¼ltig\u003c/p\u003e\u003c/td\u003e\n\u003c/tr\u003e\n\u003c/tbody\u003e\n\u003c/table\u003e\n\nDie Dokumentation fÃ¼r FieldType ist in /doc/sc/plugin2018/FieldType.html\nzu finden.\n\n## Funktionen der Klasse â€žBoardâ€œ\n\nDas Spielbrett kann man sich wie einer Art modifizieren â€žArrayâ€œ [1]\nvorstellen. Mithilfe der FieldTypes kÃ¶nnen wir die Funktionen des Boards\nverwenden. ZunÃ¤chst stellt sich allerdings die Frage, wie wir Ã¼berhaupt\ndas Spielbrett bekommen kÃ¶nnen. Das Spielbrett bekommen wir durch den\nGameState. Mit Hilfe der Methode *gameState.getBoard()*.\n\nUnsere Eigene Position kÃ¶nnen wir mithilfe von **currentPlayer** oder\n**gameState** herausfinden:\n\n    // Es wird immer ein Integer zwischen 0 bis 64 zurÃ¼ckgegeben:\n    currentPlayer.getFieldIndex();\n    // dasselbe wie oben:\n    gameState.getCurrentPlayer().getFieldIndex();\n\n    if (currentPlayer.getFieldIndex() == gameState.getCurrentPlayer().getFieldIndex()) {\n      //wird immer ausgefÃ¼hrt\n    }\n\n### public final int getNextFieldByType(FieldType type,int pos)\n\nDieser Funktion Ã¼bergeben wir eine Position und ein FieldType. Es gibt\ndie Position des nÃ¤chsten FieldType an, welches **nach** der angegeben\nPosition liegt. Hat das Feld mit der angegeben Position, den gleichen\nFieldType, so wird dennoch die Position des nÃ¤chsten Felds angegeben\n(siehe zweites Beispiel). Gibt es diesen FieldType nicht mehr wird -1\nzurÃ¼ckgegeben.\n\n    gameState.getBoard().getNextFieldByType(FieldType.GOAL,\n                                            currentPlayer.getFieldIndex());\n\nDies wÃ¼rde in einem normalen Spiel immer 64 zurÃ¼ckgeben, auÃŸer man\nbefindet sich auf dem Ziel. Im diesem Fall wÃ¤re das Ergebnis -1.\n\n    // Damit man nicht immer gameState.getBoard() schreiben muss:\n    Board b = gameState.getBoard();\n    final int index = currentPlayer.getFieldIndex(); // Index des Spielers\n\n    if (index == b.getNextFieldByType(b.getTypeAt(index), index)) {\n      System.out.println(\"Geht nicht\");\n    }\n\nDies liegt daran, dass der verwendete Index nie der RÃ¼ckgabewert von\n**getNextFieldByType** sein kann.\n\n    int next_hedgehog = b.getNextFieldByType(FieldType.HEDGEHOG,\n                                             currentPlayer.getFieldIndex());\n    int next_next_hedgehog = b.getNextFieldByType(FieldType.HEDGEHOG, next_hedgehog);\n\nDies wÃ¼rde die Postion des nÃ¤chste und vom Ã¼bernÃ¤chste Igelfeld\nbestimmen. Achtung es wird hierbei nicht Ã¼berprÃ¼ft, ob es so ein Feld\nÃ¼berhaupt gibt. Dies kann zu Fehlern fÃ¼hren. Steht man z.B auf dem\nletzten Igelfeld, so hat **next\\_next\\_hedgehog** den Wert 11, anstelle\nvon -1 (Siehe Ãœbung 2).\n\n### public final int getPreviousFieldByType(FieldType type,int pos)\n\nAnalog zu getNextFieldByType. Allerdings bezieht sich die Funktion auf\ndas vorherige Feld mit dem entsprechenden FieldType.\n\n### public final FieldType getTypeAt(int pos)\n\nMit dieser Funktionen kann man den FieldType eines bestimmten Feldes\nermitteln.\n\n    FieldType my_field = gameState.getBoard().getTypeAt(currentPlayer.getFieldIndex());\n    FieldType field_42 = gameState.getBoard().getTypeAt(42);\n\nSpeichert den aktuelle FieldType auf welchen man steht und den FieldType\ndes Feldes 42.\n\n    if (gameState.getBoard().getTypeAt(-1) == FieldType.INVALID) {\n      // Wird immer ausgefÃ¼hrt, da es das Feld an der Position -1 nicht gibt\n    }\n\nDieses Beispiel zeigt auf, dass es durch getTypeAt nie zu einer\nIndexOutOfBoundsException kommen kann. Es gibt nur Felder im Intervall\nvon 0 â€“ 64. Sollte man nach einem Feld auÃŸerhalb diese Intervalls\nfragen, so wird immer INVALID zurÃ¼ckgegeben.\n\nDie komplette API-Dokumentation ist in /doc/sc/plugin2018/Board.html zu\nfinden.\n\n## Aufgaben\n\n1.  Gib die Entfernung des Gegners zum Startfeld aus. Verwende dabei\n    keine Variablen oder Literale. Die Ausnahme ist der RÃ¼ckgabewert.\n    Dieser darf eine Literale sein (z.B. return 127;). Tipp: Suche in\n    der API von GameState nach einer Funktion, welchen den anderen\n    Spieler zurÃ¼ckgibt oder lese das Dokument â€žHase\\_Igel\\_Playerâ€œ.\n\n2.  ErklÃ¤re warum **next\\_next\\_hedgehog** den Wert 11 hÃ¤tte, wenn wir\n    auf den letzten Igelfeld stehen wÃ¼rden.\n\n        int next_hedgehog = b.getNextFieldByType(FieldType.HEDGEHOG,\n                                                 currentPlayer.getFieldIndex());\n        int next_next_hedgehog = b.getNextFieldByType(FieldType.HEDGEHOG, next_hedgehog);\n\n3.  Schreibe eine Funktion, welche das Ã¼bernÃ¤chste Igelfeld ausgibt.\n    Gibt es solch ein Feld nicht, so soll immer -1 zurÃ¼ckgegeben werden.\n\n# Die Klasse Player\n\nDie Klasse Player reprÃ¤sentiert einen Spieler. Der eigene Spieler kann\nin der RandomLogic durch die Variable **currentPlayer** oder mithilfe\nder GameState Funktion *getCurrentPlayer()* abgefragt werden. Der\ngegnerische Spieler kann ebenfalls mithilfe einer Methode von GameState\nbestimmt werden (*gameState.getOtherPlayer()*).\n\nDie Klasse Player besitzt viele Funktionen, welche einen Informationen\nÃ¼ber den Spieler geben:\n\n\u003ctable\u003e\n\u003ccolgroup\u003e\n\u003ccol style=\"width: 50%\" /\u003e\n\u003ccol style=\"width: 50%\" /\u003e\n\u003c/colgroup\u003e\n\u003ctbody\u003e\n\u003ctr class=\"odd\"\u003e\n\u003ctd style=\"text-align: left;\"\u003e\u003cp\u003ejava.util.List\u0026lt;CardType\u0026gt;\u003c/p\u003e\u003c/td\u003e\n\u003ctd style=\"text-align: left;\"\u003e\u003cp\u003e\u003cem\u003egetCards()\u003c/em\u003e\u003cbr /\u003e\nGibt die fÃ¼r diesen Spieler verfÃ¼gbaren Hasenkarten zurÃ¼ck.\u003c/p\u003e\u003c/td\u003e\n\u003c/tr\u003e\n\u003ctr class=\"even\"\u003e\n\u003ctd style=\"text-align: left;\"\u003e\u003cp\u003ejava.util.List\u0026lt;CardType\u0026gt;\u003c/p\u003e\u003c/td\u003e\n\u003ctd style=\"text-align: left;\"\u003e\u003cp\u003e\u003cem\u003egetCardsWithout(CardType\ntype)\u003c/em\u003e\u003cbr /\u003e\nGibt Karten ohne bestimmten Typ zurÃ¼ck.\u003c/p\u003e\u003c/td\u003e\n\u003c/tr\u003e\n\u003ctr class=\"odd\"\u003e\n\u003ctd style=\"text-align: left;\"\u003e\u003cp\u003eint\u003c/p\u003e\u003c/td\u003e\n\u003ctd style=\"text-align: left;\"\u003e\u003cp\u003e\u003cem\u003egetCarrots()\u003c/em\u003e\u003cbr /\u003e\nDie Anzahl an Karotten die der Spieler zur Zeit auf der Hand\nhat.\u003c/p\u003e\u003c/td\u003e\n\u003c/tr\u003e\n\u003ctr class=\"even\"\u003e\n\u003ctd style=\"text-align: left;\"\u003e\u003cp\u003eint\u003c/p\u003e\u003c/td\u003e\n\u003ctd style=\"text-align: left;\"\u003e\u003cp\u003e\u003cem\u003egetFieldIndex()\u003c/em\u003e\u003cbr /\u003e\nDie aktuelle Position der Figur auf dem Spielfeld.\u003c/p\u003e\u003c/td\u003e\n\u003c/tr\u003e\n\u003ctr class=\"odd\"\u003e\n\u003ctd style=\"text-align: left;\"\u003e\u003cp\u003eAction\u003c/p\u003e\u003c/td\u003e\n\u003ctd style=\"text-align: left;\"\u003e\u003cp\u003e\u003cem\u003egetLastNonSkipAction\u003c/em\u003e\u003cbr /\u003e\nGibt letzte Aktion des Spielers zurÃ¼ck.\u003c/p\u003e\u003c/td\u003e\n\u003c/tr\u003e\n\u003ctr class=\"even\"\u003e\n\u003ctd style=\"text-align: left;\"\u003e\u003cp\u003esc.shared.PlayerColor\u003c/p\u003e\u003c/td\u003e\n\u003ctd style=\"text-align: left;\"\u003e\u003cp\u003e\u003cem\u003egetPlayerColor()\u003c/em\u003e\u003cbr /\u003e\nDie Farbe dieses Spielers auf dem Spielbrett\u003c/p\u003e\u003c/td\u003e\n\u003c/tr\u003e\n\u003ctr class=\"odd\"\u003e\n\u003ctd style=\"text-align: left;\"\u003e\u003cp\u003eint\u003c/p\u003e\u003c/td\u003e\n\u003ctd style=\"text-align: left;\"\u003e\u003cp\u003e\u003cem\u003egetSalads()\u003c/em\u003e\u003cbr /\u003e\nDie Anzahl der Salate, die dieser Spieler noch verspeisen muss.\u003c/p\u003e\u003c/td\u003e\n\u003c/tr\u003e\n\u003ctr class=\"even\"\u003e\n\u003ctd style=\"text-align: left;\"\u003e\u003cp\u003eboolean\u003c/p\u003e\u003c/td\u003e\n\u003ctd style=\"text-align: left;\"\u003e\u003cp\u003e\u003cem\u003einGoal()\u003c/em\u003e\u003cbr /\u003e\nÃœberprÃ¼ft, ob Spieler im Ziel.\u003c/p\u003e\u003c/td\u003e\n\u003c/tr\u003e\n\u003ctr class=\"odd\"\u003e\n\u003ctd style=\"text-align: left;\"\u003e\u003cp\u003eboolean\u003c/p\u003e\u003c/td\u003e\n\u003ctd style=\"text-align: left;\"\u003e\u003cp\u003e\u003cem\u003eownsCardOfType(CardType\ntype)\u003c/em\u003e\u003cbr /\u003e\nÃœberprÃ¼ft ob Spieler bestimmte Karte noch besitzt\u003c/p\u003e\u003c/td\u003e\n\u003c/tr\u003e\n\u003c/tbody\u003e\n\u003c/table\u003e\n\nDie VollstÃ¤ndige API ist in /doc/sc/plugin2018/Player.html zu finden.\n\nDie Meisten dieser Funktionen sind selbsterklÃ¤rend. Dennoch sind hier\neinige Beispiele angegeben:\n\n    System.out.print(\"Du hast noch folgende Karten: \");\n    for (CardType c : currentPlayer.getCards()) {\n        System.out.print(c + \" \");\n    }\n    System.out.println();\n\nDies wÃ¼rde alle Karten ausgeben, welche man noch hat.\n\n    if (currentPlayer.inGoal() \u0026\u0026 !currentPlayer.getCards().isEmpty()) {\n        System.out.println(\"Was fuer eine Verschwendung.\");\n    }\n\nDie If-Bedingung wÃ¼rde dann ausgefÃ¼hrt werden, wenn man im Ziel ist,\nallerdings noch Karten hat.\n\nEine weitere wichtige Funktion ist *getFieldIndex*. Diese Funktion wird\nhÃ¤ufig im Dokument â€žHase\\_Igel\\_Spielbrettâ€œ verwendet.\n\nNeben diesen Funktionen existieren noch einige â€žSetterâ€œ. Diese sind\nallerdings hauptsÃ¤chlich fÃ¼r den Server notwendig und haben einen\ngeringen praktischen Nutzten fÃ¼r uns.\n\n## Aufgabe\n\nSchreibe eine If-Bedingung, welche abfragt, ob beide Spieler auf dem\nselben Feld sind. Da dies nur mÃ¶glich ist, wenn man auf dem Start-\nZielfeld ist, soll zunÃ¤chst abgefragt werden, ob der aktuelle Spieler\nauf dem Start- Zielfeld ist. Tipp: Es gibt die Funktion getTypeAt der\nKlasse Board. Weiter Informationen sind im Dokument\nâ€žHase\\_Igel\\_Spielbrettâ€œ zu finden.\n\n# GameRuleLogic: Hilfreiche Hilfsfunktionen\n\nDie Klasse GameRuleLogic hat viele Hilfsfunktionen, mit welchen man die\nRegeln des Spieles Ã¼berprÃ¼fen kann. Hierbei sind alle Funktionen static.\nD.h., dass man sie ohne eine Instanz aufrufen kann.\n\n\u003ctable\u003e\n\u003ccolgroup\u003e\n\u003ccol style=\"width: 50%\" /\u003e\n\u003ccol style=\"width: 50%\" /\u003e\n\u003c/colgroup\u003e\n\u003ctbody\u003e\n\u003ctr class=\"odd\"\u003e\n\u003ctd style=\"text-align: left;\"\u003e\u003cp\u003estatic int\u003c/p\u003e\u003c/td\u003e\n\u003ctd style=\"text-align: left;\"\u003e\u003cp\u003e\u003cem\u003ecalculateCarrots(int\nmoveCount)\u003c/em\u003e\u003cbr /\u003e\nBerechnet wie viele Karotten fÃ¼r einen Zug der LÃ¤nge moveCount benÃ¶tigt\nwerden.\u003c/p\u003e\u003c/td\u003e\n\u003c/tr\u003e\n\u003ctr class=\"even\"\u003e\n\u003ctd style=\"text-align: left;\"\u003e\u003cp\u003estatic int\u003c/p\u003e\u003c/td\u003e\n\u003ctd style=\"text-align: left;\"\u003e\u003cp\u003e\u003cem\u003ecalculateMoveableFields(int\ncarrots)\u003c/em\u003e\u003cbr /\u003e\nBerechnet, wie weit man mit carrots Karotten gehen kann. Beispiel: Mit\n68 Karotten kann man 11 Felder weit gehen.\u003c/p\u003e\u003c/td\u003e\n\u003c/tr\u003e\n\u003ctr class=\"odd\"\u003e\n\u003ctd style=\"text-align: left;\"\u003e\u003cp\u003estatic boolean\u003c/p\u003e\u003c/td\u003e\n\u003ctd style=\"text-align: left;\"\u003e\u003cp\u003e\u003cem\u003ecanPlayCard(GameState\nstate)*\u003c/em\u003e\u003cbr /\u003e\nGibt zurÃ¼ck, ob der derzeitige Spieler eine Karte spielen kann.\u003c/p\u003e\u003c/td\u003e\n\u003c/tr\u003e\n\u003ctr class=\"even\"\u003e\n\u003ctd style=\"text-align: left;\"\u003e\u003cp\u003estatic boolean\u003c/p\u003e\u003c/td\u003e\n\u003ctd style=\"text-align: left;\"\u003e\u003cp\u003e\u003cem\u003eisValidToAdvance(GameState state,\nint distance)\u003c/em\u003e\u003cbr /\u003e\nÃœberprÃ¼ft \u003cem\u003eAdvance\u003c/em\u003e Aktionen auf ihre Korrektheit.\n\u003cem\u003eDistance\u003c/em\u003e steht fÃ¼r die Distanz die man zurÃ¼cklegen\nwill.Three\u003c/p\u003e\u003c/td\u003e\n\u003c/tr\u003e\n\u003ctr class=\"odd\"\u003e\n\u003ctd style=\"text-align: left;\"\u003e\u003cp\u003estatic boolean\u003c/p\u003e\u003c/td\u003e\n\u003ctd style=\"text-align: left;\"\u003e\u003cp\u003e\u003cem\u003eisValidToEat(GameState\nstate)\u003c/em\u003e\u003cbr /\u003e\nÃœberprÃ¼ft \u003cem\u003eEatSalad\u003c/em\u003e ZÃ¼ge auf Korrektheit. Diese Funktion bezieht\nsich \u003cstrong\u003enicht\u003c/strong\u003e auf die Karte\n\u003cem\u003eTAKE_OR_DROP_CARROTS\u003c/em\u003e\u003c/p\u003e\u003c/td\u003e\n\u003c/tr\u003e\n\u003ctr class=\"even\"\u003e\n\u003ctd style=\"text-align: left;\"\u003e\u003cp\u003estatic boolean\u003c/p\u003e\u003c/td\u003e\n\u003ctd style=\"text-align: left;\"\u003e\u003cp\u003e\u003cem\u003eisValidToExchangeCarrots(GameState\nstate, int n)\u003c/em\u003e\u003cbr /\u003e\nÃœberprÃ¼ft ob der derzeitige Spieler 10 Karotten nehmen oder abgeben\nkann. â€žnâ€œ kann entweder 10 oder -10 sein. Je nachdem ob man annehmen\noder abgeben will. Diese Funktion bezieht sich \u003cstrong\u003enicht\u003c/strong\u003e\nauf die Karte \u003cem\u003eEAT_SALAD\u003c/em\u003e.\u003c/p\u003e\u003c/td\u003e\n\u003c/tr\u003e\n\u003ctr class=\"odd\"\u003e\n\u003ctd style=\"text-align: left;\"\u003e\u003cp\u003estatic boolean\u003c/p\u003e\u003c/td\u003e\n\u003ctd style=\"text-align: left;\"\u003e\u003cp\u003e\u003cem\u003eisValidToFallBack(GameState\nstate)\u003c/em\u003e\u003cbr /\u003e\nÃœberprÃ¼ft \u003cem\u003eFallBack\u003c/em\u003e ZÃ¼ge auf Korrektheit\u003c/p\u003e\u003c/td\u003e\n\u003c/tr\u003e\n\u003ctr class=\"even\"\u003e\n\u003ctd style=\"text-align: left;\"\u003e\u003cp\u003estatic boolean\u003c/p\u003e\u003c/td\u003e\n\u003ctd style=\"text-align: left;\"\u003e\u003cp\u003e\u003cem\u003eisValidToPlayCard(GameState state,\nCardType c,int n)*\u003c/em\u003e\u003cbr /\u003e\nÃœberprÃ¼ft ob der derzeitige Spieler die Karte spielen kann. â€žnâ€œ wird fÃ¼r\ndie \u003cem\u003eTAKE_OR_DROP_CARROTS\u003c/em\u003e Karte benÃ¶tigt (s.u). â€žnâ€œ kann die\nWert 0, 20 oder -20 annehmen.\u003c/p\u003e\u003c/td\u003e\n\u003c/tr\u003e\n\u003ctr class=\"odd\"\u003e\n\u003ctd style=\"text-align: left;\"\u003e\u003cp\u003estatic boolean\u003c/p\u003e\u003c/td\u003e\n\u003ctd style=\"text-align: left;\"\u003e\u003cp\u003e\u003cem\u003eisValidToPlayEatSalad(GameState\nstate)*\u003c/em\u003e\u003cbr /\u003e\nÃœberprÃ¼ft ob der derzeitige Spieler die \u003cem\u003eEAT_SALAD\u003c/em\u003e Karte spielen\ndarf.\u003c/p\u003e\u003c/td\u003e\n\u003c/tr\u003e\n\u003ctr class=\"even\"\u003e\n\u003ctd style=\"text-align: left;\"\u003e\u003cp\u003estatic boolean\u003c/p\u003e\u003c/td\u003e\n\u003ctd style=\"text-align: left;\"\u003e\u003cp\u003e\u003cem\u003eisValidToPlayFallBack(GameState\nstate)*\u003c/em\u003e\u003cbr /\u003e\nÃœberprÃ¼ft ob der derzeitige Spieler die \u003cem\u003eFALL_BACK\u003c/em\u003e Karte spielen\ndarf.\u003c/p\u003e\u003c/td\u003e\n\u003c/tr\u003e\n\u003ctr class=\"odd\"\u003e\n\u003ctd style=\"text-align: left;\"\u003e\u003cp\u003estatic boolean\u003c/p\u003e\u003c/td\u003e\n\u003ctd style=\"text-align: left;\"\u003e\u003cp\u003e\u003cem\u003eisValidToPlayHurryAhead(GameState\nstate) *\u003c/em\u003e\u003cbr /\u003e\nÃœberprÃ¼ft ob der derzeitige Spieler die \u003cem\u003eHURRY_AHEAD\u003c/em\u003e Karte\nspielen darf.\u003c/p\u003e\u003c/td\u003e\n\u003c/tr\u003e\n\u003ctr class=\"even\"\u003e\n\u003ctd style=\"text-align: left;\"\u003e\u003cp\u003estatic boolean\u003c/p\u003e\u003c/td\u003e\n\u003ctd\nstyle=\"text-align: left;\"\u003e\u003cp\u003e\u003cem\u003eisValidToPlayTakeOrDropCarrots(GameState\nstate,int n)*\u003c/em\u003e\u003cbr /\u003e\nÃœberprÃ¼ft ob der derzeitige Spieler die \u003cem\u003eTAKE_OR_DROP_CARROTS\u003c/em\u003e\nKarte spielen darf. â€žnâ€œ kann entweder 0, 20 oder -20 sein.\u003c/p\u003e\u003c/td\u003e\n\u003c/tr\u003e\n\u003ctr class=\"odd\"\u003e\n\u003ctd style=\"text-align: left;\"\u003e\u003cp\u003estatic boolean\u003c/p\u003e\u003c/td\u003e\n\u003ctd style=\"text-align: left;\"\u003e\u003cp\u003e\u003cem\u003eisValidToSkip(GameState\nstate)\u003c/em\u003e\u003cbr /\u003e\nÃœberprÃ¼ft, ob der derzeitige Spieler aussetzen darf.\u003c/p\u003e\u003c/td\u003e\n\u003c/tr\u003e\n\u003ctr class=\"even\"\u003e\n\u003ctd style=\"text-align: left;\"\u003e\u003cp\u003estatic boolean\u003c/p\u003e\u003c/td\u003e\n\u003ctd style=\"text-align: left;\"\u003e\u003cp\u003e\u003cem\u003emustEatSalad(GameState\nstate)\u003c/em\u003e\u003cbr /\u003e\nÃœberprÃ¼ft ob man einen Salat fressen muss. Dies ist immer der Fall, wenn\nman in der vorherigen Runde ein Salatfeld betreten hat.\u003c/p\u003e\u003c/td\u003e\n\u003c/tr\u003e\n\u003ctr class=\"odd\"\u003e\n\u003ctd style=\"text-align: left;\"\u003e\u003cp\u003estatic boolean\u003c/p\u003e\u003c/td\u003e\n\u003ctd style=\"text-align: left;\"\u003e\u003cp\u003e\u003cem\u003emustPlayCard(GameState state)\n*\u003c/em\u003e\u003cbr /\u003e\nÃœberprÃ¼ft ob eine Karte gespielt werden muss.\u003c/p\u003e\u003c/td\u003e\n\u003c/tr\u003e\n\u003ctr class=\"even\"\u003e\n\u003ctd style=\"text-align: left;\"\u003e\u003cp\u003estatic boolean\u003c/p\u003e\u003c/td\u003e\n\u003ctd style=\"text-align: left;\"\u003e\u003cp\u003e\u003cem\u003eplayerMustAdvance(GameState\nstate)\u003c/em\u003e\u003cbr /\u003e\nÃœberprÃ¼ft ab der derzeitige Spieler im nÃ¤chsten Zug einen VorwÃ¤rtszug\nmachen muss.\u003c/p\u003e\u003c/td\u003e\n\u003c/tr\u003e\n\u003c/tbody\u003e\n\u003c/table\u003e\n\n\\*Diese Funktionen werden im Kapitel â€žErweiterte Beispieleâ€œ besprochen.\n\nDie komplette API-Dokumentation ist in\ndoc/sc/plugin2018/util/GameRuleLogic.html zu finden.\n\n## Simulation des Gegners\n\nNatÃ¼rlich kann man alle diese Funktionen auch auf den Gegenspieler\nanwenden. DafÃ¼r mÃ¼ssen wir allerdings eine Kopie des GameState\nerstellen:\n\n    try {\n      GameState otherGame = gameState.clone(); // Deep-Copy\n      // Rundenanzahl hochsetzten fÃ¼r switch Befehl:\n      otherGame.setTurn(gameState.getTurn()+1);\n      // Tausche currentPlayer (hÃ¤ngt von der Rundenanzahl ab):\n      otherGame.switchCurrentPlayer();\n      // Gib Informationen Ã¼ber den Gegner aus:\n      System.out.println(\"CurrentPlayer von otherGame:\" + otherGame.getCurrentPlayer());\n    } catch (CloneNotSupportedException e1) { // Fehlerbehandlung\n      e1.printStackTrace();\n    }\n\nAlle Funktionen von GameRuleLogic kÃ¶nnen wir nun, mithilfe der Variable\notherGame, auf den Gegner anwenden.\n\n## EinfÃ¼hrende Beispiele\n\nDie meisten Funktionen dieser Klasse sind selbsterklÃ¤rend. Dennoch\nwerden einige der hÃ¤ufig verwendeten Funktionen mit kleinen Beispielen\nvorgestellt.\n\n    if (GameRuleLogic.isValidToEat(gameState) != GameRuleLogic.mustEatSalad(gameState)) {\n      System.out.println(\"UnmÃ¶glich\");\n    }\n\nNach den Regeln muss man immer ein Salat essen, wenn man im vorherigen\nZug ein Salatfeld betreten hat. AuÃŸerdem ist dies die einzige\nMÃ¶glichkeit die Aktion EatSalad auszufÃ¼hren (nicht mit dem Spielen der\nEAT\\_SALAD Karte verwechseln).\n\nDadurch wird auch die UnerfÃ¼llbarkeit des folgenden Ausdrucks\nimpliziert:\n\n    if (GameRuleLogic.isValidToEat(gameState) \u0026\u0026\n        (GameRuleLogic.isValidToFallBack(gameState) || GameRuleLogic.canMove(gameState))) {\n      System.out.println(\"UnmÃ¶glich\");\n    }\n\nEine weiter hilfreiche Funktion ist *isValidToAdvance*. Mit dieser\nFunktion wird Ã¼berprÃ¼ft, ob ein VorwÃ¤rtszug mit der Ã¼bergeben Distanz\nÃ¼berhaupt mÃ¶glich ist:\n\n    // berechne die maximale Entfernung, welche man laufen darf\n    int max_move = GameRuleLogic.calculateMoveableFields(currentPlayer.getCarrots());\n\n    if (GameRuleLogic.isValidToAdvance(gameState, max_move +1)) {\n      System.out.println(\"UnmÃ¶glich\");\n    }\n\nDie Funktion *calculateMoveableFields* gibt hierbei die maximale\nEntfernung zurÃ¼ck, welche man mit den Ã¼bergebenen Karotten laufen darf.\nDiese maximale Entfernung wird immer um 1 erhÃ¶ht, was dazu fÃ¼hrt, dass\nder Zug immer unmÃ¶glich ist.\n\n## Erweitertes Beispiel\n\nAlle Funktionen die mit einem \\* markiert wurden (s.o) haben eine\nGemeinsamkeit. Sie beziehen sich auf das Spielen von Karten. Das Spielen\nvon Karten ist allerdings nur erlaubt, wenn man das entsprechende\nHasenfeld in der selben Zug betreten hat. Deshalb mÃ¼ssen wir GameState\nbearbeiten, damit diese Funktionen Ã¼berhaupt Sinn haben. Das folgende\nBeispiel gibt eine MÃ¶glichkeit an, wie man diese Funktionen einsetzten\nkann:\n\n    int nextHareFieldIndex = gameState.getNextFieldByType(FieldType.HARE,\n                                                          currentPlayer.getFieldIndex())\n    // wenn es ein nÃ¤chstes Hasenfeld gibt\n    if (nextHareFieldIndex \u003e 0) {\n      try {\n\n        GameState gameHare = gameState.clone(); // erstelle Deep-Copy\n        Player harePlayer = gameHare.getCurrentPlayer(); // erstelle Shallow-Copy\n\n        //setzte den aktuellen Spieler auf ein Hasenfeld\n        harePlayer.setFieldIndex(nextHareFieldIndex);\n        System.out.println(gameHare.getCurrentPlayer().getCards()); // gib alle Karten aus\n\n        // Welche Karten kann man spielen?\n        System.out.println(\"Play EatSalad: \" +\n                           GameRuleLogic.isValidToPlayEatSalad(gameHare));\n        System.out.println(\"Play TakeOrDropCarrots: \" +\n                           GameRuleLogic.isValidToPlayTakeOrDropCarrots(gameHare,20));\n        System.out.println(\"Play HurryAhead: \" +\n                           GameRuleLogic.isValidToPlayHurryAhead(gameHare));\n        System.out.println(\"Play FallBack: \" +\n                           GameRuleLogic.isValidToPlayFallBack(gameHare));\n\n      } catch (CloneNotSupportedException e1) {\n        e1.printStackTrace();\n      }\n    }\n\nHierfÃ¼r mÃ¼ssen wir den Spieler einfach nur auf das Hasenfeld setzten.\nAllerdings wird nicht Ã¼berprÃ¼ft, ob der Spieler Ã¼berhaupt bis zum\nnÃ¤chsten Hasenfeld laufen kann.\n\n## Aufgaben\n\n1.  Ist das AusfÃ¼hren der inneren If-Bedingung wirklich unmÃ¶glich.\n    ErklÃ¤re warum oder gib ein Gegenbeispiel an:\n\n\u003c!-- --\u003e\n\n    int dif = gameState.getOtherPlayer().getFieldIndex() - currentPlayer.getFieldIndex();\n\n    if (dif \u003e= 0 \u0026\u0026\n        dif \u003c= GameRuleLogic.calculateMoveableFields(currentPlayer.getCarrots())) {\n      if (GameRuleLogic.isValidToAdvance(gameState, dif)) {\n        System.out.println(\"UnmÃ¶glich\");\n      }\n    }\n\n1.  Erweiterte das Beispiel aus dem Kapitel â€žErweitertes Beispielâ€œ so,\n    dass sicher gestellt wird, dass der aktuelle Spieler auf ein\n    Hasenfeld gesetzt wird, welches er wirklich erreichen kann.\n\n[1] Technisch gesehen hat die Klasse eine private Liste von Feldern.\nAllerdings Ã¤hnelt ein Aufruf der Funktion getTypeAt sehr den Aufruf\neines Arrays. Auch wenn der RÃ¼ckgabewert kein Feld sonder ein FieldType\nist.\n","data":{},"navigation":{"next":{"name":"einleitung-xml","repo":"https://github.com/software-challenge/docs/tree/main/hyperbook/book/spiele/hase-und-igel/xml-dokumentation/einleitung-xml.md","href":"/spiele/hase-und-igel/xml-dokumentation/einleitung-xml"},"current":{"name":"tutorial","repo":"https://github.com/software-challenge/docs/tree/main/hyperbook/book/spiele/hase-und-igel/tutorial/tutorial.md","href":"/spiele/hase-und-igel/tutorial/tutorial"},"previous":{"name":"start","repo":"https://github.com/software-challenge/docs/tree/main/hyperbook/book/spiele/hase-und-igel/tutorial/start.md","href":"/spiele/hase-und-igel/tutorial/start"},"sections":[{"name":"Die Software-Challenge","index":0,"expanded":true,"isEmpty":false,"pages":[{"name":"WettkampfmodalitÃ¤ten","index":2,"repo":"https://github.com/software-challenge/docs/tree/main/hyperbook/book/allgemein/wettkampf.md","href":"/allgemein/wettkampf"},{"name":"Das Spiel kennenlernen","index":3,"repo":"https://github.com/software-challenge/docs/tree/main/hyperbook/book/allgemein/spiel.md","href":"/allgemein/spiel"}],"sections":[],"repo":"https://github.com/software-challenge/docs/tree/main/hyperbook/book/allgemein/index.md","href":"/allgemein"},{"name":"Spiele","index":1,"virtual":true,"isEmpty":true,"pages":[],"sections":[{"name":"Blokus","hide":true,"isEmpty":false,"pages":[],"sections":[{"name":"Spielregeln","hide":true,"isEmpty":true,"pages":[{"name":"content","repo":"https://github.com/software-challenge/docs/tree/main/hyperbook/book/spiele/blokus/spielregeln/content.md","href":"/spiele/blokus/spielregeln/content"},{"name":"regeln","repo":"https://github.com/software-challenge/docs/tree/main/hyperbook/book/spiele/blokus/spielregeln/regeln.md","href":"/spiele/blokus/spielregeln/regeln"}],"sections":[],"repo":"https://github.com/software-challenge/docs/tree/main/hyperbook/book/spiele/blokus/spielregeln/index.md","href":"/spiele/blokus/spielregeln"},{"name":"XML-Dokumentation","hide":true,"isEmpty":true,"pages":[{"name":"einleitung-xml","repo":"https://github.com/software-challenge/docs/tree/main/hyperbook/book/spiele/blokus/xml-dokumentation/einleitung-xml.md","href":"/spiele/blokus/xml-dokumentation/einleitung-xml"},{"name":"spiel-betreten","repo":"https://github.com/software-challenge/docs/tree/main/hyperbook/book/spiele/blokus/xml-dokumentation/spiel-betreten.md","href":"/spiele/blokus/xml-dokumentation/spiel-betreten"},{"name":"spiel-verlassen","repo":"https://github.com/software-challenge/docs/tree/main/hyperbook/book/spiele/blokus/xml-dokumentation/spiel-verlassen.md","href":"/spiele/blokus/xml-dokumentation/spiel-verlassen"},{"name":"spielergebnis","repo":"https://github.com/software-challenge/docs/tree/main/hyperbook/book/spiele/blokus/xml-dokumentation/spielergebnis.md","href":"/spiele/blokus/xml-dokumentation/spielergebnis"},{"name":"spielstatus","repo":"https://github.com/software-challenge/docs/tree/main/hyperbook/book/spiele/blokus/xml-dokumentation/spielstatus.md","href":"/spiele/blokus/xml-dokumentation/spielstatus"},{"name":"spielsteine","repo":"https://github.com/software-challenge/docs/tree/main/hyperbook/book/spiele/blokus/xml-dokumentation/spielsteine.md","href":"/spiele/blokus/xml-dokumentation/spielsteine"},{"name":"spielverlauf","repo":"https://github.com/software-challenge/docs/tree/main/hyperbook/book/spiele/blokus/xml-dokumentation/spielverlauf.md","href":"/spiele/blokus/xml-dokumentation/spielverlauf"},{"name":"xml-dokumentation","repo":"https://github.com/software-challenge/docs/tree/main/hyperbook/book/spiele/blokus/xml-dokumentation/xml-dokumentation.md","href":"/spiele/blokus/xml-dokumentation/xml-dokumentation"},{"name":"zuege-senden","repo":"https://github.com/software-challenge/docs/tree/main/hyperbook/book/spiele/blokus/xml-dokumentation/zuege-senden.md","href":"/spiele/blokus/xml-dokumentation/zuege-senden"},{"name":"zug-anforderung","repo":"https://github.com/software-challenge/docs/tree/main/hyperbook/book/spiele/blokus/xml-dokumentation/zug-anforderung.md","href":"/spiele/blokus/xml-dokumentation/zug-anforderung"}],"sections":[],"repo":"https://github.com/software-challenge/docs/tree/main/hyperbook/book/spiele/blokus/xml-dokumentation/index.md","href":"/spiele/blokus/xml-dokumentation"}],"repo":"https://github.com/software-challenge/docs/tree/main/hyperbook/book/spiele/blokus/index.md","href":"/spiele/blokus"},{"name":"Hase und Igel","hide":true,"isEmpty":false,"pages":[],"sections":[{"name":"Spielregeln","hide":true,"isEmpty":true,"pages":[{"name":"beispiel","repo":"https://github.com/software-challenge/docs/tree/main/hyperbook/book/spiele/hase-und-igel/spielregeln/beispiel.md","href":"/spiele/hase-und-igel/spielregeln/beispiel"},{"name":"felder","repo":"https://github.com/software-challenge/docs/tree/main/hyperbook/book/spiele/hase-und-igel/spielregeln/felder.md","href":"/spiele/hase-und-igel/spielregeln/felder"},{"name":"regeln","repo":"https://github.com/software-challenge/docs/tree/main/hyperbook/book/spiele/hase-und-igel/spielregeln/regeln.md","href":"/spiele/hase-und-igel/spielregeln/regeln"},{"name":"spielbeginn","repo":"https://github.com/software-challenge/docs/tree/main/hyperbook/book/spiele/hase-und-igel/spielregeln/spielbeginn.md","href":"/spiele/hase-und-igel/spielregeln/spielbeginn"},{"name":"spielende","repo":"https://github.com/software-challenge/docs/tree/main/hyperbook/book/spiele/hase-und-igel/spielregeln/spielende.md","href":"/spiele/hase-und-igel/spielregeln/spielende"},{"name":"zuege","repo":"https://github.com/software-challenge/docs/tree/main/hyperbook/book/spiele/hase-und-igel/spielregeln/zuege.md","href":"/spiele/hase-und-igel/spielregeln/zuege"}],"sections":[],"repo":"https://github.com/software-challenge/docs/tree/main/hyperbook/book/spiele/hase-und-igel/spielregeln/index.md","href":"/spiele/hase-und-igel/spielregeln"},{"name":"Tutorial","hide":true,"isEmpty":true,"pages":[{"name":"board","repo":"https://github.com/software-challenge/docs/tree/main/hyperbook/book/spiele/hase-und-igel/tutorial/board.md","href":"/spiele/hase-und-igel/tutorial/board"},{"name":"game-rule-logic","repo":"https://github.com/software-challenge/docs/tree/main/hyperbook/book/spiele/hase-und-igel/tutorial/game-rule-logic.md","href":"/spiele/hase-und-igel/tutorial/game-rule-logic"},{"name":"player","repo":"https://github.com/software-challenge/docs/tree/main/hyperbook/book/spiele/hase-und-igel/tutorial/player.md","href":"/spiele/hase-und-igel/tutorial/player"},{"name":"start","repo":"https://github.com/software-challenge/docs/tree/main/hyperbook/book/spiele/hase-und-igel/tutorial/start.md","href":"/spiele/hase-und-igel/tutorial/start"},{"name":"tutorial","repo":"https://github.com/software-challenge/docs/tree/main/hyperbook/book/spiele/hase-und-igel/tutorial/tutorial.md","href":"/spiele/hase-und-igel/tutorial/tutorial"}],"sections":[],"repo":"https://github.com/software-challenge/docs/tree/main/hyperbook/book/spiele/hase-und-igel/tutorial/index.md","href":"/spiele/hase-und-igel/tutorial"},{"name":"XML-Dokumentation","hide":true,"isEmpty":true,"pages":[{"name":"einleitung-xml","repo":"https://github.com/software-challenge/docs/tree/main/hyperbook/book/spiele/hase-und-igel/xml-dokumentation/einleitung-xml.md","href":"/spiele/hase-und-igel/xml-dokumentation/einleitung-xml"},{"name":"fehler","repo":"https://github.com/software-challenge/docs/tree/main/hyperbook/book/spiele/hase-und-igel/xml-dokumentation/fehler.md","href":"/spiele/hase-und-igel/xml-dokumentation/fehler"},{"name":"spiel-betreten","repo":"https://github.com/software-challenge/docs/tree/main/hyperbook/book/spiele/hase-und-igel/xml-dokumentation/spiel-betreten.md","href":"/spiele/hase-und-igel/xml-dokumentation/spiel-betreten"},{"name":"spiel-verlassen","repo":"https://github.com/software-challenge/docs/tree/main/hyperbook/book/spiele/hase-und-igel/xml-dokumentation/spiel-verlassen.md","href":"/spiele/hase-und-igel/xml-dokumentation/spiel-verlassen"},{"name":"spielergebnis","repo":"https://github.com/software-challenge/docs/tree/main/hyperbook/book/spiele/hase-und-igel/xml-dokumentation/spielergebnis.md","href":"/spiele/hase-und-igel/xml-dokumentation/spielergebnis"},{"name":"spielstatus","repo":"https://github.com/software-challenge/docs/tree/main/hyperbook/book/spiele/hase-und-igel/xml-dokumentation/spielstatus.md","href":"/spiele/hase-und-igel/xml-dokumentation/spielstatus"},{"name":"spielverlauf","repo":"https://github.com/software-challenge/docs/tree/main/hyperbook/book/spiele/hase-und-igel/xml-dokumentation/spielverlauf.md","href":"/spiele/hase-und-igel/xml-dokumentation/spielverlauf"},{"name":"xml-dokumentation","repo":"https://github.com/software-challenge/docs/tree/main/hyperbook/book/spiele/hase-und-igel/xml-dokumentation/xml-dokumentation.md","href":"/spiele/hase-und-igel/xml-dokumentation/xml-dokumentation"},{"name":"zuege-senden","repo":"https://github.com/software-challenge/docs/tree/main/hyperbook/book/spiele/hase-und-igel/xml-dokumentation/zuege-senden.md","href":"/spiele/hase-und-igel/xml-dokumentation/zuege-senden"},{"name":"zug-anforderung","repo":"https://github.com/software-challenge/docs/tree/main/hyperbook/book/spiele/hase-und-igel/xml-dokumentation/zug-anforderung.md","href":"/spiele/hase-und-igel/xml-dokumentation/zug-anforderung"}],"sections":[],"repo":"https://github.com/software-challenge/docs/tree/main/hyperbook/book/spiele/hase-und-igel/xml-dokumentation/index.md","href":"/spiele/hase-und-igel/xml-dokumentation"}],"repo":"https://github.com/software-challenge/docs/tree/main/hyperbook/book/spiele/hase-und-igel/index.md","href":"/spiele/hase-und-igel"},{"name":"Hey, Danke fÃ¼r den Fisch!","hide":true,"expanded":true,"isEmpty":false,"pages":[{"name":"Spielregeln","index":1,"repo":"https://github.com/software-challenge/docs/tree/main/hyperbook/book/spiele/penguins/regeln.md","href":"/spiele/penguins/regeln"},{"name":"XML-Schnittstelle","repo":"https://github.com/software-challenge/docs/tree/main/hyperbook/book/spiele/penguins/xml.md","href":"/spiele/penguins/xml"}],"sections":[],"repo":"https://github.com/software-challenge/docs/tree/main/hyperbook/book/spiele/penguins/index.md","href":"/spiele/penguins"},{"name":"Hive","hide":true,"isEmpty":false,"pages":[],"sections":[{"name":"Spielregeln","hide":true,"isEmpty":true,"pages":[{"name":"regeln","repo":"https://github.com/software-challenge/docs/tree/main/hyperbook/book/spiele/hive/spielregeln/regeln.md","href":"/spiele/hive/spielregeln/regeln"}],"sections":[],"repo":"https://github.com/software-challenge/docs/tree/main/hyperbook/book/spiele/hive/spielregeln/index.md","href":"/spiele/hive/spielregeln"},{"name":"XML-Dokumention","hide":true,"isEmpty":true,"pages":[{"name":"einleitung-xml","repo":"https://github.com/software-challenge/docs/tree/main/hyperbook/book/spiele/hive/xml-dokumentation/einleitung-xml.md","href":"/spiele/hive/xml-dokumentation/einleitung-xml"},{"name":"fehler","repo":"https://github.com/software-challenge/docs/tree/main/hyperbook/book/spiele/hive/xml-dokumentation/fehler.md","href":"/spiele/hive/xml-dokumentation/fehler"},{"name":"spiel-betreten","repo":"https://github.com/software-challenge/docs/tree/main/hyperbook/book/spiele/hive/xml-dokumentation/spiel-betreten.md","href":"/spiele/hive/xml-dokumentation/spiel-betreten"},{"name":"spiel-verlassen","repo":"https://github.com/software-challenge/docs/tree/main/hyperbook/book/spiele/hive/xml-dokumentation/spiel-verlassen.md","href":"/spiele/hive/xml-dokumentation/spiel-verlassen"},{"name":"spielergebnis","repo":"https://github.com/software-challenge/docs/tree/main/hyperbook/book/spiele/hive/xml-dokumentation/spielergebnis.md","href":"/spiele/hive/xml-dokumentation/spielergebnis"},{"name":"spielstatus","repo":"https://github.com/software-challenge/docs/tree/main/hyperbook/book/spiele/hive/xml-dokumentation/spielstatus.md","href":"/spiele/hive/xml-dokumentation/spielstatus"},{"name":"spielverlauf","repo":"https://github.com/software-challenge/docs/tree/main/hyperbook/book/spiele/hive/xml-dokumentation/spielverlauf.md","href":"/spiele/hive/xml-dokumentation/spielverlauf"},{"name":"xml-dokumentation","repo":"https://github.com/software-challenge/docs/tree/main/hyperbook/book/spiele/hive/xml-dokumentation/xml-dokumentation.md","href":"/spiele/hive/xml-dokumentation/xml-dokumentation"},{"name":"zuege-senden","repo":"https://github.com/software-challenge/docs/tree/main/hyperbook/book/spiele/hive/xml-dokumentation/zuege-senden.md","href":"/spiele/hive/xml-dokumentation/zuege-senden"},{"name":"zug-anforderung","repo":"https://github.com/software-challenge/docs/tree/main/hyperbook/book/spiele/hive/xml-dokumentation/zug-anforderung.md","href":"/spiele/hive/xml-dokumentation/zug-anforderung"}],"sections":[],"repo":"https://github.com/software-challenge/docs/tree/main/hyperbook/book/spiele/hive/xml-dokumentation/index.md","href":"/spiele/hive/xml-dokumentation"}],"repo":"https://github.com/software-challenge/docs/tree/main/hyperbook/book/spiele/hive/index.md","href":"/spiele/hive"},{"name":"Mississippi Queen","expanded":true,"isEmpty":false,"pages":[{"name":"Spielregeln","index":2,"repo":"https://github.com/software-challenge/docs/tree/main/hyperbook/book/spiele/mississippi-queen/regeln.md","href":"/spiele/mississippi-queen/regeln"}],"sections":[],"repo":"https://github.com/software-challenge/docs/tree/main/hyperbook/book/spiele/mississippi-queen/index.md","href":"/spiele/mississippi-queen"},{"name":"Ostseeschach","hide":true,"isEmpty":false,"pages":[{"name":"regeln","repo":"https://github.com/software-challenge/docs/tree/main/hyperbook/book/spiele/ostseeschach/regeln.md","href":"/spiele/ostseeschach/regeln"},{"name":"xml-dokumentation","repo":"https://github.com/software-challenge/docs/tree/main/hyperbook/book/spiele/ostseeschach/xml-dokumentation.md","href":"/spiele/ostseeschach/xml-dokumentation"}],"sections":[],"repo":"https://github.com/software-challenge/docs/tree/main/hyperbook/book/spiele/ostseeschach/index.md","href":"/spiele/ostseeschach"},{"name":"Piranhas","hide":true,"isEmpty":false,"pages":[],"sections":[{"name":"Spielregeln","hide":true,"isEmpty":true,"pages":[{"name":"regeln","repo":"https://github.com/software-challenge/docs/tree/main/hyperbook/book/spiele/piranhas/spielregeln/regeln.md","href":"/spiele/piranhas/spielregeln/regeln"}],"sections":[],"repo":"https://github.com/software-challenge/docs/tree/main/hyperbook/book/spiele/piranhas/spielregeln/index.md","href":"/spiele/piranhas/spielregeln"},{"name":"XML-Dokumentation","hide":true,"isEmpty":true,"pages":[{"name":"einleitung-xml","repo":"https://github.com/software-challenge/docs/tree/main/hyperbook/book/spiele/piranhas/xml-dokumentation/einleitung-xml.md","href":"/spiele/piranhas/xml-dokumentation/einleitung-xml"},{"name":"fehler","repo":"https://github.com/software-challenge/docs/tree/main/hyperbook/book/spiele/piranhas/xml-dokumentation/fehler.md","href":"/spiele/piranhas/xml-dokumentation/fehler"},{"name":"spiel-betreten","repo":"https://github.com/software-challenge/docs/tree/main/hyperbook/book/spiele/piranhas/xml-dokumentation/spiel-betreten.md","href":"/spiele/piranhas/xml-dokumentation/spiel-betreten"},{"name":"spiel-verlassen","repo":"https://github.com/software-challenge/docs/tree/main/hyperbook/book/spiele/piranhas/xml-dokumentation/spiel-verlassen.md","href":"/spiele/piranhas/xml-dokumentation/spiel-verlassen"},{"name":"spielergebnis","repo":"https://github.com/software-challenge/docs/tree/main/hyperbook/book/spiele/piranhas/xml-dokumentation/spielergebnis.md","href":"/spiele/piranhas/xml-dokumentation/spielergebnis"},{"name":"spielstatus","repo":"https://github.com/software-challenge/docs/tree/main/hyperbook/book/spiele/piranhas/xml-dokumentation/spielstatus.md","href":"/spiele/piranhas/xml-dokumentation/spielstatus"},{"name":"spielverlauf","repo":"https://github.com/software-challenge/docs/tree/main/hyperbook/book/spiele/piranhas/xml-dokumentation/spielverlauf.md","href":"/spiele/piranhas/xml-dokumentation/spielverlauf"},{"name":"xml-dokumentation","repo":"https://github.com/software-challenge/docs/tree/main/hyperbook/book/spiele/piranhas/xml-dokumentation/xml-dokumentation.md","href":"/spiele/piranhas/xml-dokumentation/xml-dokumentation"},{"name":"zuege-senden","repo":"https://github.com/software-challenge/docs/tree/main/hyperbook/book/spiele/piranhas/xml-dokumentation/zuege-senden.md","href":"/spiele/piranhas/xml-dokumentation/zuege-senden"},{"name":"zug-anforderung","repo":"https://github.com/software-challenge/docs/tree/main/hyperbook/book/spiele/piranhas/xml-dokumentation/zug-anforderung.md","href":"/spiele/piranhas/xml-dokumentation/zug-anforderung"}],"sections":[],"repo":"https://github.com/software-challenge/docs/tree/main/hyperbook/book/spiele/piranhas/xml-dokumentation/index.md","href":"/spiele/piranhas/xml-dokumentation"}],"repo":"https://github.com/software-challenge/docs/tree/main/hyperbook/book/spiele/piranhas/index.md","href":"/spiele/piranhas"}],"repo":"https://github.com/software-challenge/docs/tree/main/hyperbook/book/spiele/index.md","href":"/spiele"},{"name":"Entwicklung","index":2,"isEmpty":false,"pages":[{"name":"Objektorientierte Programmierung","index":3,"repo":"https://github.com/software-challenge/docs/tree/main/hyperbook/book/entwicklung/einfuehrung-oop.md","href":"/entwicklung/einfuehrung-oop"},{"name":"Sauberer Programmierstil","index":4,"repo":"https://github.com/software-challenge/docs/tree/main/hyperbook/book/entwicklung/sauberer-programmierstil.md","href":"/entwicklung/sauberer-programmierstil"},{"name":"Installation von Java","index":5,"repo":"https://github.com/software-challenge/docs/tree/main/hyperbook/book/entwicklung/installation-von-java.md","href":"/entwicklung/installation-von-java"},{"name":"Einrichtung der Entwicklungsumgebung","index":6,"repo":"https://github.com/software-challenge/docs/tree/main/hyperbook/book/entwicklung/einrichtung-der-entwicklungsumgebung.md","href":"/entwicklung/einrichtung-der-entwicklungsumgebung"},{"name":"Bedienung von Eclipse","index":7,"repo":"https://github.com/software-challenge/docs/tree/main/hyperbook/book/entwicklung/bedienung-von-eclipse.md","href":"/entwicklung/bedienung-von-eclipse"},{"name":"Spielervorlage erweitern","index":7,"repo":"https://github.com/software-challenge/docs/tree/main/hyperbook/book/entwicklung/simpleclient-erweitern.md","href":"/entwicklung/simpleclient-erweitern"},{"name":"Idee implementieren","index":8,"repo":"https://github.com/software-challenge/docs/tree/main/hyperbook/book/entwicklung/eine-idee-implementieren.md","href":"/entwicklung/eine-idee-implementieren"},{"name":"Computerspieler abgabefertig machen","index":9,"repo":"https://github.com/software-challenge/docs/tree/main/hyperbook/book/entwicklung/abgabe.md","href":"/entwicklung/abgabe"}],"sections":[],"repo":"https://github.com/software-challenge/docs/tree/main/hyperbook/book/entwicklung/index.md","href":"/entwicklung"}],"pages":[{"name":"Start","index":1,"repo":"https://github.com/software-challenge/docs/tree/main/hyperbook/book/index.md","href":"/"},{"name":"Technische Grundlagen","index":2,"repo":"https://github.com/software-challenge/docs/tree/main/hyperbook/book/glossar.md","href":"/glossar"},{"name":"Lesezeichen","index":3,"repo":"https://github.com/software-challenge/docs/tree/main/hyperbook/book/bookmark.md","href":"/bookmark"},{"name":"F.A.Q.","index":4,"repo":"https://github.com/software-challenge/docs/tree/main/hyperbook/book/faq.md","href":"/faq"}]}},"__N_SSG":true},"page":"/[[...page]]","query":{"page":["spiele","hase-und-igel","tutorial","tutorial"]},"buildId":"gJRxG6W-71yU5ToWtMTf6","isFallback":false,"gsp":true,"scriptLoader":[]}</script></body></html>