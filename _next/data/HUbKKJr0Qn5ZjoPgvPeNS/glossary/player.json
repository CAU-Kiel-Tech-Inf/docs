{"pageProps":{"locale":"de","markdown":"\n# Der Computerspieler\n\nDer Computerspieler ist ein Programm, \ndas sich mit dem :t[Spielleiter]{#server} verbindet \nund die gestellte Aufgabe selbstständig löst.\nDie Aufgabe der Schülerinnen und Schüler ist es,\nsich eine Strategie zu überlegen und zu implementieren,\nmit der sie gegen die Spieler der anderen Teams gewinnen können.\n\nDer Computerspieler kann in einer beliebigen Programmiersprache geschrieben sein,\nfür einige Sprachen werden aber bereits Muster-Computerspieler \nim [Downloadbereich der Software-Challenge Website](https://software-challenge.de/dokumentation-und-material) bereitgestellt,\ndie für Neulinge sehr zu empfehlen sind,\nda so die :t[XML-Schnittstelle]{#xml} nicht beachtet werden muss.\n\n**Hinweis:** Das :t[Spielleiter-Programm]{#server} benötigt :t[Java]{#java}.\nDeshalb muss auf den ausführenden Rechnern \nauch das [Java SDK installiert](entwicklung/installation-von-java) sein.\n\n## Der Zufallsspieler\n\nDer Zufallsspieler ist ein Computerspieler, den das Institut für\nInformatik ins Rennen schickt. Er stellt zwar eine korrekte Lösung der\ngestellten Aufgabe dar, ist aber nicht besonders intelligent. Neben dem\neigentlichen Programm ist auch der Quellcode des Zufallsspielers\nverfügbar. Auf diese Weise können sich die Schülerinnen und Schüler \nanschauen und lernen, wie man die gestellte Aufgabe lösen kann. Außerdem \ndarf der Code um die eigene Strategie erweitert werden. Auf diese Weise \nmüssen die Schülerinnen und Schüler nicht den ganzen Computerspieler \nselbst entwickeln, sondern können sich auf den Entwurf und die \nImplementierung ihrer eigenen Strategie konzentrieren.\n\n## Der Fortgeschrittene Spieler\n\nWenn die aktuelle Saison der Software-Challenge etwas weiter\nfortgeschritten ist, stellt das Institut einen stärkeren Computerspieler\nzur Verfügung: den Fortgeschrittenen Spieler. Das ist ein Spieler, der eine\neffizientere Strategie zur Lösung der Aufgabe als der Zufallsspieler\nverfolgt und dadurch nicht mehr so leicht zu schlagen ist. Dieser\nSpieler wird ohne den Quellcode veröffentlicht, so dass die \nSchülerinnen und Schüler den Fortgeschrittenen Spieler zwar als \nGegenspieler für Testspiele nehmen, jedoch nicht den Quellcode für den \neigenen Spieler weiterverwenden können.\n","data":{"name":"Computerspieler","index":1},"references":[{"folder":"book","path":{"directory":"","absolute":"/home/runner/work/docs/docs/hyperbook/.hyperbook/book/glossar.md","relative":"glossar.md","href":"/glossar"},"extension":".md","name":"glossar","root":"/home/runner/work/docs/docs/hyperbook/.hyperbook","markdown":{"content":"\n## Spielinfrastruktur\n\n:t[Computerspieler]{#player}\n\n:t[Spielleiter]{#server}\n\n:t[Wettkampfsystem]{#contest}\n","data":{"name":"Technische Grundlagen","index":2},"elements":["t"]}},{"folder":"book","path":{"directory":"","absolute":"/home/runner/work/docs/docs/hyperbook/.hyperbook/book/wettbewerb.md","relative":"wettbewerb.md","href":"/wettbewerb"},"extension":".md","name":"wettbewerb","root":"/home/runner/work/docs/docs/hyperbook/.hyperbook","markdown":{"content":"\n# Die Software-Challenge\n\nDie Software-Challenge ist ein Schulprojekt, das durch das Institut für\nInformatik der CAU Kiel veranstaltet wird und das durch zahlreiche\nUnternehmen, die Prof. Dr. Werner Petersen-Stiftung sowie das\nMinisterium für Wissenschaft, Wirtschaft und Verkehr des Landes\nSchleswig-Holstein finanziert wird. In Zusammenarbeit mit den Gymnasien\nund Gesamtschulen, dem Institut für Informatik sowie den Firmen soll in\ndiesem Projekt der Informatik-Unterricht in praxisbezogener Weise\nmitgestaltet und dadurch aufgewertet werden. Gegenstand der\nSoftware-Challenge ist ein Programmierwettbewerb, der während des\ngesamten Schuljahres läuft, und der den Schülerinnen und Schülern die\nMöglichkeit bietet, mit Spaß und Spannung sowie mit kompetenter\nBegleitung in die Welt der Informatik einzusteigen. Am Ende der\nEntwicklungsphase schickt jedes Team (Kurs oder AG) einen selbst\nprogrammierten :t[Computerspieler]{#player} für das Spiel in den Wettkampf. Dieser\nWettkampf besteht zunächst aus einer kompletten Meisterschaft (jeder\ngegen jeden) und anschließend aus einem Finale der 8 führenden Teams\n(Final Eight). Als Preise winken neben zahlreichen Sachpreisen auch\nStipendien für die besten Schülerinnen und Schüler. In jeder Phase des\nProjekts wird in der Presse und im Radio über den jeweils aktuellen\nStand berichtet.\n\n## Teilnahmebedingungen und Registrierung\n\nTeilnahmeberechtigt sind alle zur Hochschulreife führenden Schulen der\nBundesrepublik Deutschland. Jede Schule kann sich dabei mit mehreren\nKursen oder AGs (höchstens 3 Teams) anmelden. Jedes Team sollte dabei aus\nmindestens 3 Schülerinnen und Schülern und einer betreuenden Lehrkraft bestehen.\nJeder Kurs bzw. jede AG darf nur ein Team anmelden. Dabei kann es in der\nAnfangsphase durchaus Sinn machen, intern in einem Team mehrere Gruppen\nzu bilden, um z.B. unterschiedliche Strategien zu testen und\n:t[Computerspieler]{#player} zu entwickeln. Spätestens zu Beginn der Wettkampfphase\nmuss sich das Team jedoch auf einen :t[Computerspieler]{#player} einigen, der dann in\nden Wettkampf geschickt und dann eventuell noch gemeinsam\nweiterentwickelt wird. In begründeten Einzelfällen kann die\nWettkampfleitung Ausnahmen von den zuvor genannten Regeln zulassen.\n\nZurzeit nehmen pro Schuljahr etwa 100 Teams bundesweit an der\nSoftware-Challenge teil. Es werden dabei neben zahlreichen Sachpreisen\nauch etwa 100 Stipendien (6 Monate je 300 Euro) an die besten 100\nSchülerinnen und Schüler vergeben.\n\nDas Anmeldeverfahren sieht etwa wie folgt aus. Genaue Termine des\naktuellen Zeitraumes finden sich auf der [Website unter\nAblauf und Termine](https://software-challenge.de/ablauf-und-termine).\n\nAb April können interessierte Lehrkräfte, Schülerinnen und Schüler \nihre Schulen und Teams für die Teilnahme an der Software-Challenge \nunverbindlich anmelden. Diese Interessenten werden dann über \nwichtige Termine und andere relevanten Dinge informiert.\n\nGegen Ende der Anmeldungsphase werden wir dann mit den registrierten\nInteressenten in Verbindung treten. Dann soll eine (relativ)\nverbindliche Anmeldung erfolgen, sodass wir darauf aufbauend unsere\nRessourcen planen können.\n\nDie endgültige Anmeldung soll dann zu Beginn des Schuljahres erfolgen.\n\nUm eine gute Planung und damit einen erfolgreichen Ablauf zu\nermöglichen, sind wir darauf angewiesen, dass die interessierten\nSchulleiterinnen, Schulleiter, Lehrkräfte, Schülerinnen und Schüler ihre Schulen und Teams\nmöglichst frühzeitig registrieren und erforderlichenfalls ihre Daten\naktualisieren.\n\n## Die Aufgabe\n\nDie Software-Challenge basiert jedes Jahr auf einem Brettspiel, für das\nein :t[Computerspieler]{#player} geschrieben werden soll und das entweder selbst\nentwickelt oder auf Basis eines existierenden Brettspiels modifiziert\nwird. Im letzteren Fall werden wir durch die Spiel-Verlage unterstützt,\nindem diese uns die Genehmigung erteilen und Grafiken zur Verfügung\nstellen. Bei der Entwicklung bzw. Modifizierung der Spiele versuchen wir\nzu erreichen, dass die Spiele interessant, abwechslungsreich und nicht\nzu kompliziert sind und dass die Glückskomponente nicht dominiert. Ein\nsehr guter :t[Computerspieler]{#player} soll sich also langfristig gegen schwächere\ndurchsetzen, wobei es durchaus vorkommen darf, dass er bei viel Pech\nauch mal verliert.\n","data":{"name":"Die Software-Challenge","index":3,"expanded":true},"elements":["t"]}},{"folder":"book","path":{"directory":"entwicklung","absolute":"/home/runner/work/docs/docs/hyperbook/.hyperbook/book/entwicklung/abgabe.md","relative":"entwicklung/abgabe.md","href":"/entwicklung/abgabe"},"extension":".md","name":"abgabe","root":"/home/runner/work/docs/docs/hyperbook/.hyperbook","markdown":{"content":"\n# Computerspieler abgabefertig machen\n\nDamit das :t[Wettkampfsystem]{#contest} mit dem :t[Computerspieler]{#player} arbeiten kann,\nmuss er als ausführbares Programm in ein ZIP-Archiv verpackt werden.\n\nJe nach Programmiersprache, in der der Spieler entwickelt wurde,\nsind unterschiedliche Schritte notwendig.\n\n:::alert{info}\nIn der Regel enthält die Spielervorlage alle nötigen Instruktionen zum Packen.\n:::\n\n### Offizielle Spielervorlagen\n- [Java](https://github.com/software-challenge/backend/blob/main/player/configuration/README.md)\n- [Ruby](https://github.com/software-challenge/client-ruby/blob/main/README.md)\n\n### Inoffizielle Spielervorlagen\n- [C#](https://github.com/jnccd/socha-client-csharp/blob/master/README.md)\n- [C++](https://github.com/Estugon/sc-penguins-cpp/blob/main/README.md)\n- [Python](https://github.com/FalconsSky/socha-python-client/blob/master/README.md)\n- [Rust](https://github.com/fwcd/socha-client-rust-2023/blob/main/README.md)\n- [Swift](https://github.com/matthesjh/sc23-swift-client/blob/main/README.md)\n\nDas Hochladen des Spielers im Wettkampfsystem wird detailliert \nunter :t[Wettkampfsystem->Computerspieler]{#contest.computerspieler} beschrieben.\n\n## Andere Programmiersprache\n\nBei Computerspielern in einer anderen Programmiersprache \nmuss das ZIP-Archiv ein Shell-Script \nmit genauen Instruktionen zum Start des Computerspielers enthalten.\nDieses muss nach dem Hochladen im Wettkampfystem \nals Hauptdatei ausgewählt werden.\n\nBeachten Sie hierbei, dass diesem Script vom Wettkampfsystem Parameter übergeben werden,\ndie an Ihr Programm weitergegeben werden müssen.\nDiese Parameter sind mindestens Host und Port des Spielservers \nsowie die Reservierungsnummer des Spiels, dem der Computerspieler beitreten soll.\nEin Aufruf sieht also in etwa wie folgt aus\n(falls `start.sh` als Hauptdatei eingestellt ist):\n\n    start.sh -h gameserver -p 13050 -r 590e5e6f-cf93-488e-a12d-5c194ecf95c2\n\nDie Parameter folgen dabei den \n[GNU Getopt Konventionen](https://www.gnu.org/software/libc/manual/html_node/Argument-Syntax.html#Argument-Syntax).\nDas heißt, die drei Parameter können in beliebiger Reihenfolge \nund als kurze oder lange Version übergeben werden.\nFolgende Variante muss also auch von Ihrem Programm korrekt verarbeitet werden können:\n\n    start.sh --reservation 590e5e6f-cf93-488e-a12d-5c194ecf95c2 --host gameserver --port 13050\n\nAuch die grafische Oberfläche ruft Ihr Programm mit diesen Parametern auf.\nIhr Programm wird also nur von der grafischen Oberfläche richtig gestartet,\nwenn es die Parameter richtig verarbeitet.\n\nFür die meisten Programmiersprachen gibt es Bibliotheken,\ndie die Kommandozeilenparameter nach diesem Schema verarbeiten können,\nSie müssen diese Funktion also nicht unbedingt selbst implementieren.\n\nWeiterhin ist es wichtig, den Interpreter in der ersten Zeile des Script anzugeben, \nda das Script nicht von einer Shell aufgerufen wird.\nEin `start.sh` Script sieht also in etwa so aus:\n\n    #!/bin/sh\n    chmod +x hauptprogramm_dateiname\n    ./hauptprogramm_dateiname \"$@\"\n\n-   Script soll von `/bin/sh` interpretiert werden, es ist also ein einfaches Shell-Script.\n-   Die Binärdatei wird ausführbar gemacht (das ist nötig, da in einem ZIP-Archiv das Ausführbar-Attribut nicht gespeichert wird).\n-   Die Binärdatei wird aufgerufen und alle Parameter, die das Script bekommen hat, werden weitergereicht (`\"$@\"`).\n\nDie `start.sh` muss in UTF-8 und mit UNIX(LF) Zeilenenden kodiert sein.\nAndere Kodierungen führen zu Fehlern bei der Ausführung auf dem Server.\nIn Notepad++ kann die Kodierung einfach in dem Tab `Kodierung` angepasst werden,\ndie Zeilenenden in `Bearbeiten > Format Zeilenende`.\n\nBei kompilierten Sprachen müssen die :t[Computerspieler]{#player} für 64bit Linux kompiliert werden,\nbei interpretierten Sprachen muss ein passender Interpreter auf dem :t[Wettkampfsystem]{#contest} vorhanden sein.\nWeiterhin müssen Abhängigkeiten wie z.B. genutzte Bibliotheken vorhanden sein\noder mitgeliefert werden.\n\n## Technische Daten für die Ausführung der Computerspieler\n\nBei allen im :t[Wettkampfsystem]{#contest} ausgetragenen Spielen\nlaufen die :t[Computerspieler]{#player} auf den Servern des Wettkampfsystems.\n\n|                  |                                                   |\n|------------------|---------------------------------------------------|\n| Betriebssystem:  | 64 Bit Linux                                      |\n| Prozessor:       | Ein Thread eines [Intel Xeon E5-2620 v4, 2,1 GHz](https://ark.intel.com/de/products/92986/Intel-Xeon-Processor-E5-2620-v4-20M-Cache-2_10-GHz) |\n| Arbeitsspeicher: | 1,5 GB                                            |\n\n### Die Begegnungen\n\nJede Begegnung besteht aus jeweils sechs Spielen,\nwobei das Recht des ersten Zuges abwechselt.\n\nDie Zugzeit ist für jeden Zug auf zwei Sekunden begrenzt.\nDabei gilt für die Rechenzeit die im Institut verwendete Hardware als Referenz.\nJeder :t[Computerspieler]{#player} wird dabei auf einer eigenen virtuellen Maschine\nmit unten stehenden Spezifikationen ausgeführt.\n\nSollte ein Spieler einen ungültigen Zug setzen oder die maximale Zugzeit überschreiten,\nso hat dieser Spieler verloren.\nIn allen anderen Fällen wird das Spiel gemäß der Spielregeln zu Ende gespielt\nund der Gewinner ermittelt.\n\n### Log-Ausgabe\n\nDie :t[Computerspieler]{#player} laufen im :t[Wettkampfsystem]{#contest} ohne eine grafische Oberfläche,\nsie können also keine Fenster oder ähnliches anzeigen.\nDer Versuch eines Computerspielers, so etwas trotzdem zu tun,\nwird wahrscheinlich zum Absturz des Computerspielers führen.\n\nDie :t[Computerspieler]{#player} können jedoch Text auf die beiden\nStandard-Ausgabedatenströme \"stdout\" und \"stderr\" schreiben.\nDiese Ausgaben finden sich dann in den Log-Dateien wieder,\ndie nach Beenden eines Spiels über das :t[Wettkampfsystem]{#contest} verfügbar sind.\n\n### Lesen von Daten\n\nZugriff auf das Internet ist nicht möglich.\nSchreiben auf die Festplatte ist möglich,\nes kann jedoch nicht auf Daten, die in früheren Spielen geschrieben wurden,\nzugegriffen werden.\n\n### Ausführungsumgebung\n\nDer :t[Computerspieler]{#player} wird in einem Docker container ausgeführt,\nwelcher die verfügbaren Bibliotheken und Programme bestimmt.\nDie verfügbaren Container-Vorlagen sind im Wettkampfsystem einsehbar,\nund bieten unter anderem Java, Python, Ruby, Node.js, Swift, .NET, C++ Boost, Tensorflow\noft in mehreren Versionen.\n\n| Bezeichnung        | Image-Name                                                                                   | Beschreibung                                                                                                               |\n| ------------------ | -------------------------------------------------------------------------------------------- | -------------------------------------------------------------------------------------------------------------------------- |\n| Java 17            | [openjdk:17](https://hub.docker.com/_/openjdk/)                                              | Open Source Java Platform, Standard Edition, Version 17 (bzw. 1.17). Für alle :t[Computerspieler]{#player} auf Basis des Java Zufallsspielers.     |\n| Java 8             | [openjdk:8u151-jre](https://hub.docker.com/_/openjdk/)                                       | Open Source Java Platform, Standard Edition, Version 1.8.        |\n| Java 18            | [openjdk:18](https://hub.docker.com/_/openjdk/)                                              | Open Source Java Platform, Standard Edition, Version 18 (bzw. 1.18)     |\n| Ruby 2             | [ruby:2.7.5](https://hub.docker.com/_/ruby/) | Ruby Interpreter, Version 2.7.5 mit installiertem Software-Challenge-Gem. Für alle :t[Computerspieler]{#player} auf Basis des Ruby Zufallsspielers.                                |\n| Python 3           | [python:3.10.1](https://hub.docker.com/_/python/)                                             | Python Interpreter, Version 3.10.1. Für selbst entwickelte :t[Computerspieler]{#player} in Python.                                       |\n| .NET Runtime | [\tmcr.microsoft.com/dotnet/runtime:6.0](https://hub.docker.com/_/microsoft-dotnet-runtime/)                                               | Offizielle Microsoft .NET Laufzeitumgebung, Version 6.0. Für selbst entwickelte :t[Computerspieler]{#player} basierend auf dem Microsoft .NET Framework. |\n| Mono 5.4 (C# .NET) | [mono:6.12.0](https://hub.docker.com/_/mono/)                                               | Mono Laufzeitumgebung, Version 6.12.0. Für selbst entwickelte :t[Computerspieler]{#player} basierend auf dem Microsoft .NET Framework. |\n| Swift 5.5.1 | [swift:5.5.1](https://hub.docker.com/_/swift/)                                               | Swift (core libraries), Version 5.1.3. Für selbst entwickelte :t[Computerspieler]{#player} in der Programmiersprache Swift. |\n| Node.js 17.2.0 | [node:17.2.0](https://hub.docker.com/_/node/)                                               | Node.js, Version 17.2.0. Für selbst entwickelte :t[Computerspieler]{#player} in der Programmiersprache Javascript. |\n| C++ Boost Library | cpp-boost basierend auf [ubuntu:20.04](https://hub.docker.com/_/ubuntu/)                                               | Container mit vorinstallierten C++ Boost Bibliotheken (libboost-program-options1.71.0, libboost-atomic1.71.0, libboost-system1.71.0) |\n| Deep Learning | [floydhub/dl-docker](https://hub.docker.com/r/floydhub/dl-docker)                                               | Image mit Bibliotheken für diverse deep learning Ansätze (TensorFlow, Caffe, Theano, Keras, Lasagne und Torch). **Bitte das Wettkampfsystem nicht zum trainieren verwenden.** Das Image soll nur verhindern, dass die für den Betrieb des fertig trainierten Clients notwendigen Bibliotheken jedesmal mit hochgeladen werden müssen. |\n| Python Tensorflow | [sc-tensorflow](https://github.com/software-challenge/client-docker-images/blob/master/tensorflow/Dockerfile)                                               | Python 3 mit Tensorflow Bibliotheken. **Bitte das Wettkampfsystem nicht zum trainieren verwenden.** Das Image soll nur verhindern, dass die für den Betrieb des fertig trainierten Clients notwendigen Bibliotheken jedesmal mit hochgeladen werden müssen. |\n| PyPy | [pypy:3.9](https://hub.docker.com/_/pypy)                                               | PyPy is a fast, compliant alternative implementation of the Python language. Version 3.9 |\n\nWenn Ihr :t[Computerspieler]{#player} eine speziellere Umgebung benötigt\n(zum Beispiel ein hier nicht angebotener Interpreter),\nnehmen Sie bitte mit uns Kontakt auf (<tech@software-challenge.de>).\nWir stellen gern weitere Images zur Verfügung.\n","data":{"name":"Computerspieler abgabefertig machen","index":9},"elements":["t","alert"]}},{"folder":"book","path":{"directory":"entwicklung","absolute":"/home/runner/work/docs/docs/hyperbook/.hyperbook/book/entwicklung/kennenlernen.md","relative":"entwicklung/kennenlernen.md","href":"/entwicklung/kennenlernen"},"extension":".md","name":"kennenlernen","root":"/home/runner/work/docs/docs/hyperbook/.hyperbook","markdown":{"content":"\n# Das Spiel kennenlernen\n\nUm ein Computerprogramm zu schreiben, was ein Spiel spielen kann, muss\nman vorher das Spiel selbst verstehen und spielen können.  \nDabei könnt ihr euch bereits Ideen und Strategien entwickeln,\ndie ihr in euren :t[Computerspieler]{#player} nachher umsetzen wollt.\n\nDas Spiel selbst kann zu zweit oder allein gegen den [Zufallsspieler](glossary/client#der-simpleclient)\nmit dem [Spielleiter](glossary/server#der-spielleiter-server) gespielt werden.\nEs empfiehlt sich, dies einige Male zu tun, bevor man mit der Programmierung beginnt.\n","data":{"name":"Das Spiel kennenlernen","index":1},"elements":["t"]}},{"folder":"book","path":{"directory":"entwicklung","absolute":"/home/runner/work/docs/docs/hyperbook/.hyperbook/book/entwicklung/index.md","relative":"entwicklung/index.md","href":"/entwicklung"},"extension":".md","name":"index","root":"/home/runner/work/docs/docs/hyperbook/.hyperbook","markdown":{"content":"\n# Die Ersten (Programmier-)Schritte\n\nBekanntlich ist aller Anfang schwer.\nDeshalb soll hier eine kleine Hilfe gegeben werden,\ndie den Start mit der Entwicklung erleichtern soll.\n\n## Die richtige Programmiersprache\n\nAm einfachsten ist es natürlich,\neine der offiziellen Spielervorlagen (Java, Ruby, Python) als Basis zu nutzen,\nallerdings könnt ihr auch eigene Clients in anderen Sprachen schreiben.\nDas ist mit mehr Arbeit verbunden,\naber wenn ihr eine Sprache besonders gerne nutzt oder Vorteile seht,\ndann kann es sich lohnen!\n\nWenn ihr also genug Erfahrung habt und euch entscheidet den schwereren Weg zu gehen,\ndann solltet ihr euch die [XML-Dokumentation](/xml) genau anschauen,\nda ihr die ganze Kommunikation inklusive Parsen der XML-Nachrichten implementieren müsst.\nAußerdem solltet ihr euch als Beispiel\nden (inoffiziellen) [Swift Computerspieler](https://github.com/matthesjh/sc20-swift-client) ansehen.\nDas kann auch helfen, wenn man Swift nicht kann,\nda die meisten prozeduralen Programmiersprachen viele Ähnlichkeiten haben.\nSomit sollte es nicht allzu schwer sein, den Swift code in eure Sprache zu übersetzen.\nAuf ähnliche Weise können natürlich auch\n[der Java Quellcode](https://github.com/software-challenge/backend/tree/main/player/src)\nund [der C# Quellcode](https://github.com/niklasCarstensen/socha-client-csharp) helfen.\n\nAm besten sprecht ihr die Verwendung einer anderen Programmiersprache frühzeitig mit eurem Tutor ab,\ndamit sichergestellt ist, dass der :t[Computerspieler]{#player} auch am Wettkampf teilnehmen kann.\nWir stellen gerne eine passende Laufzeitumgebung auf dem :t[Wettkampfsystem]{#contest}\nfür die Programmiersprache zur Verfügung.\n\n## Weiterführende Literatur\n\nZu den meisten Programmiersprachen existieren umfassende Dokumentationen.\nEinige Empfehlenswerte werden hier aufgeführt.\nDer geneigte Leser ist eingeladen, in dem entsprechenden Bereich eigene Empfehlungen hinzuzufügen.\n\n### Java\n\nDie umfassende (englischsprachige) offizielle Dokumentation zu Java\nist einsehbar [bei Oracle](https://docs.oracle.com/en/java/javase/11/core/java-core-libraries1.html).\nAls deutschsprachiges Referenzwerk ist das Buch \"Java ist auch eine Insel\" empfehlenswert,\nwelches man bei Galileo Computing als\n[Open-Book](http://openbook.galileocomputing.de/javainsel)\nkostenlos online betrachten und herunterladen kann.\nMan kann es dort ebenfalls als gedruckte Ausgabe bestellen.\n","data":{"name":"Entwicklung eines Computerspielers","index":2},"elements":["t"]}},{"folder":"book","path":{"directory":"spiele/25_hase-und-igel","absolute":"/home/runner/work/docs/docs/hyperbook/.hyperbook/book/spiele/25_hase-und-igel/xml.md","relative":"spiele/25_hase-und-igel/xml.md","href":"/spiele/25_hase-und-igel/xml"},"extension":".md","name":"xml","root":"/home/runner/work/docs/docs/hyperbook/.hyperbook","markdown":{"content":"# Software-Challenge XML-Dokumentation Hase und Igel\n\nZiel dieser Dokumentation ist es,\ndie XML-Schnittstelle der Software-Challenge 2024/25 festzuhalten.\n\n## Spiel betreten\n\nWenn begonnen wird mit dem Server zu kommunizieren, muss zuallererst\n\n    <protocol>\n\ngesendet werden, um die Kommunikation zu beginnen.\n\n### Ohne Reservierungscode\n\nBetritt ein beliebiges offenes Spiel:\n\n    <join gameType=\"swc_2018_hase_und_igel\"/>\n\nSollte kein Spiel offen sein, wird so ein neues erstellt. Je nachdem ob\npaused in server.properties true oder false ist, wird das Spiel pausiert\ngestartet oder nicht. Der Server antwortet darauf mit:\n\n-   ROOM\\_ID Id des GameRooms\n\n<!-- -->\n\n    <joined roomId=\"ROOM_ID\"/>\n\nAlle administrativen Clients werden ebenfalls darüber benachrichtigt und\nerhalten folgende Nachricht:\n\n-   ROOM\\_ID Id des GameRooms\n\n<!-- -->\n\n    <joinedGameRoom roomId=\"ROOM_ID\" existing=\"false\"/>\n\nFalls bereits ein GameRoom offen war, ist dementsprechend existing true.\n\n### Mit Reservierungscode\n\nIst ein Reservierungscode gegeben, so kann man den durch den Code\ngegebenen Platz betreten.\n\n#### Join mit RC\n\n-   RC Reservierungscode\n\n<!-- -->\n\n    <joinPrepared reservationCode=\"RC\"/>\n\n#### Welcome Message\n\nDer Server antwortet darauf nur, wenn der zweite :t[Computerspieler]{#player} ebenfalls\nverbunden ist:\n\n-   ROOM\\_ID Id des GameRooms\n\n-   COLOR Spielerfarbe also red oder blue\n\n-   status GameState wie in [Status](#status)\n\n<!-- -->\n\n    <joined roomId=\"ROOM_ID\"/>\n    <room roomId=\"ROOM_ID\">\n      <data class=\"welcomeMessage\" color=\"COLOR\"></data>\n    </room>\n    <room roomId=\"ROOM_ID\">\n      <data class=\"memento\">\n        status\n      </data>\n    </room>\n\n## Züge senden\n\n### Der Move\n\nDer Move ist die Antwort auf den MoveRequest des Servers.\n\n#### MoveRequest\n\n-   ROOM\\_ID Id des GameRooms\n\n<!-- -->\n\n    <room roomId=\"ROOM_ID\">\n      <data class=\"sc.framework.plugins.protocol.MoveRequest\"/>\n    </room>\n\n#### Senden\n\nDer Move ist der allgemeine Zug, der in verschiedenen Varianten gesendet\nwerden kann.\n\n-   ROOM\\_ID Id des GameRooms\n\n-   ZUG Zug wie in [ZUG](#zug)\n\n<!-- -->\n\n    <room roomId=\"ROOM_ID\">\n      ZUG\n    </room>\n\n### ZUG\n\n-   ACTION Aktionen wie in [ACTION](#action)\n\n<!-- -->\n\n    <data class=\"move\">\n      ACTION\n      ..\n      ACTION\n    </move>\n\n### ACTION\n\nMögliche Aktionen:\n\n-   I Index der Aktion beginnend mit 0\n\n-   D Anzahl der Felder um die sich bewegt wird\n\n-   W -10 oder 10\n\n-   V 20,0,-20 falls type TAKE\\_OR\\_DROP\\_CARROTS, 0 sonst\n\n<!-- -->\n\n    <advance order=\"I\" distance=\"D\"/>\n    <card order=\"I\" type=\"CARD_TYPE\" value=\"V\"/>\n    <exchangeCarrots order=\"I\" value=\"W\"/>\n    <eatSalad order=\"I\"/>\n    <fallBack order=\"I\"/>\n    <skip order=\"I\"/>\n\n### Debughints\n\nZügen können Debug-Informationen beigefügt werden:\n\n    <hint content=\"S\"/>\n\nDamit sieht beispielsweise ein Laufzug so aus:\n\n    <room roomId=\"ROOM_ID\">\n      <data class=\"move\">\n        <advance order=\"0\" distance=\"1\"/>\n        <card order=\"1\" type=\"EAT_SALAD\" value=\"0\"/>\n        <hint content=\"Dies ist ein Hint.\"/>\n        <hint content=\"noch ein Hint\"/>\n      </data>\n    </room>\n\n## Spielstatus\n\nEs folgt die Beschreibung des Spielstatus, der vor jeder Zugaufforderung\nan die Clients gesendet wird. Das Spielstatus-Tag ist dabei noch in\neinem *data*-Tag der Klasse *memento* gewrappt:\n\n### memento\n\n-   ROOM\\_ID Id des GameRooms\n\n-   status Gamestate wie in [Status](#status)\n\n<!-- -->\n\n    <room roomId=\"ROOM_ID\">\n      <data class=\"memento\">\n        status\n      </data>\n    </room>\n\n### Status\n\n-   Z aktuelle Zugzahl\n\n-   S Spieler, der das Spiel gestartet hat (RED/BLUE)\n\n-   C Spieler, der an der Reihe ist (RED/BLUE)\n\n-   red, blue wie in [Spieler](#spieler) definiert\n\n-   board Das Spielbrett, wie in [Spielbrett](#spielbrett) definiert\n\n-   lastMove Letzter getätigter Zug (nicht in der ersten Runde), wie in\n    [Letzter Zug](#letzter-zug) definiert\n\n-   condition Spielergebnis, wie in [Spielergebnis](#spielende)\n    definiert; nur zum Spielende\n\n<!-- -->\n\n    <state class=\"state\" turn=\"Z\" startPlayer=\"S\" currentPlayer=\"C\">\n      red\n      blue\n      [board]\n      [lastMove]\n      [condition]\n    </state>\n\n### Spieler\n\n-   C Farbe (red/blue)\n\n-   N Anzeigename\n\n-   I Feldindex des Spielers\n\n-   S Anzahl Salate\n\n-   K Anzahl der Karotten\n\n<!-- -->\n\n    <C displayName=\"N\" color=\"C\" index=\"I\" carrots=\"K\" salads=\"S\">\n      <cards>\n        <type>TAKE_OR_DROP_CARROTS</type>\n        <type>EAT_SALAD</type>\n        <type>HURRY_AHEAD</type>\n        <type>FALL_BACK</type>\n      </cards>\n      <lastNonSkipAction class=\"fallBack\" order=\"0\"/> // Beispiel für letzte Aktion\n    </C>\n\n### Spielbrett\n\n-   FIELD Ein Spielfeld wie in [Spielfeld](#spielfeld) definiert.\n\n<!-- -->\n\n    <board>\n      <fields index=\"0\" type=\"START\"/>\n      ..\n      FIELD\n      ..\n      <fields index=\"64\" type=\"GOAL\"/>\n    </board>\n\n### Spielfeld\n\n-   I Feldnummer\n\n-   TYPE Typ des Feldes\n    (START/CARROT/HARE/GOAL/POSITION\\_{X}/HEDGEHOG/SALAD). X ist 1 oder\n    2\n\n<!-- -->\n\n    <fields index=\"I\" type=\"TYPE\"/>\n\n### Letzter Zug\n\nDer letzte Zug ist ein Move (siehe hierzu [ZUG](#zug)).\n\n-   ACTIONS Teilzüge des Zuges (siehe hierzu [ACTION](#action)).\n\n<!-- -->\n\n    <lastMove>\n      ACTIONS\n    </lastMove>\n\n## Zug-Anforderung\n\nEine einfache Nachricht fordert zum Zug auf:\n\n    <room roomId=\"RID\">\n      <data class=\"sc.framework.plugins.protocol.MoveRequest\"/>\n    </room>\n\n## Fehler\n\nEin “spielfähiger” :t[Computerspieler]{#player} muss nicht mit Fehlern umgehen können.\nFehlerhafte Züge beispielsweise resultieren in einem vorzeitigen Ende\ndes Spieles, das im nächsten gesendeten Gamestate erkannt werden kann\n(siehe [Spielergebnis](#spielende)).\n\n-   MSG Fehlermeldung\n\n<!-- -->\n\n    <room roomId=\"RID\">\n      <error message=\"MSG\">\n        <originalRequest>\n        Request, der den Fehler verursacht hat\n        </originalRequest>\n      </error>\n    </room>\n\n## Spiel verlassen\n\nWenn ein :t[Computerspieler]{#player} den Raum verlässt, bekommen die anderen Clients eine\nentsprechende Meldung vom Server.\n\n-   ROOM\\_ID Id des GameRooms\n\n<!-- -->\n\n    <left roomId=\"ROOM_ID\"/>\n\n## Spielergebnis\n\nZum Spielende enthält der Spieler das Ergebnis:\n\n-   ROOM\\_ID Id des GameRooms\n\n-   R1, R2 Text, der den Grund für das Spielende erklärt\n\n-   CAUSE1, CAUSE2 Grund des Spielendes\n    (REGULAR/LEFT/RULE\\_VIOLATION/SOFT\\_TIMEOUT/HARD\\_TIMEOUT)\n\n-   WP1, WP2 Siegpunkte der jeweiligen Spieler, 0 verloren, 1\n    unentschieden, 2 gewonnen\n\n-   I1, I2 Index des Feldes auf dem der Spieler steht\n\n-   C1, C2 Karotten des Spielers\n\n-   NAME Anzeigename des Spielers\n\n-   COLOR Farbe des Siegers\n\n-   I3 I1 oder I2 je nachdem wer gewonnen hat\n\n-   C3 C1 oder C2 je nachdem wer gewonnen hat\n\n-   S Salate des Siegers\n\n-   \\[cards\\] Karten des Siegers wie in [Spieler](#spieler)\n\n-   \\[lastNonSkipAction\\] Letztes Aktion des Siegers wie in\n    [Spieler](#spieler)\n\n<!-- -->\n\n    <room roomId=\"ROOM_ID\">\n      <data class=\"result\">\n        <definition>\n          <fragment name=\"Gewinner\">\n            <aggregation>SUM</aggregation>\n            <relevantForRanking>true</relevantForRanking>\n          </fragment>\n          <fragment name=\"Ø Feldnummer\">\n            <aggregation>AVERAGE</aggregation>\n            <relevantForRanking>true</relevantForRanking>\n          </fragment>\n          <fragment name=\"Ø Karotten\">\n            <aggregation>AVERAGE</aggregation>\n            <relevantForRanking>true</relevantForRanking>\n          </fragment>\n        </definition>\n        <score cause=\"CAUSE1\" reason=\"R1\">\n          <part>WP1</part>\n          <part>I1</part>\n          <part>C1</part>\n        </score>\n        <score cause=\"CAUSE2\" reason=\"R2\">\n          <part>WP2</part>\n          <part>I2</part>\n          <part>C1</part>\n        </score>\n        <winner class=\"player\" displayName=\"NAME\" color=\"COLOR\" index=\"I3\" carrots=\"C3\" salads=\"S\">\n          [cards]\n          [lastNonSkipAction]\n        </winner>\n      </data>\n    </room>\n\n## Spielverlauf\n\nDer Server startet (StandardIp: localhost 13050).\n\nNun gibt es zwei Varianten ein Spiel zu starten, eine durch einen\nAdministratorclient die andere durch hinzufügen der Spieler zu einen\nSpieltyp:\n\n### Variante 1 (AdminClient [Mit Reservierungscode](#mit-reservierungscode))\n\nEin :t[Computerspieler]{#player} registriert sich als Administrator mit dem in\nserver.properties festgelegten Passwort p:\n\n    <protocol><authenticate passphrase=\"p\"/>\n\nDann kann ein Spiel angelegt werden:\n\n    <prepare gameType=\"swc_2018_hase_und_igel\">\n      <slot displayName=\"p1\" canTimeout=\"false\" shouldBePaused=\"true\"/>\n      <slot displayName=\"p2\" canTimeout=\"false\" shouldBePaused=\"true\"/>\n    </prepare>\n\nDer Server antwortet darauf mit einer Nachricht, die die ROOM\\_ID und\nReservierungscodes für die beiden Clients enthält:\n\n    <protocol>\n      <prepared roomId=\"871faccb-5190-4e44-82fc-6cdcbb493726\">\n        <reservation>RC1</reservation>\n        <reservation>RC2</reservation>\n      </prepared>\n\nDer Administratorclient kann nur ebenfalls als Observer des Spiels\ngenutzt werden, indem ein entsprechender Request gesendet wird. Dadurch\nwird das derzeitge Spielfeld ([memento](#memento)) ebenfalls an den\nAdministratorclient gesendet.\n\n    <observe roomId=\"871faccb-5190-4e44-82fc-6cdcbb493726\"/>\n\nClients die auf dem Serverport (localhost 13050) gestartet werden können\nso über diesen Code joinen.\n\n    <protocol>\n      <joinPrepared reservationCode=\"RC1\"/>\n\n    <protocol>\n      <joinPrepared reservationCode=\"RC2\"/>\n\n### Variante 2 ((eventuell) ohne AdminClient [Ohne Reservierungscode](#ohne-reservierungscode))\n\nDie Clients wurden auf dem Serverport (Standard: localhost 13050)\ngestartet.\n\nSie können sich mit folgender Anfrage einen bereits offenen Spiel\ngleichen Typs beitreten oder, falls kein Spiel des Typs vorhanden selbst\neines starten:\n\n    <protocol>\n      <join gameType=\"swc_2018_hase_und_igel\"/>\n\nDer Server antwortet mit:\n\n    <protocol>\n      <joined roomId=\"871faccb-5190-4e44-82fc-6cdcbb493726\"/>\n\n### Weiterer Spielverlauf\n\nDer Server antwortet jeweils mit der WelcomeMessage ([Welcome\nMessage](#welcome-message)) und dem ersten GameState\n([memento](#memento)) sobald beide Spieler verbunden sind.\n\n    <room roomId=\"871faccb-5190-4e44-82fc-6cdcbb493726\">\n      <data class=\"welcomeMessage\" color=\"red\"/>\n    </room>\n    <room roomId=\"871faccb-5190-4e44-82fc-6cdcbb493726\">\n      <data class=\"memento\">\n        <state class=\"state\" turn=\"0\" startPlayer=\"RED\" currentPlayer=\"RED\">\n          <red displayName=\"Unknown\" color=\"RED\" index=\"0\" carrots=\"68\" salads=\"5\">\n            <cards>\n              <type>TAKE_OR_DROP_CARROTS</type>\n              <type>EAT_SALAD</type>\n              <type>HURRY_AHEAD</type>\n              <type>FALL_BACK</type>\n            </cards>\n          </red>\n          <blue displayName=\"Unknown\" color=\"BLUE\" index=\"0\" carrots=\"68\" salads=\"5\">\n            <cards>\n              <type>TAKE_OR_DROP_CARROTS</type>\n              <type>EAT_SALAD</type>\n              <type>HURRY_AHEAD</type>\n              <type>FALL_BACK</type>\n            </cards>\n          </blue>\n          <board>\n            <fields index=\"0\" type=\"START\"/>\n            <fields index=\"1\" type=\"CARROT\"/>\n            <fields index=\"2\" type=\"HARE\"/>\n            <fields index=\"3\" type=\"HARE\"/>\n            <fields index=\"4\" type=\"POSITION_2\"/>\n            <fields index=\"5\" type=\"POSITION_1\"/>\n            <fields index=\"6\" type=\"CARROT\"/>\n            <fields index=\"7\" type=\"CARROT\"/>\n            <fields index=\"8\" type=\"HARE\"/>\n            <fields index=\"9\" type=\"CARROT\"/>\n            <fields index=\"10\" type=\"SALAD\"/>\n            <fields index=\"11\" type=\"HEDGEHOG\"/>\n            <fields index=\"12\" type=\"HARE\"/>\n            <fields index=\"13\" type=\"CARROT\"/>\n            <fields index=\"14\" type=\"CARROT\"/>\n            <fields index=\"15\" type=\"HEDGEHOG\"/>\n            <fields index=\"16\" type=\"POSITION_1\"/>\n            <fields index=\"17\" type=\"CARROT\"/>\n            <fields index=\"18\" type=\"POSITION_2\"/>\n            <fields index=\"19\" type=\"HEDGEHOG\"/>\n            <fields index=\"20\" type=\"CARROT\"/>\n            ...\n            <fields index=\"57\" type=\"SALAD\"/>\n            <fields index=\"58\" type=\"CARROT\"/>\n            <fields index=\"59\" type=\"POSITION_1\"/>\n            <fields index=\"60\" type=\"HARE\"/>\n            <fields index=\"61\" type=\"CARROT\"/>\n            <fields index=\"62\" type=\"HARE\"/>\n            <fields index=\"63\" type=\"CARROT\"/>\n            <fields index=\"64\" type=\"GOAL\"/>\n          </board>\n        </state>\n      </data>\n    </room>\n\nDer erste Spieler erhält dann eine Zugaufforderung\n([MoveRequest](#move-request)), falls in server.properties paused auf\nfalse gesetzt wurde. Falls das Spiel pausiert ist, muss das Spiel durch\neinen Administratorclient gestartet werden:\n\nVerbinden des Administratorclients (falls es sich um die erste\nKontaktaufnahme zum Server handelt, ansonsten &lt;protocol&gt;\nweglassen).\n\n    <protocol>\n      <authenticate passphrase=\"examplepassword\"/>\n\nPausierung aufheben:\n\n    <pause roomId=\"871faccb-5190-4e44-82fc-6cdcbb493726\" pause=\"false\" />\n\nDaraufhin wird der erste Spieler aufgefordert einen Zug zu senden:\n\n    <room roomId=\"871faccb-5190-4e44-82fc-6cdcbb493726\">\n      <data class=\"sc.framework.plugins.protocol.MoveRequest\"/>\n    </room>\n\nDer :t[Computerspieler]{#player} des CurrentPlayer sendet nun einen Zug ([ZUG](#zug)):\n\n    <room roomId=\"871faccb-5190-4e44-82fc-6cdcbb493726\">\n      <data class=\"move\">\n        <advance order=\"0\" distance=\"6\">\n      </data>\n    </room>\n\nSo geht es abwechselnd weiter, bis zum Spielende\n([Spielergebnis](#spielende)). Die letzte Nachricht des Servers endet\nmit:\n\n    </protocol>\n\nDanach wird die Verbindung geschlossen.\n\n","data":{},"elements":["t"]}},{"folder":"book","path":{"directory":"spiele/blokus/spielregeln","absolute":"/home/runner/work/docs/docs/hyperbook/.hyperbook/book/spiele/blokus/spielregeln/content.md","relative":"spiele/blokus/spielregeln/content.md","href":"/spiele/blokus/spielregeln/content"},"extension":".md","name":"content","root":"/home/runner/work/docs/docs/hyperbook/.hyperbook","markdown":{"content":"# Spielmaterial\n\nJeder Spieler verfügt über zwei Sätze von 21 Spielsteinen (Polyominos),\ndie sich aus kleinen Quadraten zusammensetzen. Der eine Spieler hat\nblaue und rote Steine, der andere gelbe und grüne. Dabei kommt jede\nForm, die aus 1–5 Quadraten besteht, in jeder Farbe genau einmal vor:\nalso 1 Monomino, 1 Domino, 2 Triominos, 5 Tetrominos und 12 Pentominos.\n\n![Anleitung Steinuebersicht](Anleitung_Steinuebersicht.png)\n\nDas Brett besteht aus 20 × 20 quadratischen Feldern, welche dieselbe\nGröße wie die Quadrate der Spielsteine haben.\n\nDie Koordinaten der Felder des Bretts beginnen in der linken oberen Ecke\nbei x=0, y=0 und folgen den Regeln des kartesischen Koordinatensystems,\nwobei die positive x-Achse nach rechts und die positive y-Achse nach\nunten verläuft.\n\n![anleitung beispielfeld](anleitung_beispielfeld.png)\n\n# Spielablauf\n\nDie Spielsteine werden abwechselnd gelegt, wobei in den Ecken begonnen\nwird. Die Reihenfolge ist: Blau – Gelb – Rot – Grün. Der erste Stein des\nzweiten Spielers darf auch diagonal gegenüber dem ersten Stein des\nersten Spielers gelegt werden.\n\nFür den ersten Stein jeder Farbe gelten besondere Regeln: Er muss so\ngesetzt werden, dass ein Eckfeld des Spielbretts (also (0,0), (19,0),\n(0,19) oder (19,19)) besetzt wird. Die Form des ersten Steins wird vom\nServer vorgegeben. Sie wird zufällig aus allen verfügbaren Formen\nausgewählt, die aus 5 Quadraten bestehen. In einem Spiel ist die Form\ndes ersten Steins für alle Farben gleich.\n\nFür die Platzierung aller weiteren Steine gilt: Zwei Steine derselben\nFarbe dürfen sich nur an den Ecken berühren. Wird ein neuer Stein\ngelegt, muss dieser mindestens einen Stein derselben Farbe an mindestens\neiner Ecke berühren. Dabei ist es egal, wie Steine anderer Farben\nberührt werden, solange diese nicht überdeckt werden.\n\nBeispielbilder mit gültigen und ungültigen Berührungen\n\n![anleitung beruehrungen](anleitung_beruehrungen.png)\n\nDie Steine dürfen umgedreht werden (die Oberseite nach unten) und sind\nfrei rotierbar (in 90° Schritten). Die Steine müssen vollständig auf dem\nFeld liegen und dürfen sich nicht mit anderen Steinen überlappen.\nGelegte Steine dürfen nicht mehr bewegt werden.\n\nZiel ist es, möglichst viele Felder auf dem Brett mit den eigenen Farben\nzu belegen.\n\nEs wird so lange gezogen, bis keine Steine mehr gesetzt werden können.\nWenn Steine einer Farbe nicht mehr gelegt werden können, wird diese\nFarbe im weiteren Verlauf des Spiels übersprungen (die gelegten Steine\nzählen aber mit in die Wertung). Kann kein Stein irgendeiner Farbe mehr\ngelegt werden, endet das Spiel.\n\nDer :t[Computerspieler]{#player} hat für das Legen eines Spielsteines zwei Sekunden\nZeit.\n\nDer :t[Spielleiter]{#server} ruft den :t[Computerspieler]{#player} nur dann zu einem Zug einer\nFarbe auf, wenn es auch noch mindestens einen möglichen Zug gibt. Der\n:t[Computerspieler]{#player} hat dann jedoch auch die Möglichkeit, mit einem\n\"Passen\"-Zug zu antworten. Dadurch wird die aktuelle Farbe in der\naktuellen Runde ausgelassen. \"Passen\" ist erst nach dem ersten Zug\nerlaubt.\n\nEine Runde besteht aus vier Zügen. Pro Zug kann eine Farbe einen Stein\nsetzen oder passen. Auch wenn eine Farbe übersprungen wird, zählt dies\nhierbei als Zug. Das Spiel endet, sobald alle Steine einer Farbe auf das\nSpielfeld gelegt wurden, spätestens aber nach 25 Runden. In jedem Fall\nwird die aktuelle Runde noch zu Ende gespielt.\n\n# Wertung\n\nJeder gelegte Stein zählt so viele Punkte, wie er Quadrate hat (ein\ngelegtes Pentomino zählt z.B. fünf Punkte). Wurden alle Steine einer\nFarbe gelegt, gibt es 15 zusätzliche Punkte. Wurden alle Steine einer\nFarbe gelegt und war zusätzlich der letzte gelegte Stein der Monomino,\ngibt es nochmal fünf zusätzliche Punkte (insgesamt also 20). Die Punkte\nder jeweiligen zwei Farben, die ein Spieler kontrolliert, werden\nzusammengezählt und sind die Gesamtpunkte des Spielers. Der Spieler mit\nden meisten Punkten gewinnt das Spiel.\n\nIn der Meisterschaftsphase ist die durchschnittliche Punktzahl\nnachrangiges Kriterium. D.h. haben zwei Teams gleich viele Siege,\nbekommt das Team mit der höheren durchschnittlichen Punktzahl den\nbesseren Tabellenplatz.\n","data":{},"elements":["t"]}},{"folder":"book","path":{"directory":"spiele/blokus/spielregeln","absolute":"/home/runner/work/docs/docs/hyperbook/.hyperbook/book/spiele/blokus/spielregeln/regeln.md","relative":"spiele/blokus/spielregeln/regeln.md","href":"/spiele/blokus/spielregeln/regeln"},"extension":".md","name":"regeln","root":"/home/runner/work/docs/docs/hyperbook/.hyperbook","markdown":{"content":"[PDF-Version dieses Dokumentes](regeln.pdf)\n\nWir freuen uns über sämtliche Verbesserungsvorschläge.  \nDie Dokumentation kann [direkt auf\nGitHub](https://github.com/software-challenge/docs) editiert werden,\neinzige Voraussetzung ist eine kostenlose Registrierung bei GitHub. Ist\nman angemeldet, kann man ein Dokument auswählen (ein guter Startpunkt\nist die Datei\n[index.md](https://github.com/software-challenge/docs/blob/main/index.md)\nwelche Verweise auf alle Sektionen der Dokumentation enthält) und dann\nauf den Stift oben rechts klicken. Damit wird von GitHub automatisch ein\nFork und ein Pull Request erstellt.  \nAlternativ auch gern eine E-Mail an <info@software-challenge.de> oder\neine Nachricht im [Discord](https://discord.gg/jhyF7EU).\n\n# Spielmaterial\n\nJeder Spieler verfügt über zwei Sätze von 21 Spielsteinen (Polyominos),\ndie sich aus kleinen Quadraten zusammensetzen. Der eine Spieler hat\nblaue und rote Steine, der andere gelbe und grüne. Dabei kommt jede\nForm, die aus 1–5 Quadraten besteht, in jeder Farbe genau einmal vor:\nalso 1 Monomino, 1 Domino, 2 Triominos, 5 Tetrominos und 12 Pentominos.\n\n![Anleitung Steinuebersicht](./images/Anleitung_Steinuebersicht.png)\n\nDas Brett besteht aus 20 × 20 quadratischen Feldern, welche dieselbe\nGröße wie die Quadrate der Spielsteine haben.\n\nDie Koordinaten der Felder des Bretts beginnen in der linken oberen Ecke\nbei x=0, y=0 und folgen den Regeln des kartesischen Koordinatensystems,\nwobei die positive x-Achse nach rechts und die positive y-Achse nach\nunten verläuft.\n\n![anleitung beispielfeld](./images/anleitung_beispielfeld.png)\n\n# Spielablauf\n\nDie Spielsteine werden abwechselnd gelegt, wobei in den Ecken begonnen\nwird. Die Reihenfolge ist: Blau – Gelb – Rot – Grün. Der erste Stein des\nzweiten Spielers darf auch diagonal gegenüber dem ersten Stein des\nersten Spielers gelegt werden.\n\nFür den ersten Stein jeder Farbe gelten besondere Regeln: Er muss so\ngesetzt werden, dass ein Eckfeld des Spielbretts (also (0,0), (19,0),\n(0,19) oder (19,19)) besetzt wird. Die Form des ersten Steins wird vom\nServer vorgegeben. Sie wird zufällig aus allen verfügbaren Formen\nausgewählt, die aus 5 Quadraten bestehen. In einem Spiel ist die Form\ndes ersten Steins für alle Farben gleich.\n\nFür die Platzierung aller weiteren Steine gilt: Zwei Steine derselben\nFarbe dürfen sich nur an den Ecken berühren. Wird ein neuer Stein\ngelegt, muss dieser mindestens einen Stein derselben Farbe an mindestens\neiner Ecke berühren. Dabei ist es egal, wie Steine anderer Farben\nberührt werden, solange diese nicht überdeckt werden.\n\nBeispielbilder mit gültigen und ungültigen Berührungen\n\n![anleitung beruehrungen](./images/anleitung_beruehrungen.png)\n\nDie Steine dürfen umgedreht werden (die Oberseite nach unten) und sind\nfrei rotierbar (in 90° Schritten). Die Steine müssen vollständig auf dem\nFeld liegen und dürfen sich nicht mit anderen Steinen überlappen.\nGelegte Steine dürfen nicht mehr bewegt werden.\n\nZiel ist es, möglichst viele Felder auf dem Brett mit den eigenen Farben\nzu belegen.\n\nEs wird so lange gezogen, bis keine Steine mehr gesetzt werden können.\nWenn Steine einer Farbe nicht mehr gelegt werden können, wird diese\nFarbe im weiteren Verlauf des Spiels übersprungen (die gelegten Steine\nzählen aber mit in die Wertung). Kann kein Stein irgendeiner Farbe mehr\ngelegt werden, endet das Spiel.\n\nDer :t[Computerspieler]{#player} hat für das Legen eines Spielsteines zwei Sekunden\nZeit.\n\nDer :t[Spielleiter]{#server} ruft den :t[Computerspieler]{#player} nur dann zu einem Zug einer\nFarbe auf, wenn es auch noch mindestens einen möglichen Zug gibt. Der\n:t[Computerspieler]{#player} hat dann jedoch auch die Möglichkeit, mit einem\n\"Passen\"-Zug zu antworten. Dadurch wird die aktuelle Farbe in der\naktuellen Runde ausgelassen. \"Passen\" ist erst nach dem ersten Zug\nerlaubt.\n\nEine Runde besteht aus vier Zügen. Pro Zug kann eine Farbe einen Stein\nsetzen oder passen. Auch wenn eine Farbe übersprungen wird, zählt dies\nhierbei als Zug. Das Spiel endet, sobald alle Steine einer Farbe auf das\nSpielfeld gelegt wurden, spätestens aber nach 25 Runden. In jedem Fall\nwird die aktuelle Runde noch zu Ende gespielt.\n\n# Wertung\n\nJeder gelegte Stein zählt so viele Punkte, wie er Quadrate hat (ein\ngelegtes Pentomino zählt z.B. fünf Punkte). Wurden alle Steine einer\nFarbe gelegt, gibt es 15 zusätzliche Punkte. Wurden alle Steine einer\nFarbe gelegt und war zusätzlich der letzte gelegte Stein der Monomino,\ngibt es nochmal fünf zusätzliche Punkte (insgesamt also 20). Die Punkte\nder jeweiligen zwei Farben, die ein Spieler kontrolliert, werden\nzusammengezählt und sind die Gesamtpunkte des Spielers. Der Spieler mit\nden meisten Punkten gewinnt das Spiel.\n\nIn der Meisterschaftsphase ist die durchschnittliche Punktzahl\nnachrangiges Kriterium. D.h. haben zwei Teams gleich viele Siege,\nbekommt das Team mit der höheren durchschnittlichen Punktzahl den\nbesseren Tabellenplatz.\n","data":{},"elements":["t"]}},{"folder":"book","path":{"directory":"spiele/blokus/xml-dokumentation","absolute":"/home/runner/work/docs/docs/hyperbook/.hyperbook/book/spiele/blokus/xml-dokumentation/einleitung-xml.md","relative":"spiele/blokus/xml-dokumentation/einleitung-xml.md","href":"/spiele/blokus/xml-dokumentation/einleitung-xml"},"extension":".md","name":"einleitung-xml","root":"/home/runner/work/docs/docs/hyperbook/.hyperbook","markdown":{"content":"# Einleitung\n\nWie in den letzten Jahren wird zur Computerspieler-Server Kommunikation ein\nXML-Protokoll genutzt. In diesem Dokument wird die\nKommunikationsschnittstelle definiert, sodass ein komplett eigener\n:t[Computerspieler]{#player} geschrieben werden kann. Es wird hier nicht die vollständige\nKommunikation dokumentiert bzw. definiert, dennoch alles, womit ein\n:t[Computerspieler]{#player} umgehen können muss, um spielfähig zu sein.\n\n## An wen richtet sich dieses Dokument?\n\nDie Kommunikation mit dem Spielserver ist für diejenigen, die aufbauend\nauf dem Zufallsspieler programmieren, unwichtig. Dort steht bereits ein\nfunktionierender :t[Computerspieler]{#player} bereit und es muss nur die Spiellogik entworfen\nwerden. Nur wer einen komplett eigenen :t[Computerspieler]{#player} entwerfen will,\nbeispielsweise um die Programmiersprache frei wählen zu können, benötigt\ndie Definitionen.\n\n## Hinweise\n\nFalls Sie beabsichtigen sollten, diese Kommunikationsschnittstelle zu\nrealisieren, sei darauf hingewiesen, dass es im Verlauf des Wettbewerbes\nmöglich ist, dass weitere, hier noch nicht aufgeführte Elemente zur\nKommunikationsschnittstelle hinzugefügt werden. Um auch bei solchen\nÄnderungen sicher zu sein, dass ihr :t[Computerspieler]{#player} fehlerfrei mit dem Server\nkommunizieren kann, empfehlen wir Ihnen, beim Auslesen des :t[XML]{#xml} jegliche\nDaten zu verwerfen, die hier nicht weiter definiert sind. Die vom\nInstitut bereitgestellten Programme (Server, Zufallsspieler) nutzen eine\nBibliothek um Java-Objekte direkt in :t[XML]{#xml} zu konvertieren und umgekehrt.\nDabei werden XML-Nachrichten nicht unbedingt mit einer newline\nabgeschlossen.\n\nDie :t[XML]{#xml} Dokumentation behandelt ausschließlich die Kommunikation. Falls\nSie Dokumentation für den Verbindungsaufbau suchen, so finden Sie diese\n[hier](https://docs.software-challenge.de/_computerspieler_abgabefertig_machen.html#andere-sprache).\n","data":{},"elements":["t"]}},{"folder":"book","path":{"directory":"spiele/blokus/xml-dokumentation","absolute":"/home/runner/work/docs/docs/hyperbook/.hyperbook/book/spiele/blokus/xml-dokumentation/spiel-betreten.md","relative":"spiele/blokus/xml-dokumentation/spiel-betreten.md","href":"/spiele/blokus/xml-dokumentation/spiel-betreten"},"extension":".md","name":"spiel-betreten","root":"/home/runner/work/docs/docs/hyperbook/.hyperbook","markdown":{"content":"# Spiel betreten\n\nWenn begonnen wird mit dem Server zu kommunizieren, muss zuallererst\n\n    <protocol>\n\ngesendet werden, um die Kommunikation zu beginnen.\n\n## Ohne Reservierungscode\n\nBetritt ein beliebiges offenes Spiel:\n\n    <join gameType=\"swc_2021_blokus\" />\n\nSollte kein Spiel offen sein, wird so ein neues erstellt. Je nachdem ob\npaused in server.properties true oder false ist, wird das Spiel pausiert\ngestartet oder nicht. Der Server antwortet darauf mit:\n\n-   ROOM\\_ID ID des GameRooms\n\n<!-- -->\n\n    <joined roomId=\"ROOM_ID\" />\n\nAlle administrativen Clients werden ebenfalls darüber benachrichtigt und\nerhalten folgende Nachricht:\n\n-   ROOM\\_ID ID des GameRooms\n\n<!-- -->\n\n    <joinedGameRoom roomId=\"ROOM_ID\" existing=\"false\" />\n\nFalls bereits ein GameRoom offen war, ist dementsprechend existing true.\n\n## Mit Reservierungscode\n\nIst ein Reservierungscode gegeben, so kann man den durch den Code\ngegebenen Platz betreten.\n\n### Join mit Reservierungscode\n\n-   RC Reservierungscode\n\n<!-- -->\n\n    <joinPrepared reservationCode=\"RC\" />\n\n### Welcome Message\n\nDer Server antwortet darauf erst, wenn der zweite :t[Computerspieler]{#player} ebenfalls\nverbunden ist:\n\n-   ROOM\\_ID Id des GameRooms\n\n-   COLOR Spielerfarbe. Da bei Blokus jeder Spieler zwei Farben spielt,\n    ist hier nur one oder two angegeben\n\n-   STATUS GameState wie in [???](#status)\n\n<!-- -->\n\n    <joined roomId=\"ROOM_ID\" />\n    <room roomId=\"ROOM_ID\">\n      <data class=\"welcomeMessage\" color=\"COLOR\"></data>\n    </room>\n    <room roomId=\"ROOM_ID\">\n      STATUS\n    </room>\n\nAls erstes kommt eine Bestätigung, dass das Spiel betreten wurde. Hier\nkann die Raum-ID festgestellt und für die weitere Kommunikation\ngespeichert werden. Nach der Willkommensnachricht, welche dem Spieler\nmitteilt, ob er erster oder zweiter Spieler ist, wird der initiale\nSpielstatus gesendet.\n","data":{},"elements":["t"]}},{"folder":"book","path":{"directory":"spiele/blokus/xml-dokumentation","absolute":"/home/runner/work/docs/docs/hyperbook/.hyperbook/book/spiele/blokus/xml-dokumentation/spiel-verlassen.md","relative":"spiele/blokus/xml-dokumentation/spiel-verlassen.md","href":"/spiele/blokus/xml-dokumentation/spiel-verlassen"},"extension":".md","name":"spiel-verlassen","root":"/home/runner/work/docs/docs/hyperbook/.hyperbook","markdown":{"content":"# Spiel verlassen\n\nWenn ein :t[Computerspieler]{#player} den Raum verlässt, bekommen die anderen Clients eine\nentsprechende Meldung vom Server.\n\n-   `ROOM_ID` Id des GameRooms\n\n<!-- -->\n\n    <left roomId=\"ROOM_ID\" />\n","data":{},"elements":["t"]}},{"folder":"book","path":{"directory":"spiele/blokus/xml-dokumentation","absolute":"/home/runner/work/docs/docs/hyperbook/.hyperbook/book/spiele/blokus/xml-dokumentation/spielstatus.md","relative":"spiele/blokus/xml-dokumentation/spielstatus.md","href":"/spiele/blokus/xml-dokumentation/spielstatus"},"extension":".md","name":"spielstatus","root":"/home/runner/work/docs/docs/hyperbook/.hyperbook","markdown":{"content":"# Spielstatus\n\nEs folgt die Beschreibung des Spielstatus, der vor jeder Zugaufforderung\nan die Clients gesendet wird. Das Spielstatus-Tag ist dabei noch in\neinem *data*-Tag der Klasse *memento* gewrappt:\n\n## memento\n\n-   `ROOM_ID` Id des GameRooms\n\n-   `STATUS` Gamestate wie in [Status](#status)\n\n<!-- -->\n\n    <room roomId=\"ROOM_ID\">\n      <data class=\"memento\">\n        STATUS\n      </data>\n    </room>\n\n## Status\n\n-   `Z` aktuelle Zugzahl\n\n-   `R` aktuelle Rundenzahl\n\n-   `P` Spielstein, der in der ersten Runde gelegt werden muss, siehe\n    [???](#spielsteine)\n\n-   `T` Team, welches beginnt (`ONE`, `TWO`)\n\n-   `board` Das Spielbrett, wie in [Spielbrett](#spielbrett) definiert\n\n-   `blueShapes`, `yellowShapes`, `redShapes`, `greenShapes` Noch nicht\n    gesetzte Spielsteine, siehe [Nicht gesetzte\n    Spielsteine](#undeployed)\n\n-   `lastMoveMono` beschreibt, wenn eine Farbe alle Steine gelegt hat,\n    ob der Mono-Stein als letztes gelegt wurde\n\n-   `validColors` alle Farben, die noch im Spiel sind\n\n-   `first` Name und auch Team des ersten Spielers.\n\n-   `second` Name und auch Team des zweiten Spielers.\n\n-   `lastMove` der zuletzt ausgeführte Zug, siehe [Vorheriger\n    Zug](#last-move)\n\n<!-- -->\n\n    <state class=\"state\" turn=\"Z\" round=\"R\" startPiece=\"P\">\n      <startTeam class=\"team\">T</startTeam>\n      blueShapes\n      yellowShapes\n      redShapes\n      greenShapes\n      validColors\n      first\n      second\n      board\n      lastMove\n      lastMoveMono\n    </state>\n\n## Spielbrett\n\n-   `X` X-Koordinate\n\n-   `Y` Y-Koordinate\n\n-   `CONTENT` Farbe des Spielsteins, der dieses Feld überdeckt\n    (`BLUE`,`YELLOW`,`RED`,`GREEN`)\n\n<!-- -->\n\n    <board>\n      <fields>\n        <field x=\"17\" y=\"0\" content=\"BLUE\"/>\n        [...]\n        <field x=\"17\" y=\"2\" content=\"BLUE\"/>\n      </fields>\n      [...]\n    </board>\n\n`<board>` enthaelt `<field>` Tags für alle Felder, die bereits belegt\nsind. Leere Felder kommen nicht vor. Grundsätzlich besteht das\nSpielbrett aber immer aus 20x20 Feldern, wobei das Feld links oben die\nX- und Y-Koordinate 0 hat und die positive X-Achste nach rechts und die\npositive Y-Achse nach unten verläuft.\n\n## Nicht gesetzte Spielsteine\n\n    <blueShapes>\n      <shape>MONO</shape>\n      <shape>DOMINO</shape>\n      <shape>TRIO_L</shape>\n      <shape>TRIO_I</shape>\n      <shape>TETRO_O</shape>\n      <shape>TETRO_T</shape>\n      <shape>TETRO_I</shape>\n      <shape>TETRO_L</shape>\n      <shape>TETRO_Z</shape>\n      <shape>PENTO_L</shape>\n      <shape>PENTO_T</shape>\n      <shape>PENTO_S</shape>\n      <shape>PENTO_Z</shape>\n      <shape>PENTO_I</shape>\n      <shape>PENTO_P</shape>\n      <shape>PENTO_W</shape>\n      <shape>PENTO_U</shape>\n      <shape>PENTO_R</shape>\n      <shape>PENTO_X</shape>\n      <shape>PENTO_Y</shape>\n    </blueShapes>\n\nDie nicht gesetzten Steine werden durch `<shape>` Tags in einem\n`<blueShapes>`, `<yellowShapes>`, `<redShapes>` und `<greenShapes>` Tag\ndargestellt.\n\n## Letzter Stein\n\n    <lastMoveMono>\n      <entry>\n        <color>YELLOW</color>\n        <boolean>true</boolean>\n      </entry>\n    </lastMoveMono>\n\nJede Farbe, die alle Steine gesetzt hat, bekommt einen `<entry>` Tag.\nDieser beschreibt fuer die Farbe im `<color>` Tag als `<boolean>`, ob\nder Mono Stein als letztes gesetzt wurde.\n\n## Farben im Spiel\n\n    <validColors>\n      <color>BLUE</color>\n      <color>YELLOW</color>\n      <color>RED</color>\n      <color>GREEN</color>\n    </validColors>\n\nAlle Farben, die noch Züge durchführen können, werden durch `<color>`\nTags dargestellt.\n\n## Erster Spieler\n\n    <first displayName=\"One\">\n      <color class=\"team\">ONE</color>\n    </first>\n\nDer erste Spieler wird wird mit dem Tag `<first>` beschrieben. Das\nAttribut \"displayName\" beinhaltet den Spielernamen des ersten Spielers.\nDer untergeordnete Tag `<color>` hält entweder den Wert `ONE` oder\n`TWO`. Hier ist dies `ONE`, also macht der erste Spieler den ersten Zug.\n\n## Zweiter Spieler\n\nDieser Tag beschreibt den zweiten Spieler. Die Struktur ist wie bei\n[Erster Spieler](#first).\n\n## Vorheriger Zug\n\n    <lastMove class=\"sc.plugin2021.SetMove\">\n      <piece color=\"BLUE\" kind=\"PENTO_V\" rotation=\"RIGHT\" isFlipped=\"false\">\n        <position x=\"17\" y=\"0\"/>\n      </piece>\n    </lastMove>\n\nDer vorherige Zug hat die selbe Struktur wie ein [???](#zug), der\ngesendet wird, ausser dass das Tag `<lastMove>` und nicht `<data>`\nheisst. Der vorherige Zug wird in jedem Spielstatus angegeben, ausser\nvor dem ersten Zug.\n\n## Beispiel kompletter Spielstatus\n\nHier ist das :t[XML]{#xml} eines kompletten beispielhaften Spielstatus, wie es der\n:t[Computerspieler]{#player} vom Server bekommt:\n\n    <room roomId=\"cb3bc426-5c70-48b9-9307-943bc328b503\">\n      <data class=\"memento\">\n        <state turn=\"70\" round=\"18\" startPiece=\"PENTO_L\">\n          <startTeam class=\"team\">ONE</startTeam>\n          <blueShapes/>\n          <yellowShapes>\n            <shape>MONO</shape>\n          </yellowShapes>\n          <redShapes>\n            <shape>MONO</shape>\n            <shape>DOMINO</shape>\n          </redShapes>\n          <greenShapes>\n            <shape>MONO</shape>\n            <shape>DOMINO</shape>\n            <shape>TRIO_L</shape>\n            <shape>TRIO_I</shape>\n          </greenShapes>\n          <validColors>\n            <color>YELLOW</color>\n            <color>RED</color>\n            <color>GREEN</color>\n          </validColors>\n          <first displayName=\"\">\n            <color class=\"team\">ONE</color>\n          </first>\n          <second displayName=\"\">\n            <color class=\"team\">TWO</color>\n          </second>\n          <board>\n            <field x=\"0\" y=\"0\" content=\"RED\"/>\n            <field x=\"1\" y=\"3\" content=\"GREEN\"/>\n            <field x=\"8\" y=\"6\" content=\"YELLOW\"/>\n            <field x=\"5\" y=\"9\" content=\"BLUE\"/>\n          </board>\n          <lastMove class=\"sc.plugin2021.SetMove\">\n            <piece color=\"BLUE\" kind=\"MONO\" rotation=\"NONE\" isFlipped=\"false\">\n              <position x=\"0\" y=\"0\"/>\n            </piece>\n          </lastMove>\n          <lastMoveMono>\n            <entry>\n              <color>BLUE</color>\n              <boolean>true</boolean>\n            </entry>\n          </lastMoveMono>\n        </state>\n      </data>\n    </room>\n","data":{},"elements":["t"]}},{"folder":"book","path":{"directory":"spiele/blokus/xml-dokumentation","absolute":"/home/runner/work/docs/docs/hyperbook/.hyperbook/book/spiele/blokus/xml-dokumentation/spielverlauf.md","relative":"spiele/blokus/xml-dokumentation/spielverlauf.md","href":"/spiele/blokus/xml-dokumentation/spielverlauf"},"extension":".md","name":"spielverlauf","root":"/home/runner/work/docs/docs/hyperbook/.hyperbook","markdown":{"content":"# Spielverlauf\n\nDer Server startet (StandardIp: localhost 13050).\n\nNun gibt es zwei Varianten ein Spiel zu starten, eine durch einen\nAdministratorclient die andere durch hinzufügen der Spieler zu einen\nSpieltyp:\n\n## Variante 1 (AdminClient [???](#mit-reservierungscode))\n\nEin :t[Computerspieler]{#player} registriert sich als Administrator mit dem in\nserver.properties festgelegten Passwort pw:\n\n    <protocol><authenticate password=\"pw\" />\n\nDann kann ein Spiel angelegt werden:\n\n    <prepare gameType=\"swc_2021_blokus\" pause=\"true\">\n      <slot displayName=\"p1\" canTimeout=\"false\" />\n      <slot displayName=\"p2\" canTimeout=\"false\" />\n    </prepare>\n\nDer Server antwortet darauf mit einer Nachricht, die die ROOM\\_ID und\nReservierungscodes für die beiden Clients enthält:\n\n    <protocol>\n      <prepared roomId=\"871faccb-5190-4e44-82fc-6cdcbb493726\">\n        <reservation>RC1</reservation>\n        <reservation>RC2</reservation>\n      </prepared>\n\nDer Administratorclient kann dann ebenfalls als Observer des Spiels\ngenutzt werden, indem ein entsprechender Request gesendet wird. Dadurch\nwird das derzeitge Spielfeld ([???](#memento)) ebenfalls an den\nAdministratorclient gesendet.\n\n    <observe roomId=\"871faccb-5190-4e44-82fc-6cdcbb493726\" />\n\nClients, die auf dem Serverport (localhost 13050) gestartet werden,\nkönnen nun mit den Reservierungscodes beitreten.\n\n    <protocol>\n      <joinPrepared reservationCode=\"RC1\" />\n\n    <protocol>\n      <joinPrepared reservationCode=\"RC2\" />\n\n## Variante 2 (kein AdminClient notwendig [???](#ohne-reservierungscode))\n\nDie Clients wurden auf dem Serverport (Standard: localhost 13050)\ngestartet.\n\nSie können mit folgender Anfrage einem bereits offenen Spiel des\nentsprechenden Typs beitreten. Wenn noch keines vorhanden ist, wird\ndabei automatisch ein neues gestartet.\n\n    <protocol>\n      <join gameType=\"swc_2019_piranhas\" />\n\nDer Server antwortet mit:\n\n    <protocol>\n      <joined roomId=\"871faccb-5190-4e44-82fc-6cdcbb493726\" />\n\n## Weiterer Spielverlauf\n\nDer Server antwortet jeweils mit der WelcomeMessage\n([???](#welcome-message)) und dem ersten GameState ([???](#memento))\nsobald beide Spieler verbunden sind.\n\n    <room roomId=\"cb3bc426-5c70-48b9-9307-943bc328b503\">\n      <data class=\"welcomeMessage\" color=\"two\"/>\n    </room>\n    <room roomId=\"cb3bc426-5c70-48b9-9307-943bc328b503\">\n      <data class=\"memento\">\n        <state class=\"state\" turn=\"0\" round=\"1\" startPiece=\"PENTO_V\">\n          <startTeam class=\"team\">ONE</startTeam>\n          <board/>\n          <blueShapes class=\"linked-hash-set\">\n            <shape>MONO</shape>\n            <shape>DOMINO</shape>\n            <shape>TRIO_L</shape>\n            <shape>TRIO_I</shape>\n            <shape>TETRO_O</shape>\n            <shape>TETRO_T</shape>\n            <shape>TETRO_I</shape>\n            <shape>TETRO_L</shape>\n            <shape>TETRO_Z</shape>\n            <shape>PENTO_L</shape>\n            <shape>PENTO_T</shape>\n            <shape>PENTO_V</shape>\n            <shape>PENTO_S</shape>\n            <shape>PENTO_Z</shape>\n            <shape>PENTO_I</shape>\n            <shape>PENTO_P</shape>\n            <shape>PENTO_W</shape>\n            <shape>PENTO_U</shape>\n            <shape>PENTO_R</shape>\n            <shape>PENTO_X</shape>\n            <shape>PENTO_Y</shape>\n          </blueShapes>\n          <yellowShapes class=\"linked-hash-set\">\n            <shape>MONO</shape>\n            <shape>DOMINO</shape>\n            <shape>TRIO_L</shape>\n            <shape>TRIO_I</shape>\n            <shape>TETRO_O</shape>\n            <shape>TETRO_T</shape>\n            <shape>TETRO_I</shape>\n            <shape>TETRO_L</shape>\n            <shape>TETRO_Z</shape>\n            <shape>PENTO_L</shape>\n            <shape>PENTO_T</shape>\n            <shape>PENTO_V</shape>\n            <shape>PENTO_S</shape>\n            <shape>PENTO_Z</shape>\n            <shape>PENTO_I</shape>\n            <shape>PENTO_P</shape>\n            <shape>PENTO_W</shape>\n            <shape>PENTO_U</shape>\n            <shape>PENTO_R</shape>\n            <shape>PENTO_X</shape>\n            <shape>PENTO_Y</shape>\n          </yellowShapes>\n          <redShapes class=\"linked-hash-set\">\n            <shape>MONO</shape>\n            <shape>DOMINO</shape>\n            <shape>TRIO_L</shape>\n            <shape>TRIO_I</shape>\n            <shape>TETRO_O</shape>\n            <shape>TETRO_T</shape>\n            <shape>TETRO_I</shape>\n            <shape>TETRO_L</shape>\n            <shape>TETRO_Z</shape>\n            <shape>PENTO_L</shape>\n            <shape>PENTO_T</shape>\n            <shape>PENTO_V</shape>\n            <shape>PENTO_S</shape>\n            <shape>PENTO_Z</shape>\n            <shape>PENTO_I</shape>\n            <shape>PENTO_P</shape>\n            <shape>PENTO_W</shape>\n            <shape>PENTO_U</shape>\n            <shape>PENTO_R</shape>\n            <shape>PENTO_X</shape>\n            <shape>PENTO_Y</shape>\n          </redShapes>\n          <greenShapes class=\"linked-hash-set\">\n            <shape>MONO</shape>\n            <shape>DOMINO</shape>\n            <shape>TRIO_L</shape>\n            <shape>TRIO_I</shape>\n            <shape>TETRO_O</shape>\n            <shape>TETRO_T</shape>\n            <shape>TETRO_I</shape>\n            <shape>TETRO_L</shape>\n            <shape>TETRO_Z</shape>\n            <shape>PENTO_L</shape>\n            <shape>PENTO_T</shape>\n            <shape>PENTO_V</shape>\n            <shape>PENTO_S</shape>\n            <shape>PENTO_Z</shape>\n            <shape>PENTO_I</shape>\n            <shape>PENTO_P</shape>\n            <shape>PENTO_W</shape>\n            <shape>PENTO_U</shape>\n            <shape>PENTO_R</shape>\n            <shape>PENTO_X</shape>\n            <shape>PENTO_Y</shape>\n          </greenShapes>\n          <lastMoveMono class=\"linked-hash-map\"/>\n          <validColors class=\"linked-hash-set\">\n            <color>BLUE</color>\n            <color>YELLOW</color>\n            <color>RED</color>\n            <color>GREEN</color>\n          </validColors>\n          <first displayName=\"One\">\n            <color class=\"team\">ONE</color>\n          </first>\n          <second displayName=\"Two\">\n            <color class=\"team\">TWO</color>\n          </second>\n        </state>\n      </data>\n    </room>\n\nDer erste Spieler erhält dann eine Zugaufforderung\n([???](#move-request)), falls in server.properties paused auf false\ngesetzt wurde. Falls das Spiel pausiert ist, muss das Spiel durch einen\nAdministratorclient gestartet werden:\n\nVerbinden des Administratorclients (falls es sich um die erste\nKontaktaufnahme zum Server handelt, ansonsten &lt;protocol&gt;\nweglassen).\n\n    <protocol>\n      <authenticate password=\"examplepassword\" />\n\nPausierung aufheben:\n\n    <pause roomId=\"871faccb-5190-4e44-82fc-6cdcbb493726\" pause=\"false\" />\n\nDaraufhin wird der erste Spieler aufgefordert einen Zug zu senden:\n\n    <room roomId=\"871faccb-5190-4e44-82fc-6cdcbb493726\">\n      <data class=\"sc.framework.plugins.protocol.MoveRequest\" />\n    </room>\n\nDer :t[Computerspieler]{#player} des CurrentPlayer sendet nun einen Zug ([???](#zug)):\n\n    <room roomId=\"cb3bc426-5c70-48b9-9307-943bc328b503\">\n      <data class=\"sc.plugin2021.SetMove\">\n        <piece color=\"BLUE\" kind=\"PENTO_V\" rotation=\"RIGHT\" isFlipped=\"false\">\n          <position x=\"17\" y=\"0\"/>\n        </piece>\n      </data>\n    </room>\n\nSo geht es abwechselnd weiter, bis zum Spielende ([???](#spielende)).\nDie letzte Nachricht des Servers endet mit:\n\n    </protocol>\n\nDanach wird die Verbindung geschlossen.\n","data":{},"elements":["t"]}},{"folder":"book","path":{"directory":"spiele/blokus/xml-dokumentation","absolute":"/home/runner/work/docs/docs/hyperbook/.hyperbook/book/spiele/blokus/xml-dokumentation/xml-dokumentation.md","relative":"spiele/blokus/xml-dokumentation/xml-dokumentation.md","href":"/spiele/blokus/xml-dokumentation/xml-dokumentation"},"extension":".md","name":"xml-dokumentation","root":"/home/runner/work/docs/docs/hyperbook/.hyperbook","markdown":{"content":"Ziel dieser Dokumentation ist es, die XML-Schnittstelle der\nSoftwarechallenge festzuhalten.\n\n[PDF-Version dieses Dokumentes](xml-dokumentation.pdf)\n\nWir freuen uns über sämtliche Verbesserungsvorschläge. Die Dokumentation\nkann [direkt auf GitHub\neditiert](https://github.com/software-challenge/docs) werden, einzige\nVoraussetzung ist eine kostenlose Registrierung bei GitHub. Ist man\nangemeldet, kann man ein Dokument auswählen (ein guter Startpunkt ist\ndie Datei\n[index.md](https://github.com/software-challenge/docs/blob/master/index.md)\nwelche Verweise auf alle Sektionen der Dokumentation enthält) und dann\nauf den Stift oben rechts klicken. Alternativ auch gern eine E-Mail an\n<tech@software-challenge.de>.\n\n# Einleitung\n\nWie in den letzten Jahren wird zur Computerspieler-Server Kommunikation ein\nXML-Protokoll genutzt. In diesem Dokument wird die\nKommunikationsschnittstelle definiert, sodass ein komplett eigener\n:t[Computerspieler]{#player} geschrieben werden kann. Es wird hier nicht die vollständige\nKommunikation dokumentiert bzw. definiert, dennoch alles, womit ein\n:t[Computerspieler]{#player} umgehen können muss, um spielfähig zu sein.\n\n## An wen richtet sich dieses Dokument?\n\nDie Kommunikation mit dem Spielserver ist für diejenigen, die aufbauend\nauf dem Zufallsspieler programmieren, unwichtig. Dort steht bereits ein\nfunktionierender :t[Computerspieler]{#player} bereit und es muss nur die Spiellogik entworfen\nwerden. Nur wer einen komplett eigenen :t[Computerspieler]{#player} entwerfen will,\nbeispielsweise um die Programmiersprache frei wählen zu können, benötigt\ndie Definitionen.\n\n## Hinweise\n\nFalls Sie beabsichtigen sollten, diese Kommunikationsschnittstelle zu\nrealisieren, sei darauf hingewiesen, dass es im Verlauf des Wettbewerbes\nmöglich ist, dass weitere, hier noch nicht aufgeführte Elemente zur\nKommunikationsschnittstelle hinzugefügt werden. Um auch bei solchen\nÄnderungen sicher zu sein, dass ihr :t[Computerspieler]{#player} fehlerfrei mit dem Server\nkommunizieren kann, empfehlen wir Ihnen, beim Auslesen des :t[XML]{#xml} jegliche\nDaten zu verwerfen, die hier nicht weiter definiert sind. Die vom\nInstitut bereitgestellten Programme (Server, Zufallsspieler) nutzen eine\nBibliothek um Java-Objekte direkt in :t[XML]{#xml} zu konvertieren und umgekehrt.\nDabei werden XML-Nachrichten nicht unbedingt mit einer newline\nabgeschlossen.\n\nDie :t[XML]{#xml} Dokumentation behandelt ausschließlich die Kommunikation. Falls\nSie Dokumentation für den Verbindungsaufbau suchen, so finden Sie diese\n[hier](https://docs.software-challenge.de/_computerspieler_abgabefertig_machen.html#andere-sprache).\n\n# Spiel betreten\n\nWenn begonnen wird mit dem Server zu kommunizieren, muss zuallererst\n\n    <protocol>\n\ngesendet werden, um die Kommunikation zu beginnen.\n\n## Ohne Reservierungscode\n\nBetritt ein beliebiges offenes Spiel:\n\n    <join gameType=\"swc_2021_blokus\" />\n\nSollte kein Spiel offen sein, wird so ein neues erstellt. Je nachdem ob\npaused in server.properties true oder false ist, wird das Spiel pausiert\ngestartet oder nicht. Der Server antwortet darauf mit:\n\n-   ROOM\\_ID ID des GameRooms\n\n<!-- -->\n\n    <joined roomId=\"ROOM_ID\" />\n\nAlle administrativen Clients werden ebenfalls darüber benachrichtigt und\nerhalten folgende Nachricht:\n\n-   ROOM\\_ID ID des GameRooms\n\n<!-- -->\n\n    <joinedGameRoom roomId=\"ROOM_ID\" existing=\"false\" />\n\nFalls bereits ein GameRoom offen war, ist dementsprechend existing true.\n\n## Mit Reservierungscode\n\nIst ein Reservierungscode gegeben, so kann man den durch den Code\ngegebenen Platz betreten.\n\n### Join mit Reservierungscode\n\n-   RC Reservierungscode\n\n<!-- -->\n\n    <joinPrepared reservationCode=\"RC\" />\n\n### Welcome Message\n\nDer Server antwortet darauf erst, wenn der zweite :t[Computerspieler]{#player} ebenfalls\nverbunden ist:\n\n-   ROOM\\_ID Id des GameRooms\n\n-   COLOR Spielerfarbe. Da bei Blokus jeder Spieler zwei Farben spielt,\n    ist hier nur one oder two angegeben\n\n-   STATUS GameState wie in [Status](#status)\n\n<!-- -->\n\n    <joined roomId=\"ROOM_ID\" />\n    <room roomId=\"ROOM_ID\">\n      <data class=\"welcomeMessage\" color=\"COLOR\"></data>\n    </room>\n    <room roomId=\"ROOM_ID\">\n      STATUS\n    </room>\n\nAls erstes kommt eine Bestätigung, dass das Spiel betreten wurde. Hier\nkann die Raum-ID festgestellt und für die weitere Kommunikation\ngespeichert werden. Nach der Willkommensnachricht, welche dem Spieler\nmitteilt, ob er erster oder zweiter Spieler ist, wird der initiale\nSpielstatus gesendet.\n\n# Zug-Anforderung\n\nEine einfache Nachricht fordert zum Zug auf:\n\n    <room roomId=\"ROOM_ID\">\n      <data class=\"sc.framework.plugins.protocol.MoveRequest\" />\n    </room>\n\n# Züge senden\n\n## Der Move\n\nDer Move ist die Antwort auf den MoveRequest des Servers.\n\n### Senden\n\nDer Move ist der allgemeine Zug, der in verschiedenen Varianten gesendet\nwerden kann.\n\n`ROOM_ID`  \nID des GameRooms, aus dem `MoveRequest`.\n\n`ZUG`  \nZug wie in [ZUG](#zug)\n\n<!-- -->\n\n    <room roomId=\"ROOM_ID\">\n      ZUG\n    </room>\n\n## ZUG\n\n`COLOR`  \nFarbe des zu setzenden Spielsteines (`BLUE`,`YELLOW`,`RED`,`GREEN`)\n\n`KIND`  \nTyp des zu setzenden Spielsteines (siehe [Spielsteine](#spielsteine))\n\n`ROTATION`  \nDrehung des Spielsteines (`NONE`,`RIGHT`,`MIRROR`,`LEFT`)\n\n`FLIPPED`  \nOb der Spielstein umgedreht wurde (`true`,`false`)\n\n`X`  \nX-Koordinate des zu ziehenden Spielsteines oder des Zielfeldes\n\n`Y`  \nY-Koordinate des zu ziehenden Spielsteines oder des Zielfeldes\n\nEs gibt zwei Arten von Zuegen. Entweder man setzt einen eigenen noch\nnicht gesetzten Stein auf ein Zielfeld:\n\n    <data class=\"sc.plugin2021.SetMove\">\n      <piece color=\"COLOR\" kind=\"KIND\" rotation=\"ROTATION\" isFlipped=\"FLIPPED\">\n        <position x=\"X\" y=\"Y\"/>\n      </piece>\n    </data>\n\nOder man möchte nicht setzen, dann ist es erlaubt, auszusetzen:\n\n    <data class=\"sc.plugin2021.SkipMove\">\n      <color>COLOR</color>\n    </data>\n\n### Spielstein Transformationen\n\nBei `ROTATION` `NONE` ändern sich die Koordinaten der Teile des\nSpielsteins nicht. `(x, y) ⇒ (x, y)`\n\n![pento L](./images/pento_L.png)\n\nBei `ROTATION` `RIGHT` wird der Spielstein um den Ursprung nach rechts\ngedreht. `(x, y) ⇒ (-y, x)`\n\n![pento L RIGHT](./images/pento_L_RIGHT.png)\n\nBei `ROTATION` `MIRROR` wird der Spielstein um den Ursprung gespiegelt.\n`(x, y) ⇒ (-x, -y)`\n\n![pento L MIRROR](./images/pento_L_MIRROR.png)\n\nBei `ROTATION` `LEFT` wird der Spielstein um den Ursprung nach links\ngedreht. `(x, y) ⇒ (y, -x)`\n\n![pento L LEFT](./images/pento_L_LEFT.png)\n\nWird zusätzlich `FLIPPED` auf `true` gesetzt, so werden die von der\nRotation resultierenden Koordinaten anschließend noch auf der X-Achse\ninvertiert. `(x, y) ⇒ (-x, y)`\n\n![pento L LEFT FLIPPED](./images/pento_L_LEFT_FLIPPED.png)\n\nAuf dem vorigen Bild ist das Resultat von `ROTATION` `LEFT` und\n`FLIPPED` `true` zu sehen.\n\nNach den Transformationen werden die Koordinaten noch normalisiert, d.h.\nsie werden an die obere linke Ecke angelegt.\n\nDafür werden sie mit dem minimalen X Wert aller Koordinaten und dem\nminimalen Y Wert aller Koordinaten subtrahiert.\n`(x, y) ⇒ (x - minX, y - minY)`\n\nSchließlich werden die Koordinaten noch mit den `X, Y` Werten, die zum\nMove gehören, addiert, um die Koordinaten aller Teile des Spielsteins\nauf dem Board zu erhalten.\n\n## Debughints\n\nZügen können Debug-Informationen beigefügt werden:\n\n    <hint content=\"S\" />\n\nDamit sieht beispielsweise ein Zug so aus:\n\n    <room roomId=\"ROOM_ID\">\n      <data class=\"sc.plugin2021.SetMove\">\n        <piece color=\"COLOR\" kind=\"KIND\" rotation=\"ROTATION\" isFlipped=\"FLIPPED\">\n          <position x=\"X\" y=\"Y\"/>\n        </piece>\n        <hint content=\"Dies ist ein Hint.\" />\n        <hint content=\"noch ein Hint\" />\n      </data>\n    </room>\n\n# Spielsteine\n\nEs gibt 21 verschiedene Arten Spielsteine. Alle haben im :t[XML]{#xml} einen\nNamen. Diese sind:\n\n-   `MONO`\n\n-   `DOMINO`\n\n-   `TRIO_L`\n\n-   `TRIO_I`\n\n-   `TETRO_O`\n\n-   `TETRO_T`\n\n-   `TETRO_I`\n\n-   `TETRO_L`\n\n-   `TETRO_Z`\n\n-   `PENTO_L`\n\n-   `PENTO_T`\n\n-   `PENTO_V`\n\n-   `PENTO_S`\n\n-   `PENTO_Z`\n\n-   `PENTO_I`\n\n-   `PENTO_P`\n\n-   `PENTO_W`\n\n-   `PENTO_U`\n\n-   `PENTO_R`\n\n-   `PENTO_X`\n\n-   `PENTO_Y`\n\n# Spielstatus\n\nEs folgt die Beschreibung des Spielstatus, der vor jeder Zugaufforderung\nan die Clients gesendet wird. Das Spielstatus-Tag ist dabei noch in\neinem *data*-Tag der Klasse *memento* gewrappt:\n\n## memento\n\n-   `ROOM_ID` Id des GameRooms\n\n-   `STATUS` Gamestate wie in [Status](#status)\n\n<!-- -->\n\n    <room roomId=\"ROOM_ID\">\n      <data class=\"memento\">\n        STATUS\n      </data>\n    </room>\n\n## Status\n\n-   `Z` aktuelle Zugzahl\n\n-   `R` aktuelle Rundenzahl\n\n-   `P` Spielstein, der in der ersten Runde gelegt werden muss, siehe\n    [Spielsteine](#spielsteine)\n\n-   `T` Team, welches beginnt (`ONE`, `TWO`)\n\n-   `board` Das Spielbrett, wie in [Spielbrett](#spielbrett) definiert\n\n-   `blueShapes`, `yellowShapes`, `redShapes`, `greenShapes` Noch nicht\n    gesetzte Spielsteine, siehe [Nicht gesetzte\n    Spielsteine](#undeployed)\n\n-   `lastMoveMono` beschreibt, wenn eine Farbe alle Steine gelegt hat,\n    ob der Mono-Stein als letztes gelegt wurde\n\n-   `validColors` alle Farben, die noch im Spiel sind\n\n-   `first` Name und auch Team des ersten Spielers.\n\n-   `second` Name und auch Team des zweiten Spielers.\n\n-   `lastMove` der zuletzt ausgeführte Zug, siehe [Vorheriger\n    Zug](#last-move)\n\n<!-- -->\n\n    <state class=\"state\" turn=\"Z\" round=\"R\" startPiece=\"P\">\n      <startTeam class=\"team\">T</startTeam>\n      blueShapes\n      yellowShapes\n      redShapes\n      greenShapes\n      validColors\n      first\n      second\n      board\n      lastMove\n      lastMoveMono\n    </state>\n\n## Spielbrett\n\n-   `X` X-Koordinate\n\n-   `Y` Y-Koordinate\n\n-   `CONTENT` Farbe des Spielsteins, der dieses Feld überdeckt\n    (`BLUE`,`YELLOW`,`RED`,`GREEN`)\n\n<!-- -->\n\n    <board>\n      <fields>\n        <field x=\"17\" y=\"0\" content=\"BLUE\"/>\n        [...]\n        <field x=\"17\" y=\"2\" content=\"BLUE\"/>\n      </fields>\n      [...]\n    </board>\n\n`<board>` enthaelt `<field>` Tags für alle Felder, die bereits belegt\nsind. Leere Felder kommen nicht vor. Grundsätzlich besteht das\nSpielbrett aber immer aus 20x20 Feldern, wobei das Feld links oben die\nX- und Y-Koordinate 0 hat und die positive X-Achste nach rechts und die\npositive Y-Achse nach unten verläuft.\n\n## Nicht gesetzte Spielsteine\n\n    <blueShapes>\n      <shape>MONO</shape>\n      <shape>DOMINO</shape>\n      <shape>TRIO_L</shape>\n      <shape>TRIO_I</shape>\n      <shape>TETRO_O</shape>\n      <shape>TETRO_T</shape>\n      <shape>TETRO_I</shape>\n      <shape>TETRO_L</shape>\n      <shape>TETRO_Z</shape>\n      <shape>PENTO_L</shape>\n      <shape>PENTO_T</shape>\n      <shape>PENTO_S</shape>\n      <shape>PENTO_Z</shape>\n      <shape>PENTO_I</shape>\n      <shape>PENTO_P</shape>\n      <shape>PENTO_W</shape>\n      <shape>PENTO_U</shape>\n      <shape>PENTO_R</shape>\n      <shape>PENTO_X</shape>\n      <shape>PENTO_Y</shape>\n    </blueShapes>\n\nDie nicht gesetzten Steine werden durch `<shape>` Tags in einem\n`<blueShapes>`, `<yellowShapes>`, `<redShapes>` und `<greenShapes>` Tag\ndargestellt.\n\n## Letzter Stein\n\n    <lastMoveMono>\n      <entry>\n        <color>YELLOW</color>\n        <boolean>true</boolean>\n      </entry>\n    </lastMoveMono>\n\nJede Farbe, die alle Steine gesetzt hat, bekommt einen `<entry>` Tag.\nDieser beschreibt fuer die Farbe im `<color>` Tag als `<boolean>`, ob\nder Mono Stein als letztes gesetzt wurde.\n\n## Farben im Spiel\n\n    <validColors>\n      <color>BLUE</color>\n      <color>YELLOW</color>\n      <color>RED</color>\n      <color>GREEN</color>\n    </validColors>\n\nAlle Farben, die noch Züge durchführen können, werden durch `<color>`\nTags dargestellt.\n\n## Erster Spieler\n\n    <first displayName=\"One\">\n      <color class=\"team\">ONE</color>\n    </first>\n\nDer erste Spieler wird wird mit dem Tag `<first>` beschrieben. Das\nAttribut \"displayName\" beinhaltet den Spielernamen des ersten Spielers.\nDer untergeordnete Tag `<color>` hält entweder den Wert `ONE` oder\n`TWO`. Hier ist dies `ONE`, also macht der erste Spieler den ersten Zug.\n\n## Zweiter Spieler\n\nDieser Tag beschreibt den zweiten Spieler. Die Struktur ist wie bei\n[Erster Spieler](#first).\n\n## Vorheriger Zug\n\n    <lastMove class=\"sc.plugin2021.SetMove\">\n      <piece color=\"BLUE\" kind=\"PENTO_V\" rotation=\"RIGHT\" isFlipped=\"false\">\n        <position x=\"17\" y=\"0\"/>\n      </piece>\n    </lastMove>\n\nDer vorherige Zug hat die selbe Struktur wie ein [ZUG](#zug), der\ngesendet wird, ausser dass das Tag `<lastMove>` und nicht `<data>`\nheisst. Der vorherige Zug wird in jedem Spielstatus angegeben, ausser\nvor dem ersten Zug.\n\n## Beispiel kompletter Spielstatus\n\nHier ist das :t[XML]{#xml} eines kompletten beispielhaften Spielstatus, wie es der\n:t[Computerspieler]{#player} vom Server bekommt:\n\n    <room roomId=\"cb3bc426-5c70-48b9-9307-943bc328b503\">\n      <data class=\"memento\">\n        <state turn=\"70\" round=\"18\" startPiece=\"PENTO_L\">\n          <startTeam class=\"team\">ONE</startTeam>\n          <blueShapes/>\n          <yellowShapes>\n            <shape>MONO</shape>\n          </yellowShapes>\n          <redShapes>\n            <shape>MONO</shape>\n            <shape>DOMINO</shape>\n          </redShapes>\n          <greenShapes>\n            <shape>MONO</shape>\n            <shape>DOMINO</shape>\n            <shape>TRIO_L</shape>\n            <shape>TRIO_I</shape>\n          </greenShapes>\n          <validColors>\n            <color>YELLOW</color>\n            <color>RED</color>\n            <color>GREEN</color>\n          </validColors>\n          <first displayName=\"\">\n            <color class=\"team\">ONE</color>\n          </first>\n          <second displayName=\"\">\n            <color class=\"team\">TWO</color>\n          </second>\n          <board>\n            <field x=\"0\" y=\"0\" content=\"RED\"/>\n            <field x=\"1\" y=\"3\" content=\"GREEN\"/>\n            <field x=\"8\" y=\"6\" content=\"YELLOW\"/>\n            <field x=\"5\" y=\"9\" content=\"BLUE\"/>\n          </board>\n          <lastMove class=\"sc.plugin2021.SetMove\">\n            <piece color=\"BLUE\" kind=\"MONO\" rotation=\"NONE\" isFlipped=\"false\">\n              <position x=\"0\" y=\"0\"/>\n            </piece>\n          </lastMove>\n          <lastMoveMono>\n            <entry>\n              <color>BLUE</color>\n              <boolean>true</boolean>\n            </entry>\n          </lastMoveMono>\n        </state>\n      </data>\n    </room>\n\n# Spiel verlassen\n\nWenn ein :t[Computerspieler]{#player} den Raum verlässt, bekommen die anderen Clients eine\nentsprechende Meldung vom Server.\n\n-   `ROOM_ID` Id des GameRooms\n\n<!-- -->\n\n    <left roomId=\"ROOM_ID\" />\n\n# Spielergebnis\n\nZum Spielende enthält der Spieler das Ergebnis:\n\n-   `ROOM_ID` Id des GameRooms\n\n-   `R1`, `R2` Text, der den Grund für das Spielende erklärt\n\n-   `CAUSE1`, `CAUSE2` Grund des Spielendes (`REGULAR`, `LEFT`,\n    `RULE_VIOLATION`, `SOFT_TIMEOUT`, `HARD_TIMEOUT`)\n\n-   `WP1`, `WP2` Siegpunkte der jeweiligen Spieler, 0 verloren, 1\n    unentschieden, 2 gewonnen\n\n-   `S1`, `S2` Punkte des jeweiligen Spielers\n\n-   `NAME` Anzeigename des Spielers\n\n-   `TEAM` Team des Siegers (`ONE`, `TWO`)\n\n<!-- -->\n\n    <room roomId=\"ROOM_ID\">\n      <data class=\"result\">\n        <definition>\n          <fragment name=\"Gewinner\">\n            <aggregation>SUM</aggregation>\n            <relevantForRanking>true</relevantForRanking>\n          </fragment>\n          <fragment name=\"∅ Punkte\">\n            <aggregation>AVERAGE</aggregation>\n            <relevantForRanking>true</relevantForRanking>\n          </fragment>\n        </definition>\n        <score cause=\"CAUSE1\" reason=\"R1\">\n          <part>WP1</part>\n          <part>S1</part>\n        </score>\n        <score cause=\"CAUSE2\" reason=\"R2\">\n          <part>WP2</part>\n          <part>S2</part>\n        </score>\n        <winner displayName=\"NAME\">\n          <color class=\"team\">TEAM</color>\n        </winner>\n      </data>\n    </room>\n\n# Spielverlauf\n\nDer Server startet (StandardIp: localhost 13050).\n\nNun gibt es zwei Varianten ein Spiel zu starten, eine durch einen\nAdministratorclient die andere durch hinzufügen der Spieler zu einen\nSpieltyp:\n\n## Variante 1 (AdminClient [Mit Reservierungscode](#mit-reservierungscode))\n\nEin :t[Computerspieler]{#player} registriert sich als Administrator mit dem in\nserver.properties festgelegten Passwort pw:\n\n    <protocol><authenticate password=\"pw\" />\n\nDann kann ein Spiel angelegt werden:\n\n    <prepare gameType=\"swc_2021_blokus\" pause=\"true\">\n      <slot displayName=\"p1\" canTimeout=\"false\" />\n      <slot displayName=\"p2\" canTimeout=\"false\" />\n    </prepare>\n\nDer Server antwortet darauf mit einer Nachricht, die die ROOM\\_ID und\nReservierungscodes für die beiden Clients enthält:\n\n    <protocol>\n      <prepared roomId=\"871faccb-5190-4e44-82fc-6cdcbb493726\">\n        <reservation>RC1</reservation>\n        <reservation>RC2</reservation>\n      </prepared>\n\nDer Administratorclient kann dann ebenfalls als Observer des Spiels\ngenutzt werden, indem ein entsprechender Request gesendet wird. Dadurch\nwird das derzeitge Spielfeld ([memento](#memento)) ebenfalls an den\nAdministratorclient gesendet.\n\n    <observe roomId=\"871faccb-5190-4e44-82fc-6cdcbb493726\" />\n\nClients, die auf dem Serverport (localhost 13050) gestartet werden,\nkönnen nun mit den Reservierungscodes beitreten.\n\n    <protocol>\n      <joinPrepared reservationCode=\"RC1\" />\n\n    <protocol>\n      <joinPrepared reservationCode=\"RC2\" />\n\n## Variante 2 (kein AdminClient notwendig [Ohne Reservierungscode](#ohne-reservierungscode))\n\nDie Clients wurden auf dem Serverport (Standard: localhost 13050)\ngestartet.\n\nSie können mit folgender Anfrage einem bereits offenen Spiel des\nentsprechenden Typs beitreten. Wenn noch keines vorhanden ist, wird\ndabei automatisch ein neues gestartet.\n\n    <protocol>\n      <join gameType=\"swc_2019_piranhas\" />\n\nDer Server antwortet mit:\n\n    <protocol>\n      <joined roomId=\"871faccb-5190-4e44-82fc-6cdcbb493726\" />\n\n## Weiterer Spielverlauf\n\nDer Server antwortet jeweils mit der WelcomeMessage ([Welcome\nMessage](#welcome-message)) und dem ersten GameState\n([memento](#memento)) sobald beide Spieler verbunden sind.\n\n    <room roomId=\"cb3bc426-5c70-48b9-9307-943bc328b503\">\n      <data class=\"welcomeMessage\" color=\"two\"/>\n    </room>\n    <room roomId=\"cb3bc426-5c70-48b9-9307-943bc328b503\">\n      <data class=\"memento\">\n        <state class=\"state\" turn=\"0\" round=\"1\" startPiece=\"PENTO_V\">\n          <startTeam class=\"team\">ONE</startTeam>\n          <board/>\n          <blueShapes class=\"linked-hash-set\">\n            <shape>MONO</shape>\n            <shape>DOMINO</shape>\n            <shape>TRIO_L</shape>\n            <shape>TRIO_I</shape>\n            <shape>TETRO_O</shape>\n            <shape>TETRO_T</shape>\n            <shape>TETRO_I</shape>\n            <shape>TETRO_L</shape>\n            <shape>TETRO_Z</shape>\n            <shape>PENTO_L</shape>\n            <shape>PENTO_T</shape>\n            <shape>PENTO_V</shape>\n            <shape>PENTO_S</shape>\n            <shape>PENTO_Z</shape>\n            <shape>PENTO_I</shape>\n            <shape>PENTO_P</shape>\n            <shape>PENTO_W</shape>\n            <shape>PENTO_U</shape>\n            <shape>PENTO_R</shape>\n            <shape>PENTO_X</shape>\n            <shape>PENTO_Y</shape>\n          </blueShapes>\n          <yellowShapes class=\"linked-hash-set\">\n            <shape>MONO</shape>\n            <shape>DOMINO</shape>\n            <shape>TRIO_L</shape>\n            <shape>TRIO_I</shape>\n            <shape>TETRO_O</shape>\n            <shape>TETRO_T</shape>\n            <shape>TETRO_I</shape>\n            <shape>TETRO_L</shape>\n            <shape>TETRO_Z</shape>\n            <shape>PENTO_L</shape>\n            <shape>PENTO_T</shape>\n            <shape>PENTO_V</shape>\n            <shape>PENTO_S</shape>\n            <shape>PENTO_Z</shape>\n            <shape>PENTO_I</shape>\n            <shape>PENTO_P</shape>\n            <shape>PENTO_W</shape>\n            <shape>PENTO_U</shape>\n            <shape>PENTO_R</shape>\n            <shape>PENTO_X</shape>\n            <shape>PENTO_Y</shape>\n          </yellowShapes>\n          <redShapes class=\"linked-hash-set\">\n            <shape>MONO</shape>\n            <shape>DOMINO</shape>\n            <shape>TRIO_L</shape>\n            <shape>TRIO_I</shape>\n            <shape>TETRO_O</shape>\n            <shape>TETRO_T</shape>\n            <shape>TETRO_I</shape>\n            <shape>TETRO_L</shape>\n            <shape>TETRO_Z</shape>\n            <shape>PENTO_L</shape>\n            <shape>PENTO_T</shape>\n            <shape>PENTO_V</shape>\n            <shape>PENTO_S</shape>\n            <shape>PENTO_Z</shape>\n            <shape>PENTO_I</shape>\n            <shape>PENTO_P</shape>\n            <shape>PENTO_W</shape>\n            <shape>PENTO_U</shape>\n            <shape>PENTO_R</shape>\n            <shape>PENTO_X</shape>\n            <shape>PENTO_Y</shape>\n          </redShapes>\n          <greenShapes class=\"linked-hash-set\">\n            <shape>MONO</shape>\n            <shape>DOMINO</shape>\n            <shape>TRIO_L</shape>\n            <shape>TRIO_I</shape>\n            <shape>TETRO_O</shape>\n            <shape>TETRO_T</shape>\n            <shape>TETRO_I</shape>\n            <shape>TETRO_L</shape>\n            <shape>TETRO_Z</shape>\n            <shape>PENTO_L</shape>\n            <shape>PENTO_T</shape>\n            <shape>PENTO_V</shape>\n            <shape>PENTO_S</shape>\n            <shape>PENTO_Z</shape>\n            <shape>PENTO_I</shape>\n            <shape>PENTO_P</shape>\n            <shape>PENTO_W</shape>\n            <shape>PENTO_U</shape>\n            <shape>PENTO_R</shape>\n            <shape>PENTO_X</shape>\n            <shape>PENTO_Y</shape>\n          </greenShapes>\n          <lastMoveMono class=\"linked-hash-map\"/>\n          <validColors class=\"linked-hash-set\">\n            <color>BLUE</color>\n            <color>YELLOW</color>\n            <color>RED</color>\n            <color>GREEN</color>\n          </validColors>\n          <first displayName=\"One\">\n            <color class=\"team\">ONE</color>\n          </first>\n          <second displayName=\"Two\">\n            <color class=\"team\">TWO</color>\n          </second>\n        </state>\n      </data>\n    </room>\n\nDer erste Spieler erhält dann eine Zugaufforderung\n([???](#move-request)), falls in server.properties paused auf false\ngesetzt wurde. Falls das Spiel pausiert ist, muss das Spiel durch einen\nAdministratorclient gestartet werden:\n\nVerbinden des Administratorclients (falls es sich um die erste\nKontaktaufnahme zum Server handelt, ansonsten &lt;protocol&gt;\nweglassen).\n\n    <protocol>\n      <authenticate password=\"examplepassword\" />\n\nPausierung aufheben:\n\n    <pause roomId=\"871faccb-5190-4e44-82fc-6cdcbb493726\" pause=\"false\" />\n\nDaraufhin wird der erste Spieler aufgefordert einen Zug zu senden:\n\n    <room roomId=\"871faccb-5190-4e44-82fc-6cdcbb493726\">\n      <data class=\"sc.framework.plugins.protocol.MoveRequest\" />\n    </room>\n\nDer :t[Computerspieler]{#player} des CurrentPlayer sendet nun einen Zug ([ZUG](#zug)):\n\n    <room roomId=\"cb3bc426-5c70-48b9-9307-943bc328b503\">\n      <data class=\"sc.plugin2021.SetMove\">\n        <piece color=\"BLUE\" kind=\"PENTO_V\" rotation=\"RIGHT\" isFlipped=\"false\">\n          <position x=\"17\" y=\"0\"/>\n        </piece>\n      </data>\n    </room>\n\nSo geht es abwechselnd weiter, bis zum Spielende\n([Spielergebnis](#spielende)). Die letzte Nachricht des Servers endet\nmit:\n\n    </protocol>\n\nDanach wird die Verbindung geschlossen.\n","data":{},"elements":["t"]}},{"folder":"book","path":{"directory":"spiele/hase-und-igel/xml-dokumentation","absolute":"/home/runner/work/docs/docs/hyperbook/.hyperbook/book/spiele/hase-und-igel/xml-dokumentation/einleitung-xml.md","relative":"spiele/hase-und-igel/xml-dokumentation/einleitung-xml.md","href":"/spiele/hase-und-igel/xml-dokumentation/einleitung-xml"},"extension":".md","name":"einleitung-xml","root":"/home/runner/work/docs/docs/hyperbook/.hyperbook","markdown":{"content":"# Einleitung\n\nWie in den letzten Jahren wird zur Computerspieler-Server Kommunikation ein\nXML-Protokoll genutzt. In diesem Dokument wird die\nKommunikationsschnittstelle definiert, sodass ein komplett eigener\n:t[Computerspieler]{#player} geschrieben werden kann. Es wird hier nicht die vollständige\nKommunikation dokumentiert bzw. definiert, dennoch alles, womit ein\n:t[Computerspieler]{#player} umgehen können muss, um spielfähig zu sein.\n\n## An wen richtet sich dieses Dokument?\n\nDie Kommunikation mit dem Spielserver ist für diejenigen, die aufbauend\nauf dem Zufallsspieler programmieren, unwichtig. Dort steht bereits ein\nfunktionierender :t[Computerspieler]{#player} bereit und es muss nur die Spiellogik entworfen\nwerden. \\\\\\\\ Nur wer einen komplett eigenen :t[Computerspieler]{#player} entwerfen will,\nbeispielsweise um die Programmiersprache frei wählen zu können, benötigt\ndie Definitionen.\n\n## Hinweise\n\nFalls Sie beabsichtigen sollten, diese Kommunikationsschnittstelle zu\nrealisieren, sei darauf hingewiesen, dass es im Verlauf des Wettbewerbes\nmöglich ist, dass weitere, hier noch nicht aufgeführte Elemente zur\nKommunikationsschnittstelle hinzugefügt werden. Um auch bei solchen\nÄnderungen sicher zu sein, dass ihr :t[Computerspieler]{#player} fehlerfrei mit dem Server\nkommunizieren kann, empfehlen wir Ihnen, beim Auslesen des :t[XML]{#xml} jegliche\nDaten zu verwerfen, die hier nicht weiter definiert sind. Die vom\nInstitut bereitgestellten Programme (Server, Zufallsspieler) nutzen eine\nBibliothek um Java-Objekte direkt in :t[XML]{#xml} zu konvertieren und umgekehrt.\nDabei werden XML-Nachrichten nicht mit einem newline abgeschlossen.\n","data":{},"elements":["t"]}},{"folder":"book","path":{"directory":"spiele/hase-und-igel/xml-dokumentation","absolute":"/home/runner/work/docs/docs/hyperbook/.hyperbook/book/spiele/hase-und-igel/xml-dokumentation/fehler.md","relative":"spiele/hase-und-igel/xml-dokumentation/fehler.md","href":"/spiele/hase-und-igel/xml-dokumentation/fehler"},"extension":".md","name":"fehler","root":"/home/runner/work/docs/docs/hyperbook/.hyperbook","markdown":{"content":"# Fehler\n\nEin “spielfähiger” :t[Computerspieler]{#player} muss nicht mit Fehlern umgehen können.\nFehlerhafte Züge beispielsweise resultieren in einem vorzeitigen Ende\ndes Spieles, das im nächsten gesendeten Gamestate erkannt werden kann\n(siehe [???](#spielende)).\n\n-   MSG Fehlermeldung\n\n<!-- -->\n\n    <room roomId=\"RID\">\n      <error message=\"MSG\">\n        <originalRequest>\n        Request, der den Fehler verursacht hat\n        </originalRequest>\n      </error>\n    </room>\n","data":{},"elements":["t"]}},{"folder":"book","path":{"directory":"spiele/hase-und-igel/xml-dokumentation","absolute":"/home/runner/work/docs/docs/hyperbook/.hyperbook/book/spiele/hase-und-igel/xml-dokumentation/spiel-betreten.md","relative":"spiele/hase-und-igel/xml-dokumentation/spiel-betreten.md","href":"/spiele/hase-und-igel/xml-dokumentation/spiel-betreten"},"extension":".md","name":"spiel-betreten","root":"/home/runner/work/docs/docs/hyperbook/.hyperbook","markdown":{"content":"# Spiel betreten\n\nWenn begonnen wird mit dem Server zu kommunizieren, muss zuallererst\n\n    <protocol>\n\ngesendet werden, um die Kommunikation zu beginnen.\n\n## Ohne Reservierungscode\n\nBetritt ein beliebiges offenes Spiel:\n\n    <join gameType=\"swc_2018_hase_und_igel\"/>\n\nSollte kein Spiel offen sein, wird so ein neues erstellt. Je nachdem ob\npaused in server.properties true oder false ist, wird das Spiel pausiert\ngestartet oder nicht. Der Server antwortet darauf mit:\n\n-   ROOM\\_ID Id des GameRooms\n\n<!-- -->\n\n    <joined roomId=\"ROOM_ID\"/>\n\nAlle administrativen Clients werden ebenfalls darüber benachrichtigt und\nerhalten folgende Nachricht:\n\n-   ROOM\\_ID Id des GameRooms\n\n<!-- -->\n\n    <joinedGameRoom roomId=\"ROOM_ID\" existing=\"false\"/>\n\nFalls bereits ein GameRoom offen war, ist dementsprechend existing true.\n\n## Mit Reservierungscode\n\nIst ein Reservierungscode gegeben, so kann man den durch den Code\ngegebenen Platz betreten.\n\n### Join mit RC\n\n-   RC Reservierungscode\n\n<!-- -->\n\n    <joinPrepared reservationCode=\"RC\"/>\n\n### Welcome Message\n\nDer Server antwortet darauf nur, wenn der zweite :t[Computerspieler]{#player} ebenfalls\nverbunden ist:\n\n-   ROOM\\_ID Id des GameRooms\n\n-   COLOR Spielerfarbe also red oder blue\n\n-   status GameState wie in [???](#status)\n\n<!-- -->\n\n    <joined roomId=\"ROOM_ID\"/>\n    <room roomId=\"ROOM_ID\">\n      <data class=\"welcomeMessage\" color=\"COLOR\"></data>\n    </room>\n    <room roomId=\"ROOM_ID\">\n      <data class=\"memento\">\n        status\n      </data>\n    </room>\n","data":{},"elements":["t"]}},{"folder":"book","path":{"directory":"spiele/hase-und-igel/xml-dokumentation","absolute":"/home/runner/work/docs/docs/hyperbook/.hyperbook/book/spiele/hase-und-igel/xml-dokumentation/spiel-verlassen.md","relative":"spiele/hase-und-igel/xml-dokumentation/spiel-verlassen.md","href":"/spiele/hase-und-igel/xml-dokumentation/spiel-verlassen"},"extension":".md","name":"spiel-verlassen","root":"/home/runner/work/docs/docs/hyperbook/.hyperbook","markdown":{"content":"# Spiel verlassen\n\nWenn ein :t[Computerspieler]{#player} den Raum verlässt, bekommen die anderen Clients eine\nentsprechende Meldung vom Server.\n\n-   ROOM\\_ID Id des GameRooms\n\n<!-- -->\n\n    <left roomId=\"ROOM_ID\"/>\n","data":{},"elements":["t"]}},{"folder":"book","path":{"directory":"spiele/hase-und-igel/xml-dokumentation","absolute":"/home/runner/work/docs/docs/hyperbook/.hyperbook/book/spiele/hase-und-igel/xml-dokumentation/spielverlauf.md","relative":"spiele/hase-und-igel/xml-dokumentation/spielverlauf.md","href":"/spiele/hase-und-igel/xml-dokumentation/spielverlauf"},"extension":".md","name":"spielverlauf","root":"/home/runner/work/docs/docs/hyperbook/.hyperbook","markdown":{"content":"# Spielverlauf\n\nDer Server startet (StandardIp: localhost 13050).\n\nNun gibt es zwei Varianten ein Spiel zu starten, eine durch einen\nAdministratorclient die andere durch hinzufügen der Spieler zu einen\nSpieltyp:\n\n## Variante 1 (AdminClient [???](#mit-reservierungscode))\n\nEin :t[Computerspieler]{#player} registriert sich als Administrator mit dem in\nserver.properties festgelegten Passwort p:\n\n    <protocol><authenticate passphrase=\"p\"/>\n\nDann kann ein Spiel angelegt werden:\n\n    <prepare gameType=\"swc_2018_hase_und_igel\">\n      <slot displayName=\"p1\" canTimeout=\"false\" shouldBePaused=\"true\"/>\n      <slot displayName=\"p2\" canTimeout=\"false\" shouldBePaused=\"true\"/>\n    </prepare>\n\nDer Server antwortet darauf mit einer Nachricht, die die ROOM\\_ID und\nReservierungscodes für die beiden Clients enthält:\n\n    <protocol>\n      <prepared roomId=\"871faccb-5190-4e44-82fc-6cdcbb493726\">\n        <reservation>RC1</reservation>\n        <reservation>RC2</reservation>\n      </prepared>\n\nDer Administratorclient kann nur ebenfalls als Observer des Spiels\ngenutzt werden, indem ein entsprechender Request gesendet wird. Dadurch\nwird das derzeitge Spielfeld ([???](#memento)) ebenfalls an den\nAdministratorclient gesendet.\n\n    <observe roomId=\"871faccb-5190-4e44-82fc-6cdcbb493726\"/>\n\nClients die auf dem Serverport (localhost 13050) gestartet werden können\nso über diesen Code joinen.\n\n    <protocol>\n      <joinPrepared reservationCode=\"RC1\"/>\n\n    <protocol>\n      <joinPrepared reservationCode=\"RC2\"/>\n\n## Variante 2 ((eventuell) ohne AdminClient [???](#ohne-reservierungscode))\n\nDie Clients wurden auf dem Serverport (Standard: localhost 13050)\ngestartet.\n\nSie können sich mit folgender Anfrage einen bereits offenen Spiel\ngleichen Typs beitreten oder, falls kein Spiel des Typs vorhanden selbst\neines starten:\n\n    <protocol>\n      <join gameType=\"swc_2018_hase_und_igel\"/>\n\nDer Server antwortet mit:\n\n    <protocol>\n      <joined roomId=\"871faccb-5190-4e44-82fc-6cdcbb493726\"/>\n\n## Weiterer Spielverlauf\n\nDer Server antwortet jeweils mit der WelcomeMessage\n([???](#welcome-message)) und dem ersten GameState ([???](#memento))\nsobald beide Spieler verbunden sind.\n\n    <room roomId=\"871faccb-5190-4e44-82fc-6cdcbb493726\">\n      <data class=\"welcomeMessage\" color=\"red\"/>\n    </room>\n    <room roomId=\"871faccb-5190-4e44-82fc-6cdcbb493726\">\n      <data class=\"memento\">\n        <state class=\"state\" turn=\"0\" startPlayer=\"RED\" currentPlayer=\"RED\">\n          <red displayName=\"Unknown\" color=\"RED\" index=\"0\" carrots=\"68\" salads=\"5\">\n            <cards>\n              <type>TAKE_OR_DROP_CARROTS</type>\n              <type>EAT_SALAD</type>\n              <type>HURRY_AHEAD</type>\n              <type>FALL_BACK</type>\n            </cards>\n          </red>\n          <blue displayName=\"Unknown\" color=\"BLUE\" index=\"0\" carrots=\"68\" salads=\"5\">\n            <cards>\n              <type>TAKE_OR_DROP_CARROTS</type>\n              <type>EAT_SALAD</type>\n              <type>HURRY_AHEAD</type>\n              <type>FALL_BACK</type>\n            </cards>\n          </blue>\n          <board>\n            <fields index=\"0\" type=\"START\"/>\n            <fields index=\"1\" type=\"CARROT\"/>\n            <fields index=\"2\" type=\"HARE\"/>\n            <fields index=\"3\" type=\"HARE\"/>\n            <fields index=\"4\" type=\"POSITION_2\"/>\n            <fields index=\"5\" type=\"POSITION_1\"/>\n            <fields index=\"6\" type=\"CARROT\"/>\n            <fields index=\"7\" type=\"CARROT\"/>\n            <fields index=\"8\" type=\"HARE\"/>\n            <fields index=\"9\" type=\"CARROT\"/>\n            <fields index=\"10\" type=\"SALAD\"/>\n            <fields index=\"11\" type=\"HEDGEHOG\"/>\n            <fields index=\"12\" type=\"HARE\"/>\n            <fields index=\"13\" type=\"CARROT\"/>\n            <fields index=\"14\" type=\"CARROT\"/>\n            <fields index=\"15\" type=\"HEDGEHOG\"/>\n            <fields index=\"16\" type=\"POSITION_1\"/>\n            <fields index=\"17\" type=\"CARROT\"/>\n            <fields index=\"18\" type=\"POSITION_2\"/>\n            <fields index=\"19\" type=\"HEDGEHOG\"/>\n            <fields index=\"20\" type=\"CARROT\"/>\n            ...\n            <fields index=\"57\" type=\"SALAD\"/>\n            <fields index=\"58\" type=\"CARROT\"/>\n            <fields index=\"59\" type=\"POSITION_1\"/>\n            <fields index=\"60\" type=\"HARE\"/>\n            <fields index=\"61\" type=\"CARROT\"/>\n            <fields index=\"62\" type=\"HARE\"/>\n            <fields index=\"63\" type=\"CARROT\"/>\n            <fields index=\"64\" type=\"GOAL\"/>\n          </board>\n        </state>\n      </data>\n    </room>\n\nDer erste Spieler erhält dann eine Zugaufforderung\n([???](#move-request)), falls in server.properties paused auf false\ngesetzt wurde. Falls das Spiel pausiert ist, muss das Spiel durch einen\nAdministratorclient gestartet werden:\n\nVerbinden des Administratorclients (falls es sich um die erste\nKontaktaufnahme zum Server handelt, ansonsten &lt;protocol&gt;\nweglassen).\n\n    <protocol>\n      <authenticate passphrase=\"examplepassword\"/>\n\nPausierung aufheben:\n\n    <pause roomId=\"871faccb-5190-4e44-82fc-6cdcbb493726\" pause=\"false\" />\n\nDaraufhin wird der erste Spieler aufgefordert einen Zug zu senden:\n\n    <room roomId=\"871faccb-5190-4e44-82fc-6cdcbb493726\">\n      <data class=\"sc.framework.plugins.protocol.MoveRequest\"/>\n    </room>\n\nDer :t[Computerspieler]{#player} des CurrentPlayer sendet nun einen Zug ([???](#zug)):\n\n    <room roomId=\"871faccb-5190-4e44-82fc-6cdcbb493726\">\n      <data class=\"move\">\n        <advance order=\"0\" distance=\"6\">\n      </data>\n    </room>\n\nSo geht es abwechselnd weiter, bis zum Spielende ([???](#spielende)).\nDie letzte Nachricht des Servers endet mit:\n\n    </protocol>\n\nDanach wird die Verbindung geschlossen.\n","data":{},"elements":["t"]}},{"folder":"book","path":{"directory":"spiele/hase-und-igel/xml-dokumentation","absolute":"/home/runner/work/docs/docs/hyperbook/.hyperbook/book/spiele/hase-und-igel/xml-dokumentation/xml-dokumentation.md","relative":"spiele/hase-und-igel/xml-dokumentation/xml-dokumentation.md","href":"/spiele/hase-und-igel/xml-dokumentation/xml-dokumentation"},"extension":".md","name":"xml-dokumentation","root":"/home/runner/work/docs/docs/hyperbook/.hyperbook","markdown":{"content":"Ziel dieser Dokumentation ist es, die XML-Schnittstelle der\nSoftwarechallenge festzuhalten.\n\n[PDF-Version dieses Dokumentes](xml-dokumentation.pdf)\n\nWir freuen uns über sämtliche Verbesserungsvorschläge. Die Dokumentation\nkann [direkt auf GitHub\neditiert](https://github.com/software-challenge/docs) werden, einzige\nVoraussetzung ist eine kostenlose Registrierung bei GitHub. Ist man\nangemeldet, kann man ein Dokument auswählen (ein guter Startpunkt ist\ndie Datei\n[index.md](https://github.com/software-challenge/docs/blob/master/index.md)\nwelche Verweise auf alle Sektionen der Dokumentation enthält) und dann\nauf den Stift oben rechts klicken. Alternativ auch gern eine E-Mail an\n<tech@software-challenge.de>.\n\n# Einleitung\n\nWie in den letzten Jahren wird zur Computerspieler-Server Kommunikation ein\nXML-Protokoll genutzt. In diesem Dokument wird die\nKommunikationsschnittstelle definiert, sodass ein komplett eigener\n:t[Computerspieler]{#player} geschrieben werden kann. Es wird hier nicht die vollständige\nKommunikation dokumentiert bzw. definiert, dennoch alles, womit ein\n:t[Computerspieler]{#player} umgehen können muss, um spielfähig zu sein.\n\n## An wen richtet sich dieses Dokument?\n\nDie Kommunikation mit dem Spielserver ist für diejenigen, die aufbauend\nauf dem Zufallsspieler programmieren, unwichtig. Dort steht bereits ein\nfunktionierender :t[Computerspieler]{#player} bereit und es muss nur die Spiellogik entworfen\nwerden. \\\\\\\\ Nur wer einen komplett eigenen :t[Computerspieler]{#player} entwerfen will,\nbeispielsweise um die Programmiersprache frei wählen zu können, benötigt\ndie Definitionen.\n\n## Hinweise\n\nFalls Sie beabsichtigen sollten, diese Kommunikationsschnittstelle zu\nrealisieren, sei darauf hingewiesen, dass es im Verlauf des Wettbewerbes\nmöglich ist, dass weitere, hier noch nicht aufgeführte Elemente zur\nKommunikationsschnittstelle hinzugefügt werden. Um auch bei solchen\nÄnderungen sicher zu sein, dass ihr :t[Computerspieler]{#player} fehlerfrei mit dem Server\nkommunizieren kann, empfehlen wir Ihnen, beim Auslesen des :t[XML]{#xml} jegliche\nDaten zu verwerfen, die hier nicht weiter definiert sind. Die vom\nInstitut bereitgestellten Programme (Server, Zufallsspieler) nutzen eine\nBibliothek um Java-Objekte direkt in :t[XML]{#xml} zu konvertieren und umgekehrt.\nDabei werden XML-Nachrichten nicht mit einem newline abgeschlossen.\n\n# Spiel betreten\n\nWenn begonnen wird mit dem Server zu kommunizieren, muss zuallererst\n\n    <protocol>\n\ngesendet werden, um die Kommunikation zu beginnen.\n\n## Ohne Reservierungscode\n\nBetritt ein beliebiges offenes Spiel:\n\n    <join gameType=\"swc_2018_hase_und_igel\"/>\n\nSollte kein Spiel offen sein, wird so ein neues erstellt. Je nachdem ob\npaused in server.properties true oder false ist, wird das Spiel pausiert\ngestartet oder nicht. Der Server antwortet darauf mit:\n\n-   ROOM\\_ID Id des GameRooms\n\n<!-- -->\n\n    <joined roomId=\"ROOM_ID\"/>\n\nAlle administrativen Clients werden ebenfalls darüber benachrichtigt und\nerhalten folgende Nachricht:\n\n-   ROOM\\_ID Id des GameRooms\n\n<!-- -->\n\n    <joinedGameRoom roomId=\"ROOM_ID\" existing=\"false\"/>\n\nFalls bereits ein GameRoom offen war, ist dementsprechend existing true.\n\n## Mit Reservierungscode\n\nIst ein Reservierungscode gegeben, so kann man den durch den Code\ngegebenen Platz betreten.\n\n### Join mit RC\n\n-   RC Reservierungscode\n\n<!-- -->\n\n    <joinPrepared reservationCode=\"RC\"/>\n\n### Welcome Message\n\nDer Server antwortet darauf nur, wenn der zweite :t[Computerspieler]{#player} ebenfalls\nverbunden ist:\n\n-   ROOM\\_ID Id des GameRooms\n\n-   COLOR Spielerfarbe also red oder blue\n\n-   status GameState wie in [Status](#status)\n\n<!-- -->\n\n    <joined roomId=\"ROOM_ID\"/>\n    <room roomId=\"ROOM_ID\">\n      <data class=\"welcomeMessage\" color=\"COLOR\"></data>\n    </room>\n    <room roomId=\"ROOM_ID\">\n      <data class=\"memento\">\n        status\n      </data>\n    </room>\n\n# Züge senden\n\n## Der Move\n\nDer Move ist die Antwort auf den MoveRequest des Servers.\n\n### MoveRequest\n\n-   ROOM\\_ID Id des GameRooms\n\n<!-- -->\n\n    <room roomId=\"ROOM_ID\">\n      <data class=\"sc.framework.plugins.protocol.MoveRequest\"/>\n    </room>\n\n### Senden\n\nDer Move ist der allgemeine Zug, der in verschiedenen Varianten gesendet\nwerden kann.\n\n-   ROOM\\_ID Id des GameRooms\n\n-   ZUG Zug wie in [ZUG](#zug)\n\n<!-- -->\n\n    <room roomId=\"ROOM_ID\">\n      ZUG\n    </room>\n\n## ZUG\n\n-   ACTION Aktionen wie in [ACTION](#action)\n\n<!-- -->\n\n    <data class=\"move\">\n      ACTION\n      ..\n      ACTION\n    </move>\n\n## ACTION\n\nMögliche Aktionen:\n\n-   I Index der Aktion beginnend mit 0\n\n-   D Anzahl der Felder um die sich bewegt wird\n\n-   W -10 oder 10\n\n-   V 20,0,-20 falls type TAKE\\_OR\\_DROP\\_CARROTS, 0 sonst\n\n<!-- -->\n\n    <advance order=\"I\" distance=\"D\"/>\n    <card order=\"I\" type=\"CARD_TYPE\" value=\"V\"/>\n    <exchangeCarrots order=\"I\" value=\"W\"/>\n    <eatSalad order=\"I\"/>\n    <fallBack order=\"I\"/>\n    <skip order=\"I\"/>\n\n## Debughints\n\nZügen können Debug-Informationen beigefügt werden:\n\n    <hint content=\"S\"/>\n\nDamit sieht beispielsweise ein Laufzug so aus:\n\n    <room roomId=\"ROOM_ID\">\n      <data class=\"move\">\n        <advance order=\"0\" distance=\"1\"/>\n        <card order=\"1\" type=\"EAT_SALAD\" value=\"0\"/>\n        <hint content=\"Dies ist ein Hint.\"/>\n        <hint content=\"noch ein Hint\"/>\n      </data>\n    </room>\n\n# Spielstatus\n\nEs folgt die Beschreibung des Spielstatus, der vor jeder Zugaufforderung\nan die Clients gesendet wird. Das Spielstatus-Tag ist dabei noch in\neinem *data*-Tag der Klasse *memento* gewrappt:\n\n## memento\n\n-   ROOM\\_ID Id des GameRooms\n\n-   status Gamestate wie in [Status](#status)\n\n<!-- -->\n\n    <room roomId=\"ROOM_ID\">\n      <data class=\"memento\">\n        status\n      </data>\n    </room>\n\n## Status\n\n-   Z aktuelle Zugzahl\n\n-   S Spieler, der das Spiel gestartet hat (RED/BLUE)\n\n-   C Spieler, der an der Reihe ist (RED/BLUE)\n\n-   red, blue wie in [Spieler](#spieler) definiert\n\n-   board Das Spielbrett, wie in [Spielbrett](#spielbrett) definiert\n\n-   lastMove Letzter getätigter Zug (nicht in der ersten Runde), wie in\n    [Letzter Zug](#letzter-zug) definiert\n\n-   condition Spielergebnis, wie in [Spielergebnis](#spielende)\n    definiert; nur zum Spielende\n\n<!-- -->\n\n    <state class=\"state\" turn=\"Z\" startPlayer=\"S\" currentPlayer=\"C\">\n      red\n      blue\n      [board]\n      [lastMove]\n      [condition]\n    </state>\n\n## Spieler\n\n-   C Farbe (red/blue)\n\n-   N Anzeigename\n\n-   I Feldindex des Spielers\n\n-   S Anzahl Salate\n\n-   K Anzahl der Karotten\n\n<!-- -->\n\n    <C displayName=\"N\" color=\"C\" index=\"I\" carrots=\"K\" salads=\"S\">\n      <cards>\n        <type>TAKE_OR_DROP_CARROTS</type>\n        <type>EAT_SALAD</type>\n        <type>HURRY_AHEAD</type>\n        <type>FALL_BACK</type>\n      </cards>\n      <lastNonSkipAction class=\"fallBack\" order=\"0\"/> // Beispiel für letzte Aktion\n    </C>\n\n## Spielbrett\n\n-   FIELD Ein Spielfeld wie in [Spielfeld](#spielfeld) definiert.\n\n<!-- -->\n\n    <board>\n      <fields index=\"0\" type=\"START\"/>\n      ..\n      FIELD\n      ..\n      <fields index=\"64\" type=\"GOAL\"/>\n    </board>\n\n## Spielfeld\n\n-   I Feldnummer\n\n-   TYPE Typ des Feldes\n    (START/CARROT/HARE/GOAL/POSITION\\_{X}/HEDGEHOG/SALAD). X ist 1 oder\n    2\n\n<!-- -->\n\n    <fields index=\"I\" type=\"TYPE\"/>\n\n## Letzter Zug\n\nDer letzte Zug ist ein Move (siehe hierzu [ZUG](#zug)).\n\n-   ACTIONS Teilzüge des Zuges (siehe hierzu [ACTION](#action)).\n\n<!-- -->\n\n    <lastMove>\n      ACTIONS\n    </lastMove>\n\n# Zug-Anforderung\n\nEine einfache Nachricht fordert zum Zug auf:\n\n    <room roomId=\"RID\">\n      <data class=\"sc.framework.plugins.protocol.MoveRequest\"/>\n    </room>\n\n# Fehler\n\nEin “spielfähiger” :t[Computerspieler]{#player} muss nicht mit Fehlern umgehen können.\nFehlerhafte Züge beispielsweise resultieren in einem vorzeitigen Ende\ndes Spieles, das im nächsten gesendeten Gamestate erkannt werden kann\n(siehe [Spielergebnis](#spielende)).\n\n-   MSG Fehlermeldung\n\n<!-- -->\n\n    <room roomId=\"RID\">\n      <error message=\"MSG\">\n        <originalRequest>\n        Request, der den Fehler verursacht hat\n        </originalRequest>\n      </error>\n    </room>\n\n# Spiel verlassen\n\nWenn ein :t[Computerspieler]{#player} den Raum verlässt, bekommen die anderen Clients eine\nentsprechende Meldung vom Server.\n\n-   ROOM\\_ID Id des GameRooms\n\n<!-- -->\n\n    <left roomId=\"ROOM_ID\"/>\n\n# Spielergebnis\n\nZum Spielende enthält der Spieler das Ergebnis:\n\n-   ROOM\\_ID Id des GameRooms\n\n-   R1, R2 Text, der den Grund für das Spielende erklärt\n\n-   CAUSE1, CAUSE2 Grund des Spielendes\n    (REGULAR/LEFT/RULE\\_VIOLATION/SOFT\\_TIMEOUT/HARD\\_TIMEOUT)\n\n-   WP1, WP2 Siegpunkte der jeweiligen Spieler, 0 verloren, 1\n    unentschieden, 2 gewonnen\n\n-   I1, I2 Index des Feldes auf dem der Spieler steht\n\n-   C1, C2 Karotten des Spielers\n\n-   NAME Anzeigename des Spielers\n\n-   COLOR Farbe des Siegers\n\n-   I3 I1 oder I2 je nachdem wer gewonnen hat\n\n-   C3 C1 oder C2 je nachdem wer gewonnen hat\n\n-   S Salate des Siegers\n\n-   \\[cards\\] Karten des Siegers wie in [Spieler](#spieler)\n\n-   \\[lastNonSkipAction\\] Letztes Aktion des Siegers wie in\n    [Spieler](#spieler)\n\n<!-- -->\n\n    <room roomId=\"ROOM_ID\">\n      <data class=\"result\">\n        <definition>\n          <fragment name=\"Gewinner\">\n            <aggregation>SUM</aggregation>\n            <relevantForRanking>true</relevantForRanking>\n          </fragment>\n          <fragment name=\"Ø Feldnummer\">\n            <aggregation>AVERAGE</aggregation>\n            <relevantForRanking>true</relevantForRanking>\n          </fragment>\n          <fragment name=\"Ø Karotten\">\n            <aggregation>AVERAGE</aggregation>\n            <relevantForRanking>true</relevantForRanking>\n          </fragment>\n        </definition>\n        <score cause=\"CAUSE1\" reason=\"R1\">\n          <part>WP1</part>\n          <part>I1</part>\n          <part>C1</part>\n        </score>\n        <score cause=\"CAUSE2\" reason=\"R2\">\n          <part>WP2</part>\n          <part>I2</part>\n          <part>C1</part>\n        </score>\n        <winner class=\"player\" displayName=\"NAME\" color=\"COLOR\" index=\"I3\" carrots=\"C3\" salads=\"S\">\n          [cards]\n          [lastNonSkipAction]\n        </winner>\n      </data>\n    </room>\n\n# Spielverlauf\n\nDer Server startet (StandardIp: localhost 13050).\n\nNun gibt es zwei Varianten ein Spiel zu starten, eine durch einen\nAdministratorclient die andere durch hinzufügen der Spieler zu einen\nSpieltyp:\n\n## Variante 1 (AdminClient [Mit Reservierungscode](#mit-reservierungscode))\n\nEin :t[Computerspieler]{#player} registriert sich als Administrator mit dem in\nserver.properties festgelegten Passwort p:\n\n    <protocol><authenticate passphrase=\"p\"/>\n\nDann kann ein Spiel angelegt werden:\n\n    <prepare gameType=\"swc_2018_hase_und_igel\">\n      <slot displayName=\"p1\" canTimeout=\"false\" shouldBePaused=\"true\"/>\n      <slot displayName=\"p2\" canTimeout=\"false\" shouldBePaused=\"true\"/>\n    </prepare>\n\nDer Server antwortet darauf mit einer Nachricht, die die ROOM\\_ID und\nReservierungscodes für die beiden Clients enthält:\n\n    <protocol>\n      <prepared roomId=\"871faccb-5190-4e44-82fc-6cdcbb493726\">\n        <reservation>RC1</reservation>\n        <reservation>RC2</reservation>\n      </prepared>\n\nDer Administratorclient kann nur ebenfalls als Observer des Spiels\ngenutzt werden, indem ein entsprechender Request gesendet wird. Dadurch\nwird das derzeitge Spielfeld ([memento](#memento)) ebenfalls an den\nAdministratorclient gesendet.\n\n    <observe roomId=\"871faccb-5190-4e44-82fc-6cdcbb493726\"/>\n\nClients die auf dem Serverport (localhost 13050) gestartet werden können\nso über diesen Code joinen.\n\n    <protocol>\n      <joinPrepared reservationCode=\"RC1\"/>\n\n    <protocol>\n      <joinPrepared reservationCode=\"RC2\"/>\n\n## Variante 2 ((eventuell) ohne AdminClient [Ohne Reservierungscode](#ohne-reservierungscode))\n\nDie Clients wurden auf dem Serverport (Standard: localhost 13050)\ngestartet.\n\nSie können sich mit folgender Anfrage einen bereits offenen Spiel\ngleichen Typs beitreten oder, falls kein Spiel des Typs vorhanden selbst\neines starten:\n\n    <protocol>\n      <join gameType=\"swc_2018_hase_und_igel\"/>\n\nDer Server antwortet mit:\n\n    <protocol>\n      <joined roomId=\"871faccb-5190-4e44-82fc-6cdcbb493726\"/>\n\n## Weiterer Spielverlauf\n\nDer Server antwortet jeweils mit der WelcomeMessage ([Welcome\nMessage](#welcome-message)) und dem ersten GameState\n([memento](#memento)) sobald beide Spieler verbunden sind.\n\n    <room roomId=\"871faccb-5190-4e44-82fc-6cdcbb493726\">\n      <data class=\"welcomeMessage\" color=\"red\"/>\n    </room>\n    <room roomId=\"871faccb-5190-4e44-82fc-6cdcbb493726\">\n      <data class=\"memento\">\n        <state class=\"state\" turn=\"0\" startPlayer=\"RED\" currentPlayer=\"RED\">\n          <red displayName=\"Unknown\" color=\"RED\" index=\"0\" carrots=\"68\" salads=\"5\">\n            <cards>\n              <type>TAKE_OR_DROP_CARROTS</type>\n              <type>EAT_SALAD</type>\n              <type>HURRY_AHEAD</type>\n              <type>FALL_BACK</type>\n            </cards>\n          </red>\n          <blue displayName=\"Unknown\" color=\"BLUE\" index=\"0\" carrots=\"68\" salads=\"5\">\n            <cards>\n              <type>TAKE_OR_DROP_CARROTS</type>\n              <type>EAT_SALAD</type>\n              <type>HURRY_AHEAD</type>\n              <type>FALL_BACK</type>\n            </cards>\n          </blue>\n          <board>\n            <fields index=\"0\" type=\"START\"/>\n            <fields index=\"1\" type=\"CARROT\"/>\n            <fields index=\"2\" type=\"HARE\"/>\n            <fields index=\"3\" type=\"HARE\"/>\n            <fields index=\"4\" type=\"POSITION_2\"/>\n            <fields index=\"5\" type=\"POSITION_1\"/>\n            <fields index=\"6\" type=\"CARROT\"/>\n            <fields index=\"7\" type=\"CARROT\"/>\n            <fields index=\"8\" type=\"HARE\"/>\n            <fields index=\"9\" type=\"CARROT\"/>\n            <fields index=\"10\" type=\"SALAD\"/>\n            <fields index=\"11\" type=\"HEDGEHOG\"/>\n            <fields index=\"12\" type=\"HARE\"/>\n            <fields index=\"13\" type=\"CARROT\"/>\n            <fields index=\"14\" type=\"CARROT\"/>\n            <fields index=\"15\" type=\"HEDGEHOG\"/>\n            <fields index=\"16\" type=\"POSITION_1\"/>\n            <fields index=\"17\" type=\"CARROT\"/>\n            <fields index=\"18\" type=\"POSITION_2\"/>\n            <fields index=\"19\" type=\"HEDGEHOG\"/>\n            <fields index=\"20\" type=\"CARROT\"/>\n            ...\n            <fields index=\"57\" type=\"SALAD\"/>\n            <fields index=\"58\" type=\"CARROT\"/>\n            <fields index=\"59\" type=\"POSITION_1\"/>\n            <fields index=\"60\" type=\"HARE\"/>\n            <fields index=\"61\" type=\"CARROT\"/>\n            <fields index=\"62\" type=\"HARE\"/>\n            <fields index=\"63\" type=\"CARROT\"/>\n            <fields index=\"64\" type=\"GOAL\"/>\n          </board>\n        </state>\n      </data>\n    </room>\n\nDer erste Spieler erhält dann eine Zugaufforderung\n([MoveRequest](#move-request)), falls in server.properties paused auf\nfalse gesetzt wurde. Falls das Spiel pausiert ist, muss das Spiel durch\neinen Administratorclient gestartet werden:\n\nVerbinden des Administratorclients (falls es sich um die erste\nKontaktaufnahme zum Server handelt, ansonsten &lt;protocol&gt;\nweglassen).\n\n    <protocol>\n      <authenticate passphrase=\"examplepassword\"/>\n\nPausierung aufheben:\n\n    <pause roomId=\"871faccb-5190-4e44-82fc-6cdcbb493726\" pause=\"false\" />\n\nDaraufhin wird der erste Spieler aufgefordert einen Zug zu senden:\n\n    <room roomId=\"871faccb-5190-4e44-82fc-6cdcbb493726\">\n      <data class=\"sc.framework.plugins.protocol.MoveRequest\"/>\n    </room>\n\nDer :t[Computerspieler]{#player} des CurrentPlayer sendet nun einen Zug ([ZUG](#zug)):\n\n    <room roomId=\"871faccb-5190-4e44-82fc-6cdcbb493726\">\n      <data class=\"move\">\n        <advance order=\"0\" distance=\"6\">\n      </data>\n    </room>\n\nSo geht es abwechselnd weiter, bis zum Spielende\n([Spielergebnis](#spielende)). Die letzte Nachricht des Servers endet\nmit:\n\n    </protocol>\n\nDanach wird die Verbindung geschlossen.\n","data":{},"elements":["t"]}},{"folder":"book","path":{"directory":"spiele/hive/xml-dokumentation","absolute":"/home/runner/work/docs/docs/hyperbook/.hyperbook/book/spiele/hive/xml-dokumentation/einleitung-xml.md","relative":"spiele/hive/xml-dokumentation/einleitung-xml.md","href":"/spiele/hive/xml-dokumentation/einleitung-xml"},"extension":".md","name":"einleitung-xml","root":"/home/runner/work/docs/docs/hyperbook/.hyperbook","markdown":{"content":"# Einleitung\n\nWie in den letzten Jahren wird zur Computerspieler-Server Kommunikation ein\nXML-Protokoll genutzt. In diesem Dokument wird die\nKommunikationsschnittstelle definiert, sodass ein komplett eigener\n:t[Computerspieler]{#player} geschrieben werden kann. Es wird hier nicht die vollständige\nKommunikation dokumentiert bzw. definiert, dennoch alles, womit ein\n:t[Computerspieler]{#player} umgehen können muss, um spielfähig zu sein.\n\n## An wen richtet sich dieses Dokument?\n\nDie Kommunikation mit dem Spielserver ist für diejenigen, die aufbauend\nauf dem Zufallsspieler programmieren, unwichtig. Dort steht bereits ein\nfunktionierender :t[Computerspieler]{#player} bereit und es muss nur die Spiellogik entworfen\nwerden. Nur wer einen komplett eigenen :t[Computerspieler]{#player} entwerfen will,\nbeispielsweise um die Programmiersprache frei wählen zu können, benötigt\ndie Definitionen.\n\n## Hinweise\n\nFalls Sie beabsichtigen sollten, diese Kommunikationsschnittstelle zu\nrealisieren, sei darauf hingewiesen, dass es im Verlauf des Wettbewerbes\nmöglich ist, dass weitere, hier noch nicht aufgeführte Elemente zur\nKommunikationsschnittstelle hinzugefügt werden. Um auch bei solchen\nÄnderungen sicher zu sein, dass ihr :t[Computerspieler]{#player} fehlerfrei mit dem Server\nkommunizieren kann, empfehlen wir Ihnen, beim Auslesen des :t[XML]{#xml} jegliche\nDaten zu verwerfen, die hier nicht weiter definiert sind. Die vom\nInstitut bereitgestellten Programme (Server, Zufallsspieler) nutzen eine\nBibliothek um Java-Objekte direkt in :t[XML]{#xml} zu konvertieren und umgekehrt.\nDabei werden XML-Nachrichten nicht mit einem newline abgeschlossen.\n","data":{},"elements":["t"]}},{"folder":"book","path":{"directory":"spiele/hive/xml-dokumentation","absolute":"/home/runner/work/docs/docs/hyperbook/.hyperbook/book/spiele/hive/xml-dokumentation/fehler.md","relative":"spiele/hive/xml-dokumentation/fehler.md","href":"/spiele/hive/xml-dokumentation/fehler"},"extension":".md","name":"fehler","root":"/home/runner/work/docs/docs/hyperbook/.hyperbook","markdown":{"content":"# Fehler\n\nEin “spielfähiger” :t[Computerspieler]{#player} muss nicht mit Fehlern umgehen können.\nFehlerhafte Züge beispielsweise resultieren in einem vorzeitigen Ende\ndes Spieles, das im nächsten gesendeten Gamestate erkannt werden kann\n(siehe [???](#spielende)).\n\n-   MSG Fehlermeldung\n\n<!-- -->\n\n    <room roomId=\"RID\">\n      <error message=\"MSG\">\n        <originalRequest>\n          Request, der den Fehler verursacht hat\n        </originalRequest>\n      </error>\n    </room>\n","data":{},"elements":["t"]}},{"folder":"book","path":{"directory":"spiele/hive/xml-dokumentation","absolute":"/home/runner/work/docs/docs/hyperbook/.hyperbook/book/spiele/hive/xml-dokumentation/spiel-betreten.md","relative":"spiele/hive/xml-dokumentation/spiel-betreten.md","href":"/spiele/hive/xml-dokumentation/spiel-betreten"},"extension":".md","name":"spiel-betreten","root":"/home/runner/work/docs/docs/hyperbook/.hyperbook","markdown":{"content":"# Spiel betreten\n\nWenn begonnen wird mit dem Server zu kommunizieren, muss zuallererst\n\n    <protocol>\n\ngesendet werden, um die Kommunikation zu beginnen.\n\n## Ohne Reservierungscode\n\nBetritt ein beliebiges offenes Spiel:\n\n    <join gameType=\"swc_2019_piranhas\" />\n\nSollte kein Spiel offen sein, wird so ein neues erstellt. Je nachdem ob\npaused in server.properties true oder false ist, wird das Spiel pausiert\ngestartet oder nicht. Der Server antwortet darauf mit:\n\n-   ROOM\\_ID Id des GameRooms\n\n<!-- -->\n\n    <joined roomId=\"ROOM_ID\" />\n\nAlle administrativen Clients werden ebenfalls darüber benachrichtigt und\nerhalten folgende Nachricht:\n\n-   ROOM\\_ID Id des GameRooms\n\n<!-- -->\n\n    <joinedGameRoom roomId=\"ROOM_ID\" existing=\"false\" />\n\nFalls bereits ein GameRoom offen war, ist dementsprechend existing true.\n\n## Mit Reservierungscode\n\nIst ein Reservierungscode gegeben, so kann man den durch den Code\ngegebenen Platz betreten.\n\n### Join mit RC\n\n-   RC Reservierungscode\n\n<!-- -->\n\n    <joinPrepared reservationCode=\"RC\" />\n\n### Welcome Message\n\nDer Server antwortet darauf nur, wenn der zweite :t[Computerspieler]{#player} ebenfalls\nverbunden ist:\n\n-   ROOM\\_ID Id des GameRooms\n\n-   COLOR Spielerfarbe also red oder blue\n\n-   STATUS GameState wie in [???](#status)\n\n<!-- -->\n\n    <joined roomId=\"ROOM_ID\" />\n    <room roomId=\"ROOM_ID\">\n      <data class=\"welcomeMessage\" color=\"COLOR\"></data>\n    </room>\n    <room roomId=\"ROOM_ID\">\n      <data class=\"memento\">\n        STATUS\n      </data>\n    </room>\n","data":{},"elements":["t"]}},{"folder":"book","path":{"directory":"spiele/hive/xml-dokumentation","absolute":"/home/runner/work/docs/docs/hyperbook/.hyperbook/book/spiele/hive/xml-dokumentation/spiel-verlassen.md","relative":"spiele/hive/xml-dokumentation/spiel-verlassen.md","href":"/spiele/hive/xml-dokumentation/spiel-verlassen"},"extension":".md","name":"spiel-verlassen","root":"/home/runner/work/docs/docs/hyperbook/.hyperbook","markdown":{"content":"# Spiel verlassen\n\nWenn ein :t[Computerspieler]{#player} den Raum verlässt, bekommen die anderen Clients eine\nentsprechende Meldung vom Server.\n\n-   ROOM\\_ID Id des GameRooms\n\n<!-- -->\n\n    <left roomId=\"ROOM_ID\" />\n","data":{},"elements":["t"]}},{"folder":"book","path":{"directory":"spiele/hive/xml-dokumentation","absolute":"/home/runner/work/docs/docs/hyperbook/.hyperbook/book/spiele/hive/xml-dokumentation/spielverlauf.md","relative":"spiele/hive/xml-dokumentation/spielverlauf.md","href":"/spiele/hive/xml-dokumentation/spielverlauf"},"extension":".md","name":"spielverlauf","root":"/home/runner/work/docs/docs/hyperbook/.hyperbook","markdown":{"content":"# Spielverlauf\n\nDer Server startet (StandardIp: localhost 13050).\n\nNun gibt es zwei Varianten ein Spiel zu starten, eine durch einen\nAdministratorclient die andere durch hinzufügen der Spieler zu einen\nSpieltyp:\n\n## Variante 1 (AdminClient [???](#mit-reservierungscode))\n\nEin :t[Computerspieler]{#player} registriert sich als Administrator mit dem in\nserver.properties festgelegten Passwort p:\n\n    <protocol><authenticate password=\"p\" />\n\nDann kann ein Spiel angelegt werden:\n\n    <prepare gameType=\"swc_2019_piranhas\">\n      <slot displayName=\"p1\" canTimeout=\"false\" shouldBePaused=\"true\" />\n      <slot displayName=\"p2\" canTimeout=\"false\" shouldBePaused=\"true\" />\n    </prepare>\n\nDer Server antwortet darauf mit einer Nachricht, die die ROOM\\_ID und\nReservierungscodes für die beiden Clients enthält:\n\n    <protocol>\n      <prepared roomId=\"871faccb-5190-4e44-82fc-6cdcbb493726\">\n        <reservation>RC1</reservation>\n        <reservation>RC2</reservation>\n      </prepared>\n\nDer Administratorclient kann nur ebenfalls als Observer des Spiels\ngenutzt werden, indem ein entsprechender Request gesendet wird. Dadurch\nwird das derzeitge Spielfeld ([???](#memento)) ebenfalls an den\nAdministratorclient gesendet.\n\n    <observe roomId=\"871faccb-5190-4e44-82fc-6cdcbb493726\" />\n\nClients die auf dem Serverport (localhost 13050) gestartet werden können\nso über diesen Code joinen.\n\n    <protocol>\n      <joinPrepared reservationCode=\"RC1\" />\n\n    <protocol>\n      <joinPrepared reservationCode=\"RC2\" />\n\n## Variante 2 ((eventuell) ohne AdminClient [???](#ohne-reservierungscode))\n\nDie Clients wurden auf dem Serverport (Standard: localhost 13050)\ngestartet.\n\nSie können sich mit folgender Anfrage einen bereits offenen Spiel\ngleichen Typs beitreten oder, falls kein Spiel des Typs vorhanden selbst\neines starten:\n\n    <protocol>\n      <join gameType=\"swc_2019_piranhas\" />\n\nDer Server antwortet mit:\n\n    <protocol>\n      <joined roomId=\"871faccb-5190-4e44-82fc-6cdcbb493726\" />\n\n## Weiterer Spielverlauf\n\nDer Server antwortet jeweils mit der WelcomeMessage\n([???](#welcome-message)) und dem ersten GameState ([???](#memento))\nsobald beide Spieler verbunden sind.\n\n    <room roomId=\"871faccb-5190-4e44-82fc-6cdcbb493726\">\n      <data class=\"welcomeMessage\" color=\"red\" />\n    </room>\n    <room roomId=\"871faccb-5190-4e44-82fc-6cdcbb493726\">\n      <data class=\"memento\">\n        <state class=\"state\" startPlayerColor=\"RED\" currentPlayerColor=\"RED\" turn=\"0\">\n          <red displayName=\"Red\" color=\"RED\"/>\n          <blue displayName=\"Blue\" color=\"BLUE\"/>\n          <board>\n            <fields>\n              <null/>\n              <null/>\n              <null/>\n              <null/>\n              <null/>\n              <field x=\"-5\" y=\"0\" z=\"5\" isObstructed=\"false\"/>\n              <field x=\"-5\" y=\"1\" z=\"4\" isObstructed=\"false\"/>\n              <field x=\"-5\" y=\"2\" z=\"3\" isObstructed=\"false\"/>\n              <field x=\"-5\" y=\"3\" z=\"2\" isObstructed=\"false\"/>\n              <field x=\"-5\" y=\"4\" z=\"1\" isObstructed=\"false\"/>\n              <field x=\"-5\" y=\"5\" z=\"0\" isObstructed=\"false\"/>\n            </fields>\n            <fields>\n              <null/>\n              <null/>\n              <null/>\n              <null/>\n              <field x=\"-4\" y=\"-1\" z=\"5\" isObstructed=\"false\"/>\n              <field x=\"-4\" y=\"0\" z=\"4\" isObstructed=\"false\"/>\n            </fields>\n            ...\n            <fields>\n            ...\n            </fields>\n          </board>\n        </state>\n      </data>\n    </room>\n\nDer erste Spieler erhält dann eine Zugaufforderung\n([???](#move-request)), falls in server.properties paused auf false\ngesetzt wurde. Falls das Spiel pausiert ist, muss das Spiel durch einen\nAdministratorclient gestartet werden:\n\nVerbinden des Administratorclients (falls es sich um die erste\nKontaktaufnahme zum Server handelt, ansonsten &lt;protocol&gt;\nweglassen).\n\n    <protocol>\n      <authenticate password=\"examplepassword\" />\n\nPausierung aufheben:\n\n    <pause roomId=\"871faccb-5190-4e44-82fc-6cdcbb493726\" pause=\"false\" />\n\nDaraufhin wird der erste Spieler aufgefordert einen Zug zu senden:\n\n    <room roomId=\"871faccb-5190-4e44-82fc-6cdcbb493726\">\n      <data class=\"sc.framework.plugins.protocol.MoveRequest\" />\n    </room>\n\nDer :t[Computerspieler]{#player} des CurrentPlayer sendet nun einen Zug ([???](#zug)):\n\n    <room roomId=\"871faccb-5190-4e44-82fc-6cdcbb493726\">\n      <data class=\"setmove\">\n        <piece owner=\"RED\" type=\"BEETLE\" />\n        <destination x=\"-2\" y=\"0\" z=\"2\"/>\n      </data>\n    </room>\n\nSo geht es abwechselnd weiter, bis zum Spielende ([???](#spielende)).\nDie letzte Nachricht des Servers endet mit:\n\n    </protocol>\n\nDanach wird die Verbindung geschlossen.\n","data":{},"elements":["t"]}},{"folder":"book","path":{"directory":"spiele/hive/xml-dokumentation","absolute":"/home/runner/work/docs/docs/hyperbook/.hyperbook/book/spiele/hive/xml-dokumentation/xml-dokumentation.md","relative":"spiele/hive/xml-dokumentation/xml-dokumentation.md","href":"/spiele/hive/xml-dokumentation/xml-dokumentation"},"extension":".md","name":"xml-dokumentation","root":"/home/runner/work/docs/docs/hyperbook/.hyperbook","markdown":{"content":"Ziel dieser Dokumentation ist es, die XML-Schnittstelle der\nSoftwarechallenge festzuhalten.\n\n[PDF-Version dieses Dokumentes](xml-dokumentation.pdf)\n\nWir freuen uns über sämtliche Verbesserungsvorschläge. Die Dokumentation\nkann [direkt auf GitHub\neditiert](https://github.com/software-challenge/docs) werden, einzige\nVoraussetzung ist eine kostenlose Registrierung bei GitHub. Ist man\nangemeldet, kann man ein Dokument auswählen (ein guter Startpunkt ist\ndie Datei\n[index.md](https://github.com/software-challenge/docs/blob/master/index.md)\nwelche Verweise auf alle Sektionen der Dokumentation enthält) und dann\nauf den Stift oben rechts klicken. Alternativ auch gern eine E-Mail an\n<tech@software-challenge.de>.\n\n# Einleitung\n\nWie in den letzten Jahren wird zur Computerspieler-Server Kommunikation ein\nXML-Protokoll genutzt. In diesem Dokument wird die\nKommunikationsschnittstelle definiert, sodass ein komplett eigener\n:t[Computerspieler]{#player} geschrieben werden kann. Es wird hier nicht die vollständige\nKommunikation dokumentiert bzw. definiert, dennoch alles, womit ein\n:t[Computerspieler]{#player} umgehen können muss, um spielfähig zu sein.\n\n## An wen richtet sich dieses Dokument?\n\nDie Kommunikation mit dem Spielserver ist für diejenigen, die aufbauend\nauf dem Zufallsspieler programmieren, unwichtig. Dort steht bereits ein\nfunktionierender :t[Computerspieler]{#player} bereit und es muss nur die Spiellogik entworfen\nwerden. Nur wer einen komplett eigenen :t[Computerspieler]{#player} entwerfen will,\nbeispielsweise um die Programmiersprache frei wählen zu können, benötigt\ndie Definitionen.\n\n## Hinweise\n\nFalls Sie beabsichtigen sollten, diese Kommunikationsschnittstelle zu\nrealisieren, sei darauf hingewiesen, dass es im Verlauf des Wettbewerbes\nmöglich ist, dass weitere, hier noch nicht aufgeführte Elemente zur\nKommunikationsschnittstelle hinzugefügt werden. Um auch bei solchen\nÄnderungen sicher zu sein, dass ihr :t[Computerspieler]{#player} fehlerfrei mit dem Server\nkommunizieren kann, empfehlen wir Ihnen, beim Auslesen des :t[XML]{#xml} jegliche\nDaten zu verwerfen, die hier nicht weiter definiert sind. Die vom\nInstitut bereitgestellten Programme (Server, Zufallsspieler) nutzen eine\nBibliothek um Java-Objekte direkt in :t[XML]{#xml} zu konvertieren und umgekehrt.\nDabei werden XML-Nachrichten nicht mit einem newline abgeschlossen. ==\nSpiel betreten Wenn begonnen wird mit dem Server zu kommunizieren, muss\nzuallererst\n\n    <protocol>\n\ngesendet werden, um die Kommunikation zu beginnen.\n\n## Ohne Reservierungscode\n\nBetritt ein beliebiges offenes Spiel:\n\n    <join gameType=\"swc_2019_piranhas\" />\n\nSollte kein Spiel offen sein, wird so ein neues erstellt. Je nachdem ob\npaused in server.properties true oder false ist, wird das Spiel pausiert\ngestartet oder nicht. Der Server antwortet darauf mit:\n\n-   ROOM\\_ID Id des GameRooms\n\n<!-- -->\n\n    <joined roomId=\"ROOM_ID\" />\n\nAlle administrativen Clients werden ebenfalls darüber benachrichtigt und\nerhalten folgende Nachricht:\n\n-   ROOM\\_ID Id des GameRooms\n\n<!-- -->\n\n    <joinedGameRoom roomId=\"ROOM_ID\" existing=\"false\" />\n\nFalls bereits ein GameRoom offen war, ist dementsprechend existing true.\n\n## Mit Reservierungscode\n\nIst ein Reservierungscode gegeben, so kann man den durch den Code\ngegebenen Platz betreten.\n\n### Join mit RC\n\n-   RC Reservierungscode\n\n<!-- -->\n\n    <joinPrepared reservationCode=\"RC\" />\n\n### Welcome Message\n\nDer Server antwortet darauf nur, wenn der zweite :t[Computerspieler]{#player} ebenfalls\nverbunden ist:\n\n-   ROOM\\_ID Id des GameRooms\n\n-   COLOR Spielerfarbe also red oder blue\n\n-   STATUS GameState wie in [Status](#status)\n\n<!-- -->\n\n    <joined roomId=\"ROOM_ID\" />\n    <room roomId=\"ROOM_ID\">\n      <data class=\"welcomeMessage\" color=\"COLOR\"></data>\n    </room>\n    <room roomId=\"ROOM_ID\">\n      <data class=\"memento\">\n        STATUS\n      </data>\n    </room>\n\n# Züge senden\n\n## Der Move\n\nDer Move ist die Antwort auf den MoveRequest des Servers.\n\n### MoveRequest\n\n`ROOM_ID`  \nID des GameRooms, dient der Zuordnung der Antworten des Clients.\n\n<!-- -->\n\n    <room roomId=\"ROOM_ID\">\n      <data class=\"sc.framework.plugins.protocol.MoveRequest\" />\n    </room>\n\n### Senden\n\nDer Move ist der allgemeine Zug, der in verschiedenen Varianten gesendet\nwerden kann.\n\n`ROOM_ID`  \nID des GameRooms, aus dem `MoveRequest`.\n\n`ZUG`  \nZug wie in [ZUG](#zug)\n\n<!-- -->\n\n    <room roomId=\"ROOM_ID\">\n      ZUG\n    </room>\n\n## ZUG\n\n`X`  \nX-Koordinate des zu ziehenden Spielsteines oder des Zielfeldes\n\n`Y`  \nY-Koordinate des zu ziehenden Spielsteines oder des Zielfeldes\n\n`Z`  \nZ-Koordinate des zu ziehenden Spielsteines oder des Zielfeldes\n\n`COLOR`  \nFarbe des zu setzenden Spielsteines (RED/BLUE)\n\n`TYPE`  \nTyp des zu setzenden Spielsteines (ANT, BEE, BEETLE, GRASSHOPPER,\nSPIDER)\n\nEs gibt drei Arten von Zuegen. Entweder man setzt einen eigenen noch\nnicht gesetzten Stein auf ein Zielfeld:\n\n    <data class=\"setmove\">\n      <piece owner=\"COLOR\" type=\"TYPE\" />\n      <destination x=\"X\" y=\"Y\" z=\"Z\"/>\n    </data>\n\nOder man bewegt einen eigenen Stein auf dem Spielfeld:\n\n    <data class=\"dragmove\">\n      <start x=\"X\" y=\"Y\" z=\"Z\"/>\n      <destination x=\"X\" y=\"Y\" z=\"Z\"/>\n    </data>\n\nOder man kann weder setzen noch ziehen, dann ist es erlaubt,\nauszusetzen:\n\n    <data class=\"missmove\" />\n\n## Debughints\n\nZügen können Debug-Informationen beigefügt werden:\n\n    <hint content=\"S\" />\n\nDamit sieht beispielsweise ein Zug so aus:\n\n    <room roomId=\"ROOM_ID\">\n      <data class=\"dragmove\">\n        <start x=\"X\" y=\"Y\" z=\"Z\"/>\n        <destination x=\"X\" y=\"Y\" z=\"Z\"/>\n        <hint content=\"Dies ist ein Hint.\" />\n        <hint content=\"noch ein Hint\" />\n      </data>\n    </room>\n\n# Spielstatus\n\nEs folgt die Beschreibung des Spielstatus, der vor jeder Zugaufforderung\nan die Clients gesendet wird. Das Spielstatus-Tag ist dabei noch in\neinem *data*-Tag der Klasse *memento* gewrappt:\n\n## memento\n\n-   ROOM\\_ID Id des GameRooms\n\n-   STATUS Gamestate wie in [Status](#status)\n\n<!-- -->\n\n    <room roomId=\"ROOM_ID\">\n      <data class=\"memento\">\n        STATUS\n      </data>\n    </room>\n\n## Status\n\n-   Z aktuelle Zugzahl\n\n-   S Spieler, der das Spiel gestartet hat (RED/BLUE)\n\n-   C Spieler, der an der Reihe ist (RED/BLUE)\n\n-   red, blue wie in [Spieler](#spieler) definiert\n\n-   board Das Spielbrett, wie in [Spielbrett](#spielbrett) definiert\n\n-   undeployed Noch nicht gesetzte Spielsteine, siehe [Nicht gesetzte\n    Spielsteine](#undeployed)\n\n<!-- -->\n\n    <state class=\"state\" turn=\"Z\" startPlayerColor=\"S\" currentPlayerColor=\"C\">\n      red\n      blue\n      [board]\n      [undeployed]\n    </state>\n\n## Spieler\n\n-   c Farbe (red/blue)\n\n-   C Farbe (RED/BLUE)\n\n-   N Name des Spielers\n\n<!-- -->\n\n    <c displayName=\"N\" color=\"C\" />\n\n## Spielbrett\n\n-   FIELD Ein Spielfeld wie in [Spielfeld](#spielfeld) definiert.\n\n<!-- -->\n\n    <board>\n      <fields>\n        <null/>\n        ...\n        <null/>\n        <field x=\"-5\" y=\"2\" z=\"3\" isObstructed=\"false\"/>\n        ...\n        FIELD\n        ...\n        <field x=\"-5\" y=\"5\" z=\"0\" isObstructed=\"false\"/>\n      </fields>\n      ...\n      </board>\n\n`<board>` enthaelt 11 `<fields>` Tags die wiederrum 11 Eintraege haben.\nDas ganze repraesentiert ein 11x11 2D-Array. Da das Spielfeld aber nicht\nrechteckig ist sondern die Form eines Hexagons hat, sind nicht alle\nArray-Eintraege durch Felder belegt, sondern manche durch `<null/>`. Das\nFeld mit den X- und Y-Koordinaten `x` und `y` ist im Array an der Stelle\n(`x+5`, `y+5`) gespeichert.\n\n## Spielfeld\n\n-   X X-Koordinate\n\n-   Y Y-Koordinate\n\n-   Z Z-Koordinate\n\n-   OBSTRUCTED Blockiert (true) oder nicht (false)\n\n-   PIECES Spielsteine (falls auf dem Feld vorhanden). Oberster\n    Spielstein kommt als letztes in der Liste. Siehe\n    [Spielstein](#spielstein).\n\n<!-- -->\n\n    <field x=\"X\" y=\"Y\" z=\"Z\" isObstructed=\"OBSTRUCTED\">\n      PIECES\n    </field>\n\n## Spielstein\n\n-   OWNER Farbe (RED/BLUE)\n\n-   TYPE Insektentyp (ANT, BEE, BEETLE, GRASSHOPPER, SPIDER)\n\n<!-- -->\n\n    <piece owner=\"OWNER\" type=\"TYPE\"/>\n\n## Nicht gesetzte Spielsteine\n\n    <undeployedRedPieces>\n      <piece owner=\"RED\" type=\"BEE\"/>\n      ...\n    </undeployedRedPieces>\n    <undeployedBluePieces>\n      <piece owner=\"BLUE\" type=\"BEE\"/>\n      ...\n    </undeployedBluePieces>\n\n# Zug-Anforderung\n\nEine einfache Nachricht fordert zum Zug auf:\n\n    <room roomId=\"RID\">\n      <data class=\"sc.framework.plugins.protocol.MoveRequest\" />\n    </room>\n\n# Fehler\n\nEin “spielfähiger” :t[Computerspieler]{#player} muss nicht mit Fehlern umgehen können.\nFehlerhafte Züge beispielsweise resultieren in einem vorzeitigen Ende\ndes Spieles, das im nächsten gesendeten Gamestate erkannt werden kann\n(siehe [Spielergebnis](#spielende)).\n\n-   MSG Fehlermeldung\n\n<!-- -->\n\n    <room roomId=\"RID\">\n      <error message=\"MSG\">\n        <originalRequest>\n          Request, der den Fehler verursacht hat\n        </originalRequest>\n      </error>\n    </room>\n\n# Spiel verlassen\n\nWenn ein :t[Computerspieler]{#player} den Raum verlässt, bekommen die anderen Clients eine\nentsprechende Meldung vom Server.\n\n-   ROOM\\_ID Id des GameRooms\n\n<!-- -->\n\n    <left roomId=\"ROOM_ID\" />\n\n# Spielergebnis\n\nZum Spielende enthält der Spieler das Ergebnis:\n\n-   ROOM\\_ID Id des GameRooms\n\n-   R1, R2 Text, der den Grund für das Spielende erklärt\n\n-   CAUSE1, CAUSE2 Grund des Spielendes\n    (REGULAR/LEFT/RULE\\_VIOLATION/SOFT\\_TIMEOUT/HARD\\_TIMEOUT)\n\n-   WP1, WP2 Siegpunkte der jeweiligen Spieler, 0 verloren, 1\n    unentschieden, 2 gewonnen\n\n-   NAME Anzeigename des Spielers\n\n-   COLOR Farbe des Siegers\n\n-   S3 S1 oder S2 je nachdem wer gewonnen hat\n\n<!-- -->\n\n    <room roomId=\"ROOM_ID\">\n      <data class=\"result\">\n        <definition>\n          <fragment name=\"Gewinner\">\n            <aggregation>SUM</aggregation>\n            <relevantForRanking>true</relevantForRanking>\n          </fragment>\n          <fragment name=\"Ø freie Felder\">\n            <aggregation>AVERAGE</aggregation>\n            <relevantForRanking>true</relevantForRanking>\n          </fragment>\n        </definition>\n        <score cause=\"CAUSE1\" reason=\"R1\">\n          <part>WP1</part>\n          <part>S1</part>\n        </score>\n        <score cause=\"CAUSE2\" reason=\"R2\">\n          <part>WP2</part>\n          <part>S2</part>\n        </score>\n        <winner class=\"player\" displayName=\"NAME\" color=\"COLOR\" />\n      </data>\n    </room>\n\n# Spielverlauf\n\nDer Server startet (StandardIp: localhost 13050).\n\nNun gibt es zwei Varianten ein Spiel zu starten, eine durch einen\nAdministratorclient die andere durch hinzufügen der Spieler zu einen\nSpieltyp:\n\n## Variante 1 (AdminClient [Mit Reservierungscode](#mit-reservierungscode))\n\nEin :t[Computerspieler]{#player} registriert sich als Administrator mit dem in\nserver.properties festgelegten Passwort p:\n\n    <protocol><authenticate password=\"p\" />\n\nDann kann ein Spiel angelegt werden:\n\n    <prepare gameType=\"swc_2019_piranhas\">\n      <slot displayName=\"p1\" canTimeout=\"false\" shouldBePaused=\"true\" />\n      <slot displayName=\"p2\" canTimeout=\"false\" shouldBePaused=\"true\" />\n    </prepare>\n\nDer Server antwortet darauf mit einer Nachricht, die die ROOM\\_ID und\nReservierungscodes für die beiden Clients enthält:\n\n    <protocol>\n      <prepared roomId=\"871faccb-5190-4e44-82fc-6cdcbb493726\">\n        <reservation>RC1</reservation>\n        <reservation>RC2</reservation>\n      </prepared>\n\nDer Administratorclient kann nur ebenfalls als Observer des Spiels\ngenutzt werden, indem ein entsprechender Request gesendet wird. Dadurch\nwird das derzeitge Spielfeld ([memento](#memento)) ebenfalls an den\nAdministratorclient gesendet.\n\n    <observe roomId=\"871faccb-5190-4e44-82fc-6cdcbb493726\" />\n\nClients die auf dem Serverport (localhost 13050) gestartet werden können\nso über diesen Code joinen.\n\n    <protocol>\n      <joinPrepared reservationCode=\"RC1\" />\n\n    <protocol>\n      <joinPrepared reservationCode=\"RC2\" />\n\n## Variante 2 ((eventuell) ohne AdminClient [Ohne Reservierungscode](#ohne-reservierungscode))\n\nDie Clients wurden auf dem Serverport (Standard: localhost 13050)\ngestartet.\n\nSie können sich mit folgender Anfrage einen bereits offenen Spiel\ngleichen Typs beitreten oder, falls kein Spiel des Typs vorhanden selbst\neines starten:\n\n    <protocol>\n      <join gameType=\"swc_2019_piranhas\" />\n\nDer Server antwortet mit:\n\n    <protocol>\n      <joined roomId=\"871faccb-5190-4e44-82fc-6cdcbb493726\" />\n\n## Weiterer Spielverlauf\n\nDer Server antwortet jeweils mit der WelcomeMessage ([Welcome\nMessage](#welcome-message)) und dem ersten GameState\n([memento](#memento)) sobald beide Spieler verbunden sind.\n\n    <room roomId=\"871faccb-5190-4e44-82fc-6cdcbb493726\">\n      <data class=\"welcomeMessage\" color=\"red\" />\n    </room>\n    <room roomId=\"871faccb-5190-4e44-82fc-6cdcbb493726\">\n      <data class=\"memento\">\n        <state class=\"state\" startPlayerColor=\"RED\" currentPlayerColor=\"RED\" turn=\"0\">\n          <red displayName=\"Red\" color=\"RED\"/>\n          <blue displayName=\"Blue\" color=\"BLUE\"/>\n          <board>\n            <fields>\n              <null/>\n              <null/>\n              <null/>\n              <null/>\n              <null/>\n              <field x=\"-5\" y=\"0\" z=\"5\" isObstructed=\"false\"/>\n              <field x=\"-5\" y=\"1\" z=\"4\" isObstructed=\"false\"/>\n              <field x=\"-5\" y=\"2\" z=\"3\" isObstructed=\"false\"/>\n              <field x=\"-5\" y=\"3\" z=\"2\" isObstructed=\"false\"/>\n              <field x=\"-5\" y=\"4\" z=\"1\" isObstructed=\"false\"/>\n              <field x=\"-5\" y=\"5\" z=\"0\" isObstructed=\"false\"/>\n            </fields>\n            <fields>\n              <null/>\n              <null/>\n              <null/>\n              <null/>\n              <field x=\"-4\" y=\"-1\" z=\"5\" isObstructed=\"false\"/>\n              <field x=\"-4\" y=\"0\" z=\"4\" isObstructed=\"false\"/>\n            </fields>\n            ...\n            <fields>\n            ...\n            </fields>\n          </board>\n        </state>\n      </data>\n    </room>\n\nDer erste Spieler erhält dann eine Zugaufforderung\n([MoveRequest](#move-request)), falls in server.properties paused auf\nfalse gesetzt wurde. Falls das Spiel pausiert ist, muss das Spiel durch\neinen Administratorclient gestartet werden:\n\nVerbinden des Administratorclients (falls es sich um die erste\nKontaktaufnahme zum Server handelt, ansonsten &lt;protocol&gt;\nweglassen).\n\n    <protocol>\n      <authenticate password=\"examplepassword\" />\n\nPausierung aufheben:\n\n    <pause roomId=\"871faccb-5190-4e44-82fc-6cdcbb493726\" pause=\"false\" />\n\nDaraufhin wird der erste Spieler aufgefordert einen Zug zu senden:\n\n    <room roomId=\"871faccb-5190-4e44-82fc-6cdcbb493726\">\n      <data class=\"sc.framework.plugins.protocol.MoveRequest\" />\n    </room>\n\nDer :t[Computerspieler]{#player} des CurrentPlayer sendet nun einen Zug ([ZUG](#zug)):\n\n    <room roomId=\"871faccb-5190-4e44-82fc-6cdcbb493726\">\n      <data class=\"setmove\">\n        <piece owner=\"RED\" type=\"BEETLE\" />\n        <destination x=\"-2\" y=\"0\" z=\"2\"/>\n      </data>\n    </room>\n\nSo geht es abwechselnd weiter, bis zum Spielende\n([Spielergebnis](#spielende)). Die letzte Nachricht des Servers endet\nmit:\n\n    </protocol>\n\nDanach wird die Verbindung geschlossen.\n","data":{},"elements":["t"]}},{"folder":"book","path":{"directory":"spiele/penguins","absolute":"/home/runner/work/docs/docs/hyperbook/.hyperbook/book/spiele/penguins/xml.md","relative":"spiele/penguins/xml.md","href":"/spiele/penguins/xml"},"extension":".md","name":"xml","root":"/home/runner/work/docs/docs/hyperbook/.hyperbook","markdown":{"content":"\n# Die Schnittstelle zum Server (XML)\n\nDer :t[Spielleiter]{#server} kommuniziert mit den Computerspielern über eine Netzwerkverbindung. Dadurch ist man aus technischer Sicht komplett flexibel, was die Wahl der Programmiersprache angeht. Die :t[Computerspieler]{#player} müssen lediglich das Kommunikationsprotokoll erfüllen.\n\nAnfängern wird allerdings davon abgeraten, einen komplett eigenen :t[Computerspieler]{#player} zu schreiben. Es ist deutlich einfacher, auf einem bereitgestellten Zufallsspieler aufzubauen, da man sich dabei nur um die Strategie und nicht um die Kommunikation kümmern muss. Außerdem wird vom Institut für Informatik die beste Unterstützung für Java/Kotlin geboten.\n\n## Hinweise\n\nIm Verlauf des Wettbewerbes können Elemente zur Kommunikationsschnittstelle hinzugefügt werden, die in dieser Dokumentation nicht aufgeführt sind. Um auch bei solchen Änderungen sicher zu sein, dass ein :t[Computerspieler]{#player} fehlerfrei mit dem Server kommunizieren kann, sollten beim Auslesen des :t[XML]{#xml} jegliche Daten verworfen werden, die hier nicht weiter definiert sind.\n\nDie bereitgestellten Programme \n(:t[Server]{#server}, :t[Java-Spieler]{#player}) nutzen eine Bibliothek,\num Java-Objekte direkt in :t[XML]{#xml} zu konvertieren und umgekehrt.\nDabei werden XML-Nachrichten nicht unbedingt mit einem Zeilenumbruch abgeschlossen.\n\n## Das Spielprotokoll\n\nIn diesem Abschnitt wird die spielunabhängige Kommunikationsschnittstelle für Spieler festgehalten, um das Schreiben eines komplett eigenen Clients zu ermöglichen.\n\n### Spiel betreten\n\n```xml\n<protocol>\n```\n\nDieses Tag eröffnet die Kommunikation mit dem Server. Dann gibt es drei Möglichkeiten, einer Spielpartie beizutreten.\n\n#### Beliebige Partie\n\nBetritt eine beliebige offene Spielpartie:\n\n```xml\n<join />\n```\n\nSollte kein Spiel offen sein, wird automatisch ein neues erstellt. Abhängig von der Einstellung `paused` in `server.properties` wird das Spiel pausiert gestartet oder nicht.\n\n#### Bestimmte Partie\n\nEiner bestimmten, bereits offenen, aber noch nicht gestarteten Partie kann durch Angabe der `ROOM_ID` beigetreten werden:\n\n```xml\n<joinRoom roomId=\"ROOM_ID\" />\n```\n\n#### Mit Reservierung\n\nUnter Angabe eines Reservierungscodes kann man einen reservierten Platz in einer geplanten Partie einnehmen:\n\n```xml\n<joinPrepared reservationCode=\"RESERVATION\" />\n```\n\n#### Antwort nach der Verbindung\n\nDer Server antwortet auf einen erfolgreichen Spielbeitritt mit:\n\n```xml\n<joined roomId=\"ROOM_ID\" />\n```\n\n- **ROOM_ID**\n  - Identifikationscode der Spielpartie\n\n### Spielverlauf\n\n#### Start\n\nDer Server eröffnet das Spiel mit einer Begrüßung und dem initialen Spielstatus, sobald beide Spieler verbunden sind.\n\n- **ROOM_ID**\n  - Identifikationscode der Spielpartie\n\n- **TEAMNUMBER**\n  - Spielernummer, eg. `ONE`, `TWO`\n\n#### Syntax der Willkommensnachricht\n\n\n```xml\n<room roomId=\"ROOM_ID\">\n  <data class=\"welcomeMessage\" color=\"TEAMNUMBER\"></data>\n</room>\n<room roomId=\"ROOM_ID\">\n  <data class=\"memento\">\n    STATUS\n  </data>\n</room>\n```\n\n#### Status nach der Willkommensnachricht\n\nDer Status der oben in dem data memento Objekt enthalten ist, ist beispielsweise der folgenden Form:\n```xml\n<state turn=\"0\">\n  <startTeam>ONE</startTeam>\n  <board>\n\t<list>\n\t  <field>1</field>\n\t  <field>2</field>\n\t  <field>2</field>\n\t</list>\n\t<list>\n\t  <field>2</field>\n\t  <field>ONE</field>\n\t  <field>2</field>\n\t</list>\n\t<list>\n\t  <field>TWO</field>\n\t  <field>4</field>\n\t  <field>1</field>\n\t</list>\n  </board>\n  <fishes>\n\t<int>0</int>\n\t<int>0</int>\n  </fishes>\n</state>\n```\n\nEs enthält die Zugnummer in ``turn``, das anfangende Team in ``startTeam``, eine Liste an Feldern in ``board`` und die Anzahl Fische beider Spielers in ``fishes``, zuerst die von ONE und danach die von TWO.\n\nIn `board` entsprechen die Positionen der Felder auf dem Spielfeld in [odd-r Koordinaten](https://www.redblobgames.com/grids/hexagons/#neighbors-offset) ihrer Positionen in der XML Struktur. Von oben bei null anfangend werden die `<list>` Objekte in `<board>` durchgezählt. Die Nummer der List in dem das Field Objekt ist, ist seine `y` Koordinate.  Auf die gleiche Weise entspricht die `x` Koordinate eines Felds seiner Nummer innerhalb des `<list>` Objekts.  \nDer Inhalt der `field` Objekte steht für die Anzahl Fische auf dem Feld, oder für einen Pinguin eines Spielers. In ersterem Fall steht eine Zahl in dem XML-Objekt und in letzterem Fall der Name des Spielers der den Pinguin gehört. Auf einem Feld können 0 bis 4 Fische sein.\n\n`x`: `<field>` index in `<list>`\n\n`y`: `<list>` index in `<board>`\n\n##### Koordinatensysteme\n\nBeachtet, dass der XML-Status [odd-r Koordinaten](https://www.redblobgames.com/grids/hexagons/#neighbors-offset) nutzt, und dass die Koordinaten in Zügen als [doubled Koordinaten](https://www.redblobgames.com/grids/hexagons/#neighbors-doubled) interpretiert werden.\n\nDie Formeln für die Transformation von dem einen System in das andere sind folgendermaßen:\n\nodd-r zu doubled: ``(x, y) => (x * 2 + y % 2, y)``\n\ndoubled zu odd-r: ``(x, y) => (Ceiling(x / 2.0) - y % 2, y)``\n\nBeachtet, dass `x / 2` hier durch `Ceiling(x / 2.0)` aufgerundet wird.\n\n:::alert{warn}\nBeachtet weiter, dass im doubled Koordinatensystem unabhängig der Größe (0, 1), (0, 3), (0, 5), etc. immer out of bounds sind, da sie in odd-r zu (-1, y) übersetzt werden.\n:::\n\n#### Spielablauf\n\nDer erste Spieler erhält dann eine Zugaufforderung:\n\n```xml\n<room roomId=\"ROOM_ID\">\n  <data class=\"moveRequest\" />\n</room>\n```\n\nWorauf dieser innerhalb der gesetzten Zeitbeschränkung mit einem der folgenden Zug-Typen antwortet:\n\n##### Normaler Zug\n\n```xml\n<room roomId=\"ROOM_ID\">\n  <data class=\"move\">\n    <from x=\"0\" y=\"7\"/>\n    <to x=\"4\" y=\"5\"/>\n  </data>\n</room>\n```\n\nEin normaler Zug besteht aus einem ``from`` und einem ``to`` Vektor, welche beide `x` und `y` Werte in [doubled Koordinaten](https://www.redblobgames.com/grids/hexagons/#neighbors-doubled) enthalten.\n\n##### Lege Zug\n\n```xml\n<room roomId=\"ROOM_ID\">\n  <data class=\"move\">\n    <to x=\"1\" y=\"2\"/>\n  </data>\n</room>\n```\n\nEin Lege-Zug besteht aus einem ``to`` Vektor, welcher `x` und `y` Werte in [doubled Koordinaten](https://www.redblobgames.com/grids/hexagons/#neighbors-doubled) enthält.\n\n##### Weiteres\n\nNach Erhalt des Zuges sendet der Server den neuen Spielstatus an alle Spieler \nund dem nächsten Spieler eine Zugaufforderung.\nSo geht es hin und her bis zum [Spielergebnis](#spielergebnis).\n\n#### Ende der Kommunikation\n\nDie letzte Nachricht des Servers endet mit:\n\n```xml\n</protocol>\n```\n\nDanach wird die Verbindung geschlossen.\n\n### Spielergebnis\n\nZum Spielende erhält jeder Spieler das Ergebnis. Es beginnt mit einer `definition`, die die Interpretation der Ergebnisse erklärt. Für jeden Spieler gibt es einen Eintrag in `scores`. Der darin enthaltene `score` schlüsselt sich auf in:\n\n- **cause**\n  - Beitrag des Spielers zum Spielende (`REGULAR`, `LEFT`, `RULE_VIOLATION`, `SOFT_TIMEOUT`, `HARD_TIMEOUT`).\n- **reason**\n  - Erklärung zu `cause`.\n- **part**\n  - Siegpunkte des Spielers (0 verloren, 1 unentschieden, 2 gewonnen) und weitere Punkteinträge entsprechend `definition`.\n- **winner**\n  - Gibt das Gewinner-Team an, wenn es eines gibt.\n\nHier ein Beispiel:\n\n```xml\n<room roomId=\"ROOM_ID\">\n  <data class=\"result\">\n    <definition>\n      <fragment name=\"Siegpunkte\">\n        <aggregation>SUM</aggregation>\n        <relevantForRanking>true</relevantForRanking>\n      </fragment>\n      <fragment name=\"∅ Punkte\">\n        <aggregation>AVERAGE</aggregation>\n        <relevantForRanking>true</relevantForRanking>\n      </fragment>\n    </definition>\n    <scores>\n      <entry>\n        <player name=\"rad\" team=\"ONE\"/>\n        <score cause=\"REGULAR\" reason=\"\">\n          <part>2</part>\n          <part>27</part>\n        </score>\n      </entry>\n      <entry>\n        <player name=\"blues\" team=\"TWO\"/>\n        <score cause=\"LEFT\" reason=\"Player left\">\n          <part>0</part>\n          <part>15</part>\n        </score>\n      </entry>\n    </scores>\n    <winner team=\"ONE\"/>\n  </data>\n</room>\n```\n\n### Weiterführende Informationen\n\n:t[Einführung in XML]{#xml}\n\n:t[Administration der Spiele mit XML]{#xml-administration.md}","data":{"name":"XML-Schnittstelle"},"elements":["t","alert"]}},{"folder":"book","path":{"directory":"spiele/piranhas/xml-dokumentation","absolute":"/home/runner/work/docs/docs/hyperbook/.hyperbook/book/spiele/piranhas/xml-dokumentation/einleitung-xml.md","relative":"spiele/piranhas/xml-dokumentation/einleitung-xml.md","href":"/spiele/piranhas/xml-dokumentation/einleitung-xml"},"extension":".md","name":"einleitung-xml","root":"/home/runner/work/docs/docs/hyperbook/.hyperbook","markdown":{"content":"# Einleitung\n\nWie in den letzten Jahren wird zur Computerspieler-Server Kommunikation ein\nXML-Protokoll genutzt. In diesem Dokument wird die\nKommunikationsschnittstelle definiert, sodass ein komplett eigener\n:t[Computerspieler]{#player} geschrieben werden kann. Es wird hier nicht die vollständige\nKommunikation dokumentiert bzw. definiert, dennoch alles, womit ein\n:t[Computerspieler]{#player} umgehen können muss, um spielfähig zu sein.\n\n## An wen richtet sich dieses Dokument?\n\nDie Kommunikation mit dem Spielserver ist für diejenigen, die aufbauend\nauf dem Zufallsspieler programmieren, unwichtig. Dort steht bereits ein\nfunktionierender :t[Computerspieler]{#player} bereit und es muss nur die Spiellogik entworfen\nwerden. \\\\\\\\ Nur wer einen komplett eigenen :t[Computerspieler]{#player} entwerfen will,\nbeispielsweise um die Programmiersprache frei wählen zu können, benötigt\ndie Definitionen.\n\n## Hinweise\n\nFalls Sie beabsichtigen sollten, diese Kommunikationsschnittstelle zu\nrealisieren, sei darauf hingewiesen, dass es im Verlauf des Wettbewerbes\nmöglich ist, dass weitere, hier noch nicht aufgeführte Elemente zur\nKommunikationsschnittstelle hinzugefügt werden. Um auch bei solchen\nÄnderungen sicher zu sein, dass ihr :t[Computerspieler]{#player} fehlerfrei mit dem Server\nkommunizieren kann, empfehlen wir Ihnen, beim Auslesen des :t[XML]{#xml} jegliche\nDaten zu verwerfen, die hier nicht weiter definiert sind. Die vom\nInstitut bereitgestellten Programme (Server, Zufallsspieler) nutzen eine\nBibliothek um Java-Objekte direkt in :t[XML]{#xml} zu konvertieren und umgekehrt.\nDabei werden XML-Nachrichten nicht mit einem newline abgeschlossen.\n","data":{},"elements":["t"]}},{"folder":"book","path":{"directory":"spiele/piranhas/xml-dokumentation","absolute":"/home/runner/work/docs/docs/hyperbook/.hyperbook/book/spiele/piranhas/xml-dokumentation/fehler.md","relative":"spiele/piranhas/xml-dokumentation/fehler.md","href":"/spiele/piranhas/xml-dokumentation/fehler"},"extension":".md","name":"fehler","root":"/home/runner/work/docs/docs/hyperbook/.hyperbook","markdown":{"content":"# Fehler\n\nEin “spielfähiger” :t[Computerspieler]{#player} muss nicht mit Fehlern umgehen können.\nFehlerhafte Züge beispielsweise resultieren in einem vorzeitigen Ende\ndes Spieles, das im nächsten gesendeten Gamestate erkannt werden kann\n(siehe [???](#spielende)).\n\n-   MSG Fehlermeldung\n\n<!-- -->\n\n    <room roomId=\"RID\">\n      <error message=\"MSG\">\n        <originalRequest>\n          Request, der den Fehler verursacht hat\n        </originalRequest>\n      </error>\n    </room>\n","data":{},"elements":["t"]}},{"folder":"book","path":{"directory":"spiele/piranhas/xml-dokumentation","absolute":"/home/runner/work/docs/docs/hyperbook/.hyperbook/book/spiele/piranhas/xml-dokumentation/spiel-betreten.md","relative":"spiele/piranhas/xml-dokumentation/spiel-betreten.md","href":"/spiele/piranhas/xml-dokumentation/spiel-betreten"},"extension":".md","name":"spiel-betreten","root":"/home/runner/work/docs/docs/hyperbook/.hyperbook","markdown":{"content":"# Spiel betreten\n\nWenn begonnen wird mit dem Server zu kommunizieren, muss zuallererst\n\n    <protocol>\n\ngesendet werden, um die Kommunikation zu beginnen.\n\n## Ohne Reservierungscode\n\nBetritt ein beliebiges offenes Spiel:\n\n    <join gameType=\"swc_2019_piranhas\" />\n\nSollte kein Spiel offen sein, wird so ein neues erstellt. Je nachdem ob\npaused in server.properties true oder false ist, wird das Spiel pausiert\ngestartet oder nicht. Der Server antwortet darauf mit:\n\n-   ROOM\\_ID Id des GameRooms\n\n<!-- -->\n\n    <joined roomId=\"ROOM_ID\" />\n\nAlle administrativen Clients werden ebenfalls darüber benachrichtigt und\nerhalten folgende Nachricht:\n\n-   ROOM\\_ID Id des GameRooms\n\n<!-- -->\n\n    <joinedGameRoom roomId=\"ROOM_ID\" existing=\"false\" />\n\nFalls bereits ein GameRoom offen war, ist dementsprechend existing true.\n\n## Mit Reservierungscode\n\nIst ein Reservierungscode gegeben, so kann man den durch den Code\ngegebenen Platz betreten.\n\n### Join mit RC\n\n-   RC Reservierungscode\n\n<!-- -->\n\n    <joinPrepared reservationCode=\"RC\" />\n\n### Welcome Message\n\nDer Server antwortet darauf nur, wenn der zweite :t[Computerspieler]{#player} ebenfalls\nverbunden ist:\n\n-   ROOM\\_ID Id des GameRooms\n\n-   COLOR Spielerfarbe also red oder blue\n\n-   STATUS GameState wie in [???](#status)\n\n<!-- -->\n\n    <joined roomId=\"ROOM_ID\" />\n    <room roomId=\"ROOM_ID\">\n      <data class=\"welcomeMessage\" color=\"COLOR\"></data>\n    </room>\n    <room roomId=\"ROOM_ID\">\n      <data class=\"memento\">\n        STATUS\n      </data>\n    </room>\n","data":{},"elements":["t"]}},{"folder":"book","path":{"directory":"spiele/piranhas/xml-dokumentation","absolute":"/home/runner/work/docs/docs/hyperbook/.hyperbook/book/spiele/piranhas/xml-dokumentation/spiel-verlassen.md","relative":"spiele/piranhas/xml-dokumentation/spiel-verlassen.md","href":"/spiele/piranhas/xml-dokumentation/spiel-verlassen"},"extension":".md","name":"spiel-verlassen","root":"/home/runner/work/docs/docs/hyperbook/.hyperbook","markdown":{"content":"# Spiel verlassen\n\nWenn ein :t[Computerspieler]{#player} den Raum verlässt, bekommen die anderen Clients eine\nentsprechende Meldung vom Server.\n\n-   ROOM\\_ID Id des GameRooms\n\n<!-- -->\n\n    <left roomId=\"ROOM_ID\" />\n","data":{},"elements":["t"]}},{"folder":"book","path":{"directory":"spiele/piranhas/xml-dokumentation","absolute":"/home/runner/work/docs/docs/hyperbook/.hyperbook/book/spiele/piranhas/xml-dokumentation/spielverlauf.md","relative":"spiele/piranhas/xml-dokumentation/spielverlauf.md","href":"/spiele/piranhas/xml-dokumentation/spielverlauf"},"extension":".md","name":"spielverlauf","root":"/home/runner/work/docs/docs/hyperbook/.hyperbook","markdown":{"content":"# Spielverlauf\n\nDer Server startet (StandardIp: localhost 13050).\n\nNun gibt es zwei Varianten ein Spiel zu starten, eine durch einen\nAdministratorclient die andere durch hinzufügen der Spieler zu einen\nSpieltyp:\n\n## Variante 1 (AdminClient [???](#mit-reservierungscode))\n\nEin :t[Computerspieler]{#player} registriert sich als Administrator mit dem in\nserver.properties festgelegten Passwort p:\n\n    <protocol><authenticate passphrase=\"p\" />\n\nDann kann ein Spiel angelegt werden:\n\n    <prepare gameType=\"swc_2019_piranhas\">\n      <slot displayName=\"p1\" canTimeout=\"false\" shouldBePaused=\"true\" />\n      <slot displayName=\"p2\" canTimeout=\"false\" shouldBePaused=\"true\" />\n    </prepare>\n\nDer Server antwortet darauf mit einer Nachricht, die die ROOM\\_ID und\nReservierungscodes für die beiden Clients enthält:\n\n    <protocol>\n      <prepared roomId=\"871faccb-5190-4e44-82fc-6cdcbb493726\">\n        <reservation>RC1</reservation>\n        <reservation>RC2</reservation>\n      </prepared>\n\nDer Administratorclient kann nur ebenfalls als Observer des Spiels\ngenutzt werden, indem ein entsprechender Request gesendet wird. Dadurch\nwird das derzeitge Spielfeld ([???](#memento)) ebenfalls an den\nAdministratorclient gesendet.\n\n    <observe roomId=\"871faccb-5190-4e44-82fc-6cdcbb493726\" />\n\nClients die auf dem Serverport (localhost 13050) gestartet werden können\nso über diesen Code joinen.\n\n    <protocol>\n      <joinPrepared reservationCode=\"RC1\" />\n\n    <protocol>\n      <joinPrepared reservationCode=\"RC2\" />\n\n## Variante 2 ((eventuell) ohne AdminClient [???](#ohne-reservierungscode))\n\nDie Clients wurden auf dem Serverport (Standard: localhost 13050)\ngestartet.\n\nSie können sich mit folgender Anfrage einen bereits offenen Spiel\ngleichen Typs beitreten oder, falls kein Spiel des Typs vorhanden selbst\neines starten:\n\n    <protocol>\n      <join gameType=\"swc_2019_piranhas\" />\n\nDer Server antwortet mit:\n\n    <protocol>\n      <joined roomId=\"871faccb-5190-4e44-82fc-6cdcbb493726\" />\n\n## Weiterer Spielverlauf\n\nDer Server antwortet jeweils mit der WelcomeMessage\n([???](#welcome-message)) und dem ersten GameState ([???](#memento))\nsobald beide Spieler verbunden sind.\n\n    <room roomId=\"871faccb-5190-4e44-82fc-6cdcbb493726\">\n      <data class=\"welcomeMessage\" color=\"red\" />\n    </room>\n    <room roomId=\"871faccb-5190-4e44-82fc-6cdcbb493726\">\n      <data class=\"memento\">\n        <state class=\"state\" turn=\"0\" startPlayer=\"RED\" currentPlayer=\"RED\">\n          <red displayName=\"Unknown\" color=\"RED\" />\n          <blue displayName=\"Unknown\" color=\"BLUE\" />\n          <board>\n            <fields>\n              <field x=\"0\" y=\"0\" state=\"EMPTY\" />\n              ...\n              <field x=\"0\" y=\"9\" state=\"EMPTY\" />\n            </fields>\n            ...\n            <fields>\n              <field x=\"9\" y=\"0\" state=\"EMPTY\" />\n              ...\n              <field x=\"9\" y=\"9\" state=\"EMPTY\" />\n            </fields>\n          </board>\n        </state>\n      </data>\n    </room>\n\nDer erste Spieler erhält dann eine Zugaufforderung\n([???](#move-request)), falls in server.properties paused auf false\ngesetzt wurde. Falls das Spiel pausiert ist, muss das Spiel durch einen\nAdministratorclient gestartet werden:\n\nVerbinden des Administratorclients (falls es sich um die erste\nKontaktaufnahme zum Server handelt, ansonsten &lt;protocol&gt;\nweglassen).\n\n    <protocol>\n      <authenticate passphrase=\"examplepassword\" />\n\nPausierung aufheben:\n\n    <pause roomId=\"871faccb-5190-4e44-82fc-6cdcbb493726\" pause=\"false\" />\n\nDaraufhin wird der erste Spieler aufgefordert einen Zug zu senden:\n\n    <room roomId=\"871faccb-5190-4e44-82fc-6cdcbb493726\">\n      <data class=\"sc.framework.plugins.protocol.MoveRequest\" />\n    </room>\n\nDer :t[Computerspieler]{#player} des CurrentPlayer sendet nun einen Zug ([???](#zug)):\n\n    <room roomId=\"871faccb-5190-4e44-82fc-6cdcbb493726\">\n      <data class=\"move\" x=\"0\" y=\"0\" direction=\"UP\" />\n    </room>\n\nSo geht es abwechselnd weiter, bis zum Spielende ([???](#spielende)).\nDie letzte Nachricht des Servers endet mit:\n\n    </protocol>\n\nDanach wird die Verbindung geschlossen.\n","data":{},"elements":["t"]}},{"folder":"book","path":{"directory":"spiele/piranhas/xml-dokumentation","absolute":"/home/runner/work/docs/docs/hyperbook/.hyperbook/book/spiele/piranhas/xml-dokumentation/xml-dokumentation.md","relative":"spiele/piranhas/xml-dokumentation/xml-dokumentation.md","href":"/spiele/piranhas/xml-dokumentation/xml-dokumentation"},"extension":".md","name":"xml-dokumentation","root":"/home/runner/work/docs/docs/hyperbook/.hyperbook","markdown":{"content":"Ziel dieser Dokumentation ist es, die XML-Schnittstelle der\nSoftwarechallenge festzuhalten.\n\n[PDF-Version dieses Dokumentes](xml-dokumentation.pdf)\n\nWir freuen uns über sämtliche Verbesserungsvorschläge. Die Dokumentation\nkann [direkt auf GitHub\neditiert](https://github.com/software-challenge/docs) werden, einzige\nVoraussetzung ist eine kostenlose Registrierung bei GitHub. Ist man\nangemeldet, kann man ein Dokument auswählen (ein guter Startpunkt ist\ndie Datei\n[index.md](https://github.com/software-challenge/docs/blob/master/index.md)\nwelche Verweise auf alle Sektionen der Dokumentation enthält) und dann\nauf den Stift oben rechts klicken. Alternativ auch gern eine E-Mail an\n<tech@software-challenge.de>.\n\n# Einleitung\n\nWie in den letzten Jahren wird zur Computerspieler-Server Kommunikation ein\nXML-Protokoll genutzt. In diesem Dokument wird die\nKommunikationsschnittstelle definiert, sodass ein komplett eigener\n:t[Computerspieler]{#player} geschrieben werden kann. Es wird hier nicht die vollständige\nKommunikation dokumentiert bzw. definiert, dennoch alles, womit ein\n:t[Computerspieler]{#player} umgehen können muss, um spielfähig zu sein.\n\n## An wen richtet sich dieses Dokument?\n\nDie Kommunikation mit dem Spielserver ist für diejenigen, die aufbauend\nauf dem Zufallsspieler programmieren, unwichtig. Dort steht bereits ein\nfunktionierender :t[Computerspieler]{#player} bereit und es muss nur die Spiellogik entworfen\nwerden. \\\\\\\\ Nur wer einen komplett eigenen :t[Computerspieler]{#player} entwerfen will,\nbeispielsweise um die Programmiersprache frei wählen zu können, benötigt\ndie Definitionen.\n\n## Hinweise\n\nFalls Sie beabsichtigen sollten, diese Kommunikationsschnittstelle zu\nrealisieren, sei darauf hingewiesen, dass es im Verlauf des Wettbewerbes\nmöglich ist, dass weitere, hier noch nicht aufgeführte Elemente zur\nKommunikationsschnittstelle hinzugefügt werden. Um auch bei solchen\nÄnderungen sicher zu sein, dass ihr :t[Computerspieler]{#player} fehlerfrei mit dem Server\nkommunizieren kann, empfehlen wir Ihnen, beim Auslesen des :t[XML]{#xml} jegliche\nDaten zu verwerfen, die hier nicht weiter definiert sind. Die vom\nInstitut bereitgestellten Programme (Server, Zufallsspieler) nutzen eine\nBibliothek um Java-Objekte direkt in :t[XML]{#xml} zu konvertieren und umgekehrt.\nDabei werden XML-Nachrichten nicht mit einem newline abgeschlossen.\n\n# Spiel betreten\n\nWenn begonnen wird mit dem Server zu kommunizieren, muss zuallererst\n\n    <protocol>\n\ngesendet werden, um die Kommunikation zu beginnen.\n\n## Ohne Reservierungscode\n\nBetritt ein beliebiges offenes Spiel:\n\n    <join gameType=\"swc_2019_piranhas\" />\n\nSollte kein Spiel offen sein, wird so ein neues erstellt. Je nachdem ob\npaused in server.properties true oder false ist, wird das Spiel pausiert\ngestartet oder nicht. Der Server antwortet darauf mit:\n\n-   ROOM\\_ID Id des GameRooms\n\n<!-- -->\n\n    <joined roomId=\"ROOM_ID\" />\n\nAlle administrativen Clients werden ebenfalls darüber benachrichtigt und\nerhalten folgende Nachricht:\n\n-   ROOM\\_ID Id des GameRooms\n\n<!-- -->\n\n    <joinedGameRoom roomId=\"ROOM_ID\" existing=\"false\" />\n\nFalls bereits ein GameRoom offen war, ist dementsprechend existing true.\n\n## Mit Reservierungscode\n\nIst ein Reservierungscode gegeben, so kann man den durch den Code\ngegebenen Platz betreten.\n\n### Join mit RC\n\n-   RC Reservierungscode\n\n<!-- -->\n\n    <joinPrepared reservationCode=\"RC\" />\n\n### Welcome Message\n\nDer Server antwortet darauf nur, wenn der zweite :t[Computerspieler]{#player} ebenfalls\nverbunden ist:\n\n-   ROOM\\_ID Id des GameRooms\n\n-   COLOR Spielerfarbe also red oder blue\n\n-   STATUS GameState wie in [Status](#status)\n\n<!-- -->\n\n    <joined roomId=\"ROOM_ID\" />\n    <room roomId=\"ROOM_ID\">\n      <data class=\"welcomeMessage\" color=\"COLOR\"></data>\n    </room>\n    <room roomId=\"ROOM_ID\">\n      <data class=\"memento\">\n        STATUS\n      </data>\n    </room>\n\n# Züge senden\n\n## Der Move\n\nDer Move ist die Antwort auf den MoveRequest des Servers.\n\n### MoveRequest\n\n`ROOM_ID`  \nID des GameRooms, dient der Zuordnung der Antworten des Clients.\n\n<!-- -->\n\n    <room roomId=\"ROOM_ID\">\n      <data class=\"sc.framework.plugins.protocol.MoveRequest\" />\n    </room>\n\n### Senden\n\nDer Move ist der allgemeine Zug, der in verschiedenen Varianten gesendet\nwerden kann.\n\n`ROOM_ID`  \nID des GameRooms, aus dem `MoveRequest`.\n\n`ZUG`  \nZug wie in [ZUG](#zug)\n\n<!-- -->\n\n    <room roomId=\"ROOM_ID\">\n      ZUG\n    </room>\n\n## ZUG\n\n`X`  \nX-Koordinate des zu ziehenden Piranhas (`0` bis `9`, Spalten des\nSpielfeldes von links nach rechts)\n\n`Y`  \nY-Koordinate des zu ziehenden Piranhas (`0` bis `9`, Zeilen des\nSpielfeldes von unten nach oben)\n\n`DIRECTION`  \nRichtung, in die der Piranha zieht. Eine von folgenden:\n\n-   `UP`\n\n-   `UP_RIGHT`\n\n-   `RIGHT`\n\n-   `DOWN_RIGHT`\n\n-   `DOWN`\n\n-   `DOWN_LEFT`\n\n-   `LEFT`\n\n-   `UP_LEFT`\n\n<!-- -->\n\n    <data class=\"move\" x=\"X\" y=\"Y\" direction=\"DIRECTION\" />\n\n## Debughints\n\nZügen können Debug-Informationen beigefügt werden:\n\n    <hint content=\"S\" />\n\nDamit sieht beispielsweise ein Laufzug so aus:\n\n    <room roomId=\"ROOM_ID\">\n      <data class=\"move\" x=\"0\" y=\"0\" direction=\"UP\">\n        <hint content=\"Dies ist ein Hint.\" />\n        <hint content=\"noch ein Hint\" />\n      </data>\n    </room>\n\n# Spielstatus\n\nEs folgt die Beschreibung des Spielstatus, der vor jeder Zugaufforderung\nan die Clients gesendet wird. Das Spielstatus-Tag ist dabei noch in\neinem *data*-Tag der Klasse *memento* gewrappt:\n\n## memento\n\n-   ROOM\\_ID Id des GameRooms\n\n-   STATUS Gamestate wie in [Status](#status)\n\n<!-- -->\n\n    <room roomId=\"ROOM_ID\">\n      <data class=\"memento\">\n        STATUS\n      </data>\n    </room>\n\n## Status\n\n-   Z aktuelle Zugzahl\n\n-   S Spieler, der das Spiel gestartet hat (RED/BLUE)\n\n-   C Spieler, der an der Reihe ist (RED/BLUE)\n\n-   red, blue wie in [Spieler](#spieler) definiert\n\n-   board Das Spielbrett, wie in [Spielbrett](#spielbrett) definiert\n\n-   lastMove Letzter getätigter Zug (nicht in der ersten Runde), wie in\n    [Letzter Zug](#letzter-zug) definiert\n\n-   condition Spielergebnis, wie in [Spielergebnis](#spielende)\n    definiert; nur zum Spielende\n\n<!-- -->\n\n    <state class=\"state\" turn=\"Z\" startPlayer=\"S\" currentPlayer=\"C\">\n      red\n      blue\n      [board]\n      [lastMove]\n      [condition]\n    </state>\n\n## Spieler\n\n-   c Farbe (red/blue)\n\n-   C Farbe (RED/BLUE)\n\n<!-- -->\n\n    <c displayName=\"N\" color=\"C\" />\n\n## Spielbrett\n\n-   FIELD Ein Spielfeld wie in [Spielfeld](#spielfeld) definiert.\n\n<!-- -->\n\n    <board>\n      <fields>\n        <field x=\"0\" y=\"0\" state=\"EMPTY\" />\n        ...\n        FIELD\n        ...\n        <field x=\"0\" y=\"9\" state=\"EMPTY\" />\n      </fields>\n      ...\n      <fields>\n        <field x=\"9\" y=\"0\" state=\"EMPTY\" />\n        ...\n        FIELD\n        ...\n        <field x=\"9\" y=\"9\" state=\"EMPTY\" />\n      </fields>\n    </board>\n\n## Spielfeld\n\n-   X X-Koordinate\n\n-   Y Y-Koordinate\n\n-   STATE Zustand des Feldes (RED,BLUE,OBSTRUCTED,EMPTY)\n\n<!-- -->\n\n    <field x=\"X\" y=\"Y\" state=\"STATE\" />\n\n## Letzter Zug\n\nDer letzte Zug ist ein Move (siehe hierzu [ZUG](#zug)).\n\n    <lastMove>\n      ZUG\n    </lastMove>\n\n# Zug-Anforderung\n\nEine einfache Nachricht fordert zum Zug auf:\n\n    <room roomId=\"RID\">\n      <data class=\"sc.framework.plugins.protocol.MoveRequest\" />\n    </room>\n\n# Fehler\n\nEin “spielfähiger” :t[Computerspieler]{#player} muss nicht mit Fehlern umgehen können.\nFehlerhafte Züge beispielsweise resultieren in einem vorzeitigen Ende\ndes Spieles, das im nächsten gesendeten Gamestate erkannt werden kann\n(siehe [Spielergebnis](#spielende)).\n\n-   MSG Fehlermeldung\n\n<!-- -->\n\n    <room roomId=\"RID\">\n      <error message=\"MSG\">\n        <originalRequest>\n          Request, der den Fehler verursacht hat\n        </originalRequest>\n      </error>\n    </room>\n\n# Spiel verlassen\n\nWenn ein :t[Computerspieler]{#player} den Raum verlässt, bekommen die anderen Clients eine\nentsprechende Meldung vom Server.\n\n-   ROOM\\_ID Id des GameRooms\n\n<!-- -->\n\n    <left roomId=\"ROOM_ID\" />\n\n# Spielergebnis\n\nZum Spielende enthält der Spieler das Ergebnis:\n\n-   ROOM\\_ID Id des GameRooms\n\n-   R1, R2 Text, der den Grund für das Spielende erklärt\n\n-   CAUSE1, CAUSE2 Grund des Spielendes\n    (REGULAR/LEFT/RULE\\_VIOLATION/SOFT\\_TIMEOUT/HARD\\_TIMEOUT)\n\n-   WP1, WP2 Siegpunkte der jeweiligen Spieler, 0 verloren, 1\n    unentschieden, 2 gewonnen\n\n-   NAME Anzeigename des Spielers\n\n-   COLOR Farbe des Siegers\n\n-   S3 S1 oder S2 je nachdem wer gewonnen hat\n\n<!-- -->\n\n    <room roomId=\"ROOM_ID\">\n      <data class=\"result\">\n        <definition>\n          <fragment name=\"Gewinner\">\n            <aggregation>SUM</aggregation>\n            <relevantForRanking>true</relevantForRanking>\n          </fragment>\n          <fragment name=\"Ø Schwarm\">\n            <aggregation>AVERAGE</aggregation>\n            <relevantForRanking>true</relevantForRanking>\n          </fragment>\n        </definition>\n        <score cause=\"CAUSE1\" reason=\"R1\">\n          <part>WP1</part>\n          <part>S1</part>\n        </score>\n        <score cause=\"CAUSE2\" reason=\"R2\">\n          <part>WP2</part>\n          <part>S2</part>\n        </score>\n        <winner class=\"player\" displayName=\"NAME\" color=\"COLOR\" />\n      </data>\n    </room>\n\n# Spielverlauf\n\nDer Server startet (StandardIp: localhost 13050).\n\nNun gibt es zwei Varianten ein Spiel zu starten, eine durch einen\nAdministratorclient die andere durch hinzufügen der Spieler zu einen\nSpieltyp:\n\n## Variante 1 (AdminClient [Mit Reservierungscode](#mit-reservierungscode))\n\nEin :t[Computerspieler]{#player} registriert sich als Administrator mit dem in\nserver.properties festgelegten Passwort p:\n\n    <protocol><authenticate passphrase=\"p\" />\n\nDann kann ein Spiel angelegt werden:\n\n    <prepare gameType=\"swc_2019_piranhas\">\n      <slot displayName=\"p1\" canTimeout=\"false\" shouldBePaused=\"true\" />\n      <slot displayName=\"p2\" canTimeout=\"false\" shouldBePaused=\"true\" />\n    </prepare>\n\nDer Server antwortet darauf mit einer Nachricht, die die ROOM\\_ID und\nReservierungscodes für die beiden Clients enthält:\n\n    <protocol>\n      <prepared roomId=\"871faccb-5190-4e44-82fc-6cdcbb493726\">\n        <reservation>RC1</reservation>\n        <reservation>RC2</reservation>\n      </prepared>\n\nDer Administratorclient kann nur ebenfalls als Observer des Spiels\ngenutzt werden, indem ein entsprechender Request gesendet wird. Dadurch\nwird das derzeitge Spielfeld ([memento](#memento)) ebenfalls an den\nAdministratorclient gesendet.\n\n    <observe roomId=\"871faccb-5190-4e44-82fc-6cdcbb493726\" />\n\nClients die auf dem Serverport (localhost 13050) gestartet werden können\nso über diesen Code joinen.\n\n    <protocol>\n      <joinPrepared reservationCode=\"RC1\" />\n\n    <protocol>\n      <joinPrepared reservationCode=\"RC2\" />\n\n## Variante 2 ((eventuell) ohne AdminClient [Ohne Reservierungscode](#ohne-reservierungscode))\n\nDie Clients wurden auf dem Serverport (Standard: localhost 13050)\ngestartet.\n\nSie können sich mit folgender Anfrage einen bereits offenen Spiel\ngleichen Typs beitreten oder, falls kein Spiel des Typs vorhanden selbst\neines starten:\n\n    <protocol>\n      <join gameType=\"swc_2019_piranhas\" />\n\nDer Server antwortet mit:\n\n    <protocol>\n      <joined roomId=\"871faccb-5190-4e44-82fc-6cdcbb493726\" />\n\n## Weiterer Spielverlauf\n\nDer Server antwortet jeweils mit der WelcomeMessage ([Welcome\nMessage](#welcome-message)) und dem ersten GameState\n([memento](#memento)) sobald beide Spieler verbunden sind.\n\n    <room roomId=\"871faccb-5190-4e44-82fc-6cdcbb493726\">\n      <data class=\"welcomeMessage\" color=\"red\" />\n    </room>\n    <room roomId=\"871faccb-5190-4e44-82fc-6cdcbb493726\">\n      <data class=\"memento\">\n        <state class=\"state\" turn=\"0\" startPlayer=\"RED\" currentPlayer=\"RED\">\n          <red displayName=\"Unknown\" color=\"RED\" />\n          <blue displayName=\"Unknown\" color=\"BLUE\" />\n          <board>\n            <fields>\n              <field x=\"0\" y=\"0\" state=\"EMPTY\" />\n              ...\n              <field x=\"0\" y=\"9\" state=\"EMPTY\" />\n            </fields>\n            ...\n            <fields>\n              <field x=\"9\" y=\"0\" state=\"EMPTY\" />\n              ...\n              <field x=\"9\" y=\"9\" state=\"EMPTY\" />\n            </fields>\n          </board>\n        </state>\n      </data>\n    </room>\n\nDer erste Spieler erhält dann eine Zugaufforderung\n([MoveRequest](#move-request)), falls in server.properties paused auf\nfalse gesetzt wurde. Falls das Spiel pausiert ist, muss das Spiel durch\neinen Administratorclient gestartet werden:\n\nVerbinden des Administratorclients (falls es sich um die erste\nKontaktaufnahme zum Server handelt, ansonsten &lt;protocol&gt;\nweglassen).\n\n    <protocol>\n      <authenticate passphrase=\"examplepassword\" />\n\nPausierung aufheben:\n\n    <pause roomId=\"871faccb-5190-4e44-82fc-6cdcbb493726\" pause=\"false\" />\n\nDaraufhin wird der erste Spieler aufgefordert einen Zug zu senden:\n\n    <room roomId=\"871faccb-5190-4e44-82fc-6cdcbb493726\">\n      <data class=\"sc.framework.plugins.protocol.MoveRequest\" />\n    </room>\n\nDer :t[Computerspieler]{#player} des CurrentPlayer sendet nun einen Zug ([ZUG](#zug)):\n\n    <room roomId=\"871faccb-5190-4e44-82fc-6cdcbb493726\">\n      <data class=\"move\" x=\"0\" y=\"0\" direction=\"UP\" />\n    </room>\n\nSo geht es abwechselnd weiter, bis zum Spielende\n([Spielergebnis](#spielende)). Die letzte Nachricht des Servers endet\nmit:\n\n    </protocol>\n\nDanach wird die Verbindung geschlossen.\n","data":{},"elements":["t"]}},{"folder":"book","path":{"directory":"xml","absolute":"/home/runner/work/docs/docs/hyperbook/.hyperbook/book/xml/administration.md","relative":"xml/administration.md","href":"/xml/administration"},"extension":".md","name":"administration","root":"/home/runner/work/docs/docs/hyperbook/.hyperbook","markdown":{"content":"\n## Administration\n\nMit einem authentifizierten Client kann man den Server steuern.\n\n### Verbindungsaufbau\n\nZuerst muss sich ein Client mit dem entsprechenden Passwort aus `server.properties` authentifizieren:\n\n```xml\n<protocol><authenticate password=\"examplepassword\"/>\n```\n\nEin authentifizierter AdminClient wird benachrichtigt, \nwenn sich ein :t[Computerspieler]{#player} über ein `JoinRoomRequest` verbindet:\n\n```xml\n<joinedGameRoom roomId=ROOMID playerCount=X />\n```\n\n- **roomId**: eine vom Server generierte Zeichenfolge, die die Partie identifiziert\n\n- **playerCount**: die Anzahl der Spieler im Raum nach dem Beitritt des neuen Spielers\n\n### Aktionen in einem Raum\n\nEin AdminClient kann sich als Beobachter eines Raums registrieren lassen,\ndadurch erhält er alle Nachrichten, die das Spiel betreffen:\n\n```xml\n<observe roomId=ROOMID />\n```\n\nEin AdminClient kann ein Spiel pausieren oder fortsetzen:\n\n```xml\n<pause roomId=ROOMID pause=\"true/false\" />\n```\n\nEin AdminClient kann den nächsten Zug in einem pausierten Spiel anfordern:\n\n```xml\n<step roomId=ROOMID />\n```\n\nEin AdminClient kann ein Spiel abbrechen:\n\n```xml\n<cancel roomId=ROOMID />\n```\n\nEin AdminClient kann einen Spielraum vorbereiten:\n\n```xml\n<prepare gameType=\"pluginId\" pause=\"true\">\n  <slot displayName=\"p1\" canTimeout=\"true\" reserved=\"true\"/>\n  <slot displayName=\"p2\" canTimeout=\"true\" reserved=\"true\"/>\n</prepare>\n```\n\n- **pluginId**: identifiziert das Spiel (für Hey, Danke für den Fisch: `swc_2023_pengins`)\n- **pause**: ob das angelegte Spiel nach Beitritt aller Spieler pausiert startet\n\nHierauf antwortet der Server ggf. mit Reservierungscodes für die Spieler zum Beitreten.\n\n### Servereinstellungen\n\nDer Server lässt sich in der `server.properties` Datei konfigurieren,\ndie zusammen mit dem Server heruntergeladen wird.\nIn ihr können folgende Werte konfiguriert werden:\n\n- **password**: lokales Administratorpasswort (standardmäßig auf `examplepassword`)\n- **paused**: ob ein automatisch angelegtes Spiel anfangs pausiert sein soll oder nicht (standardmäßig pausiert)\n","data":{"name":"Verwaltung von Spielen mittels authentifiziertem  Client","index":3},"elements":["t"]}},{"folder":"book","path":{"directory":"xml","absolute":"/home/runner/work/docs/docs/hyperbook/.hyperbook/book/xml/protokoll.md","relative":"xml/protokoll.md","href":"/xml/protokoll"},"extension":".md","name":"protokoll","root":"/home/runner/work/docs/docs/hyperbook/.hyperbook","markdown":{"content":"\n# Die XML-Schnittstelle zum Server\n\nDer :t[Spielleiter]{#server} kommuniziert mit den Computerspielern über eine Netzwerkverbindung.\nDadurch ist man aus technischer Sicht komplett flexibel, was die Wahl der Programmiersprache angeht.\nDie :t[Computerspieler]{#player} müssen lediglich das Kommunikationsprotokoll erfüllen.\n\nAnfängern wird allerdings davon abgeraten, einen komplett eigenen Computerspieler zu schreiben.\nEs ist deutlich einfacher, auf einer bereitgestellten Spielervorlage aufzubauen,\nda man sich dabei nur um die Strategie und nicht um die Kommunikation kümmern muss.\nAußerdem wird vom Institut für Informatik die beste Unterstützung für Java/Kotlin geboten.\n\n:::alert{warn}\nIm Verlauf des Wettbewerbes können Elemente zur Kommunikationsschnittstelle hinzugefügt werden,\ndie in dieser Dokumentation nicht aufgeführt sind.\nDamit ein Computerspieler auch bei solchen Änderungen fehlerfrei mit dem Server kommunizieren kann,\nsollten beim Auslesen des :t[XML]{#xml} jegliche Daten verworfen werden,\ndie hier nicht weiter definiert sind.\n:::\n\n:::alert{info}\nDie bereitgestellten Programme\n(Server, Java-Spieler) nutzen eine Bibliothek namens XStream,\num Java-Objekte direkt in :t[XML]{#xml} zu konvertieren und umgekehrt.\nDabei werden XML-Nachrichten nicht unbedingt mit einem Zeilenumbruch abgeschlossen.\n:::\n\nSpielspezifische Elemente werden in der Dokumentation des jeweiligen Spiels dokumentiert.\n\n## Der Aufbau\n\n:::plantuml\n@startuml\nnode \"Server\" as server {\n    artifact \"Spielleiter\" as serverApp\n}\nnode \"Spieler 1\" as client1 {\n    artifact \"Spielervorlage\" as client1App\n}\nnode \"Spieler 2\" as client2 {\n    artifact \"Spielervorlage\" as client2App\n}\nserverApp --> client1App : Sendet Status und Anfragen in XML\nserverApp --> client2App : Sendet Status und Anfragen in XML\nclient1App --> serverApp : Sendet Zug in XML\nclient2App --> serverApp : Sendet Zug in XML\n@enduml\n:::\n\nDie Darstellung skizziert die Architektur unseres Spielsystems,\nbestehend aus dem Server als :t[Spielleiter]{#server} und zwei Spielern.\nDer Server verwaltet das Spielgeschehen\nund interagiert über das XML-Protokoll mit den beiden Spielern,\ndie jeweils auf einer Spielervorlage aufbauen.\n\n## Das Spielprotokoll\n\nIn diesem Abschnitt wird die spielunabhängige Kommunikationsschnittstelle für Spieler festgehalten,\num das Schreiben eines komplett eigenen Clients zu ermöglichen.\n\n### Spiel betreten\n\n```xml\n<protocol>\n```\n\nDieses Tag eröffnet die Kommunikation mit dem Server. Dann gibt es drei Möglichkeiten, einer Spielpartie beizutreten.\n\n#### Beliebige Partie\n\nBetritt eine beliebige offene Spielpartie:\n\n```xml\n<join />\n```\n\nSollte kein Spiel offen sein, wird automatisch ein neues erstellt. Abhängig von der Einstellung `paused` in `server.properties` wird das Spiel pausiert, gestartet oder nicht.\n\n#### Bestimmte Partie\n\nEiner bestimmten, bereits offenen, aber noch nicht gestarteten Partie kann durch Angabe der `ROOM_ID` beigetreten werden:\n\n```xml\n<joinRoom roomId=\"ROOM_ID\" />\n```\n\n#### Mit Reservierung\n\nUnter Angabe eines Reservierungscodes kann man einen reservierten Platz in einer geplanten Partie einnehmen:\n\n```xml\n<joinPrepared reservationCode=\"RESERVATION\" />\n```\n\n#### Antwort nach der Verbindung\n\nDer Server antwortet auf einen erfolgreichen Spielbeitritt mit:\n\n```xml\n<joined roomId=\"ROOM_ID\" />\n```\n\n- **ROOM_ID**\n  - Identifikationscode der Spielpartie\n\n### Spielverlauf\nFolgend werden die spiel spezifischen Punkte des XML-Protokolls erläutert, welche sich in jedem Jahr ändern und auch am Anfang der Saison noch Änderungen unterliegen kann.\n#### Start\n\nDer Server eröffnet das Spiel mit einer Begrüßung und dem initialen Spielstatus, sobald beide Spieler verbunden sind.\n\n- **ROOM_ID**\n  - Identifikationscode der Spielpartie\n\n- **TEAMNUMBER**\n  - Spielernummer, eg. `ONE`, `TWO`\n\n#### Syntax der Willkommensnachricht\n\n\n```xml\n<room roomId=\"ROOM_ID\">\n  <data class=\"welcomeMessage\" color=\"TEAMNUMBER\"></data>\n</room>\n<room roomId=\"ROOM_ID\">\n  <data class=\"memento\">\n    SPIELSTATUS\n  </data>\n</room>\n```\n\n#### Spielablauf\n\nDer erste Spieler erhält dann eine Zugaufforderung:\n\n```xml\n<room roomId=\"ROOM_ID\">\n  <data class=\"moveRequest\" />\n</room>\n```\n\nWorauf dieser innerhalb der erlaubten Zeitspanne mit einem spielspezifischen Zug antwortet.\n\n","data":{"name":"XML-Protokoll","index":2},"elements":["t","alert","plantuml"]}}],"navigation":{"next":{"name":"Überblick","index":1,"repo":"https://github.com/software-challenge/docs/tree/main/hyperbook/book/index.md","href":"/"},"current":null,"previous":null,"sections":[{"name":"Spiele","index":1,"virtual":true,"isEmpty":true,"pages":[],"sections":[{"name":"Blokus","hide":true,"isEmpty":false,"pages":[],"sections":[{"name":"Spielregeln","hide":true,"isEmpty":true,"pages":[{"name":"content","repo":"https://github.com/software-challenge/docs/tree/main/hyperbook/book/spiele/blokus/spielregeln/content.md","href":"/spiele/blokus/spielregeln/content"},{"name":"regeln","repo":"https://github.com/software-challenge/docs/tree/main/hyperbook/book/spiele/blokus/spielregeln/regeln.md","href":"/spiele/blokus/spielregeln/regeln"}],"sections":[],"repo":"https://github.com/software-challenge/docs/tree/main/hyperbook/book/spiele/blokus/spielregeln/index.md","href":"/spiele/blokus/spielregeln"},{"name":"XML-Dokumentation","hide":true,"isEmpty":true,"pages":[{"name":"einleitung-xml","repo":"https://github.com/software-challenge/docs/tree/main/hyperbook/book/spiele/blokus/xml-dokumentation/einleitung-xml.md","href":"/spiele/blokus/xml-dokumentation/einleitung-xml"},{"name":"spiel-betreten","repo":"https://github.com/software-challenge/docs/tree/main/hyperbook/book/spiele/blokus/xml-dokumentation/spiel-betreten.md","href":"/spiele/blokus/xml-dokumentation/spiel-betreten"},{"name":"spiel-verlassen","repo":"https://github.com/software-challenge/docs/tree/main/hyperbook/book/spiele/blokus/xml-dokumentation/spiel-verlassen.md","href":"/spiele/blokus/xml-dokumentation/spiel-verlassen"},{"name":"spielergebnis","repo":"https://github.com/software-challenge/docs/tree/main/hyperbook/book/spiele/blokus/xml-dokumentation/spielergebnis.md","href":"/spiele/blokus/xml-dokumentation/spielergebnis"},{"name":"spielstatus","repo":"https://github.com/software-challenge/docs/tree/main/hyperbook/book/spiele/blokus/xml-dokumentation/spielstatus.md","href":"/spiele/blokus/xml-dokumentation/spielstatus"},{"name":"spielsteine","repo":"https://github.com/software-challenge/docs/tree/main/hyperbook/book/spiele/blokus/xml-dokumentation/spielsteine.md","href":"/spiele/blokus/xml-dokumentation/spielsteine"},{"name":"spielverlauf","repo":"https://github.com/software-challenge/docs/tree/main/hyperbook/book/spiele/blokus/xml-dokumentation/spielverlauf.md","href":"/spiele/blokus/xml-dokumentation/spielverlauf"},{"name":"xml-dokumentation","repo":"https://github.com/software-challenge/docs/tree/main/hyperbook/book/spiele/blokus/xml-dokumentation/xml-dokumentation.md","href":"/spiele/blokus/xml-dokumentation/xml-dokumentation"},{"name":"zuege-senden","repo":"https://github.com/software-challenge/docs/tree/main/hyperbook/book/spiele/blokus/xml-dokumentation/zuege-senden.md","href":"/spiele/blokus/xml-dokumentation/zuege-senden"},{"name":"zug-anforderung","repo":"https://github.com/software-challenge/docs/tree/main/hyperbook/book/spiele/blokus/xml-dokumentation/zug-anforderung.md","href":"/spiele/blokus/xml-dokumentation/zug-anforderung"}],"sections":[],"repo":"https://github.com/software-challenge/docs/tree/main/hyperbook/book/spiele/blokus/xml-dokumentation/index.md","href":"/spiele/blokus/xml-dokumentation"}],"repo":"https://github.com/software-challenge/docs/tree/main/hyperbook/book/spiele/blokus/index.md","href":"/spiele/blokus"},{"name":"Hase und Igel","hide":true,"isEmpty":false,"pages":[],"sections":[{"name":"Spielregeln","hide":true,"isEmpty":true,"pages":[{"name":"beispiel","repo":"https://github.com/software-challenge/docs/tree/main/hyperbook/book/spiele/hase-und-igel/spielregeln/beispiel.md","href":"/spiele/hase-und-igel/spielregeln/beispiel"},{"name":"felder","repo":"https://github.com/software-challenge/docs/tree/main/hyperbook/book/spiele/hase-und-igel/spielregeln/felder.md","href":"/spiele/hase-und-igel/spielregeln/felder"},{"name":"regeln","repo":"https://github.com/software-challenge/docs/tree/main/hyperbook/book/spiele/hase-und-igel/spielregeln/regeln.md","href":"/spiele/hase-und-igel/spielregeln/regeln"},{"name":"spielbeginn","repo":"https://github.com/software-challenge/docs/tree/main/hyperbook/book/spiele/hase-und-igel/spielregeln/spielbeginn.md","href":"/spiele/hase-und-igel/spielregeln/spielbeginn"},{"name":"spielende","repo":"https://github.com/software-challenge/docs/tree/main/hyperbook/book/spiele/hase-und-igel/spielregeln/spielende.md","href":"/spiele/hase-und-igel/spielregeln/spielende"},{"name":"zuege","repo":"https://github.com/software-challenge/docs/tree/main/hyperbook/book/spiele/hase-und-igel/spielregeln/zuege.md","href":"/spiele/hase-und-igel/spielregeln/zuege"}],"sections":[],"repo":"https://github.com/software-challenge/docs/tree/main/hyperbook/book/spiele/hase-und-igel/spielregeln/index.md","href":"/spiele/hase-und-igel/spielregeln"},{"name":"Tutorial","hide":true,"isEmpty":true,"pages":[{"name":"board","repo":"https://github.com/software-challenge/docs/tree/main/hyperbook/book/spiele/hase-und-igel/tutorial/board.md","href":"/spiele/hase-und-igel/tutorial/board"},{"name":"game-rule-logic","repo":"https://github.com/software-challenge/docs/tree/main/hyperbook/book/spiele/hase-und-igel/tutorial/game-rule-logic.md","href":"/spiele/hase-und-igel/tutorial/game-rule-logic"},{"name":"player","repo":"https://github.com/software-challenge/docs/tree/main/hyperbook/book/spiele/hase-und-igel/tutorial/player.md","href":"/spiele/hase-und-igel/tutorial/player"},{"name":"start","repo":"https://github.com/software-challenge/docs/tree/main/hyperbook/book/spiele/hase-und-igel/tutorial/start.md","href":"/spiele/hase-und-igel/tutorial/start"},{"name":"tutorial","repo":"https://github.com/software-challenge/docs/tree/main/hyperbook/book/spiele/hase-und-igel/tutorial/tutorial.md","href":"/spiele/hase-und-igel/tutorial/tutorial"}],"sections":[],"repo":"https://github.com/software-challenge/docs/tree/main/hyperbook/book/spiele/hase-und-igel/tutorial/index.md","href":"/spiele/hase-und-igel/tutorial"},{"name":"XML-Dokumentation","hide":true,"isEmpty":true,"pages":[{"name":"einleitung-xml","repo":"https://github.com/software-challenge/docs/tree/main/hyperbook/book/spiele/hase-und-igel/xml-dokumentation/einleitung-xml.md","href":"/spiele/hase-und-igel/xml-dokumentation/einleitung-xml"},{"name":"fehler","repo":"https://github.com/software-challenge/docs/tree/main/hyperbook/book/spiele/hase-und-igel/xml-dokumentation/fehler.md","href":"/spiele/hase-und-igel/xml-dokumentation/fehler"},{"name":"spiel-betreten","repo":"https://github.com/software-challenge/docs/tree/main/hyperbook/book/spiele/hase-und-igel/xml-dokumentation/spiel-betreten.md","href":"/spiele/hase-und-igel/xml-dokumentation/spiel-betreten"},{"name":"spiel-verlassen","repo":"https://github.com/software-challenge/docs/tree/main/hyperbook/book/spiele/hase-und-igel/xml-dokumentation/spiel-verlassen.md","href":"/spiele/hase-und-igel/xml-dokumentation/spiel-verlassen"},{"name":"spielergebnis","repo":"https://github.com/software-challenge/docs/tree/main/hyperbook/book/spiele/hase-und-igel/xml-dokumentation/spielergebnis.md","href":"/spiele/hase-und-igel/xml-dokumentation/spielergebnis"},{"name":"spielstatus","repo":"https://github.com/software-challenge/docs/tree/main/hyperbook/book/spiele/hase-und-igel/xml-dokumentation/spielstatus.md","href":"/spiele/hase-und-igel/xml-dokumentation/spielstatus"},{"name":"spielverlauf","repo":"https://github.com/software-challenge/docs/tree/main/hyperbook/book/spiele/hase-und-igel/xml-dokumentation/spielverlauf.md","href":"/spiele/hase-und-igel/xml-dokumentation/spielverlauf"},{"name":"xml-dokumentation","repo":"https://github.com/software-challenge/docs/tree/main/hyperbook/book/spiele/hase-und-igel/xml-dokumentation/xml-dokumentation.md","href":"/spiele/hase-und-igel/xml-dokumentation/xml-dokumentation"},{"name":"zuege-senden","repo":"https://github.com/software-challenge/docs/tree/main/hyperbook/book/spiele/hase-und-igel/xml-dokumentation/zuege-senden.md","href":"/spiele/hase-und-igel/xml-dokumentation/zuege-senden"},{"name":"zug-anforderung","repo":"https://github.com/software-challenge/docs/tree/main/hyperbook/book/spiele/hase-und-igel/xml-dokumentation/zug-anforderung.md","href":"/spiele/hase-und-igel/xml-dokumentation/zug-anforderung"}],"sections":[],"repo":"https://github.com/software-challenge/docs/tree/main/hyperbook/book/spiele/hase-und-igel/xml-dokumentation/index.md","href":"/spiele/hase-und-igel/xml-dokumentation"}],"repo":"https://github.com/software-challenge/docs/tree/main/hyperbook/book/spiele/hase-und-igel/index.md","href":"/spiele/hase-und-igel"},{"name":"Hase und Igel","expanded":true,"isEmpty":false,"pages":[{"name":"xml","repo":"https://github.com/software-challenge/docs/tree/main/hyperbook/book/spiele/25_hase-und-igel/xml.md","href":"/spiele/25_hase-und-igel/xml"}],"sections":[{"name":"Tutorial","hide":true,"isEmpty":true,"pages":[{"name":"board","repo":"https://github.com/software-challenge/docs/tree/main/hyperbook/book/spiele/25_hase-und-igel/tutorial/board.md","href":"/spiele/25_hase-und-igel/tutorial/board"},{"name":"game-rule-logic","repo":"https://github.com/software-challenge/docs/tree/main/hyperbook/book/spiele/25_hase-und-igel/tutorial/game-rule-logic.md","href":"/spiele/25_hase-und-igel/tutorial/game-rule-logic"},{"name":"player","repo":"https://github.com/software-challenge/docs/tree/main/hyperbook/book/spiele/25_hase-und-igel/tutorial/player.md","href":"/spiele/25_hase-und-igel/tutorial/player"},{"name":"start","repo":"https://github.com/software-challenge/docs/tree/main/hyperbook/book/spiele/25_hase-und-igel/tutorial/start.md","href":"/spiele/25_hase-und-igel/tutorial/start"},{"name":"tutorial","repo":"https://github.com/software-challenge/docs/tree/main/hyperbook/book/spiele/25_hase-und-igel/tutorial/tutorial.md","href":"/spiele/25_hase-und-igel/tutorial/tutorial"}],"sections":[],"repo":"https://github.com/software-challenge/docs/tree/main/hyperbook/book/spiele/25_hase-und-igel/tutorial/index.md","href":"/spiele/25_hase-und-igel/tutorial"}],"repo":"https://github.com/software-challenge/docs/tree/main/hyperbook/book/spiele/25_hase-und-igel/index.md","href":"/spiele/25_hase-und-igel"},{"name":"Hey, Danke für den Fisch!","hide":true,"expanded":true,"isEmpty":false,"pages":[{"name":"Spielregeln","index":1,"repo":"https://github.com/software-challenge/docs/tree/main/hyperbook/book/spiele/penguins/regeln.md","href":"/spiele/penguins/regeln"},{"name":"XML-Schnittstelle","repo":"https://github.com/software-challenge/docs/tree/main/hyperbook/book/spiele/penguins/xml.md","href":"/spiele/penguins/xml"}],"sections":[],"repo":"https://github.com/software-challenge/docs/tree/main/hyperbook/book/spiele/penguins/index.md","href":"/spiele/penguins"},{"name":"Hive","hide":true,"isEmpty":false,"pages":[],"sections":[{"name":"Spielregeln","hide":true,"isEmpty":true,"pages":[{"name":"regeln","repo":"https://github.com/software-challenge/docs/tree/main/hyperbook/book/spiele/hive/spielregeln/regeln.md","href":"/spiele/hive/spielregeln/regeln"}],"sections":[],"repo":"https://github.com/software-challenge/docs/tree/main/hyperbook/book/spiele/hive/spielregeln/index.md","href":"/spiele/hive/spielregeln"},{"name":"XML-Dokumention","hide":true,"isEmpty":true,"pages":[{"name":"einleitung-xml","repo":"https://github.com/software-challenge/docs/tree/main/hyperbook/book/spiele/hive/xml-dokumentation/einleitung-xml.md","href":"/spiele/hive/xml-dokumentation/einleitung-xml"},{"name":"fehler","repo":"https://github.com/software-challenge/docs/tree/main/hyperbook/book/spiele/hive/xml-dokumentation/fehler.md","href":"/spiele/hive/xml-dokumentation/fehler"},{"name":"spiel-betreten","repo":"https://github.com/software-challenge/docs/tree/main/hyperbook/book/spiele/hive/xml-dokumentation/spiel-betreten.md","href":"/spiele/hive/xml-dokumentation/spiel-betreten"},{"name":"spiel-verlassen","repo":"https://github.com/software-challenge/docs/tree/main/hyperbook/book/spiele/hive/xml-dokumentation/spiel-verlassen.md","href":"/spiele/hive/xml-dokumentation/spiel-verlassen"},{"name":"spielergebnis","repo":"https://github.com/software-challenge/docs/tree/main/hyperbook/book/spiele/hive/xml-dokumentation/spielergebnis.md","href":"/spiele/hive/xml-dokumentation/spielergebnis"},{"name":"spielstatus","repo":"https://github.com/software-challenge/docs/tree/main/hyperbook/book/spiele/hive/xml-dokumentation/spielstatus.md","href":"/spiele/hive/xml-dokumentation/spielstatus"},{"name":"spielverlauf","repo":"https://github.com/software-challenge/docs/tree/main/hyperbook/book/spiele/hive/xml-dokumentation/spielverlauf.md","href":"/spiele/hive/xml-dokumentation/spielverlauf"},{"name":"xml-dokumentation","repo":"https://github.com/software-challenge/docs/tree/main/hyperbook/book/spiele/hive/xml-dokumentation/xml-dokumentation.md","href":"/spiele/hive/xml-dokumentation/xml-dokumentation"},{"name":"zuege-senden","repo":"https://github.com/software-challenge/docs/tree/main/hyperbook/book/spiele/hive/xml-dokumentation/zuege-senden.md","href":"/spiele/hive/xml-dokumentation/zuege-senden"},{"name":"zug-anforderung","repo":"https://github.com/software-challenge/docs/tree/main/hyperbook/book/spiele/hive/xml-dokumentation/zug-anforderung.md","href":"/spiele/hive/xml-dokumentation/zug-anforderung"}],"sections":[],"repo":"https://github.com/software-challenge/docs/tree/main/hyperbook/book/spiele/hive/xml-dokumentation/index.md","href":"/spiele/hive/xml-dokumentation"}],"repo":"https://github.com/software-challenge/docs/tree/main/hyperbook/book/spiele/hive/index.md","href":"/spiele/hive"},{"name":"Mississippi Queen","hide":true,"isEmpty":false,"pages":[{"name":"Spielregeln","index":1,"repo":"https://github.com/software-challenge/docs/tree/main/hyperbook/book/spiele/mississippi-queen/regeln.md","href":"/spiele/mississippi-queen/regeln"},{"name":"XML-Elemente","index":2,"repo":"https://github.com/software-challenge/docs/tree/main/hyperbook/book/spiele/mississippi-queen/xml.md","href":"/spiele/mississippi-queen/xml"}],"sections":[],"repo":"https://github.com/software-challenge/docs/tree/main/hyperbook/book/spiele/mississippi-queen/index.md","href":"/spiele/mississippi-queen"},{"name":"Ostseeschach","hide":true,"isEmpty":false,"pages":[{"name":"regeln","repo":"https://github.com/software-challenge/docs/tree/main/hyperbook/book/spiele/ostseeschach/regeln.md","href":"/spiele/ostseeschach/regeln"},{"name":"xml-dokumentation","repo":"https://github.com/software-challenge/docs/tree/main/hyperbook/book/spiele/ostseeschach/xml-dokumentation.md","href":"/spiele/ostseeschach/xml-dokumentation"}],"sections":[],"repo":"https://github.com/software-challenge/docs/tree/main/hyperbook/book/spiele/ostseeschach/index.md","href":"/spiele/ostseeschach"},{"name":"Piranhas","hide":true,"isEmpty":false,"pages":[],"sections":[{"name":"Spielregeln","hide":true,"isEmpty":true,"pages":[{"name":"regeln","repo":"https://github.com/software-challenge/docs/tree/main/hyperbook/book/spiele/piranhas/spielregeln/regeln.md","href":"/spiele/piranhas/spielregeln/regeln"}],"sections":[],"repo":"https://github.com/software-challenge/docs/tree/main/hyperbook/book/spiele/piranhas/spielregeln/index.md","href":"/spiele/piranhas/spielregeln"},{"name":"XML-Dokumentation","hide":true,"isEmpty":true,"pages":[{"name":"einleitung-xml","repo":"https://github.com/software-challenge/docs/tree/main/hyperbook/book/spiele/piranhas/xml-dokumentation/einleitung-xml.md","href":"/spiele/piranhas/xml-dokumentation/einleitung-xml"},{"name":"fehler","repo":"https://github.com/software-challenge/docs/tree/main/hyperbook/book/spiele/piranhas/xml-dokumentation/fehler.md","href":"/spiele/piranhas/xml-dokumentation/fehler"},{"name":"spiel-betreten","repo":"https://github.com/software-challenge/docs/tree/main/hyperbook/book/spiele/piranhas/xml-dokumentation/spiel-betreten.md","href":"/spiele/piranhas/xml-dokumentation/spiel-betreten"},{"name":"spiel-verlassen","repo":"https://github.com/software-challenge/docs/tree/main/hyperbook/book/spiele/piranhas/xml-dokumentation/spiel-verlassen.md","href":"/spiele/piranhas/xml-dokumentation/spiel-verlassen"},{"name":"spielergebnis","repo":"https://github.com/software-challenge/docs/tree/main/hyperbook/book/spiele/piranhas/xml-dokumentation/spielergebnis.md","href":"/spiele/piranhas/xml-dokumentation/spielergebnis"},{"name":"spielstatus","repo":"https://github.com/software-challenge/docs/tree/main/hyperbook/book/spiele/piranhas/xml-dokumentation/spielstatus.md","href":"/spiele/piranhas/xml-dokumentation/spielstatus"},{"name":"spielverlauf","repo":"https://github.com/software-challenge/docs/tree/main/hyperbook/book/spiele/piranhas/xml-dokumentation/spielverlauf.md","href":"/spiele/piranhas/xml-dokumentation/spielverlauf"},{"name":"xml-dokumentation","repo":"https://github.com/software-challenge/docs/tree/main/hyperbook/book/spiele/piranhas/xml-dokumentation/xml-dokumentation.md","href":"/spiele/piranhas/xml-dokumentation/xml-dokumentation"},{"name":"zuege-senden","repo":"https://github.com/software-challenge/docs/tree/main/hyperbook/book/spiele/piranhas/xml-dokumentation/zuege-senden.md","href":"/spiele/piranhas/xml-dokumentation/zuege-senden"},{"name":"zug-anforderung","repo":"https://github.com/software-challenge/docs/tree/main/hyperbook/book/spiele/piranhas/xml-dokumentation/zug-anforderung.md","href":"/spiele/piranhas/xml-dokumentation/zug-anforderung"}],"sections":[],"repo":"https://github.com/software-challenge/docs/tree/main/hyperbook/book/spiele/piranhas/xml-dokumentation/index.md","href":"/spiele/piranhas/xml-dokumentation"}],"repo":"https://github.com/software-challenge/docs/tree/main/hyperbook/book/spiele/piranhas/index.md","href":"/spiele/piranhas"}],"repo":"https://github.com/software-challenge/docs/tree/main/hyperbook/book/spiele/index.md","href":"/spiele"},{"name":"Entwicklung eines Computerspielers","index":2,"isEmpty":false,"pages":[{"name":"Das Spiel kennenlernen","index":1,"repo":"https://github.com/software-challenge/docs/tree/main/hyperbook/book/entwicklung/kennenlernen.md","href":"/entwicklung/kennenlernen"},{"name":"Objektorientierte Programmierung","index":3,"repo":"https://github.com/software-challenge/docs/tree/main/hyperbook/book/entwicklung/einfuehrung-oop.md","href":"/entwicklung/einfuehrung-oop"},{"name":"Sauberer Programmierstil","index":4,"repo":"https://github.com/software-challenge/docs/tree/main/hyperbook/book/entwicklung/sauberer-programmierstil.md","href":"/entwicklung/sauberer-programmierstil"},{"name":"Installation von Java","index":5,"repo":"https://github.com/software-challenge/docs/tree/main/hyperbook/book/entwicklung/installation-von-java.md","href":"/entwicklung/installation-von-java"},{"name":"Einrichtung der Entwicklungsumgebung","index":6,"repo":"https://github.com/software-challenge/docs/tree/main/hyperbook/book/entwicklung/einrichtung-der-entwicklungsumgebung.md","href":"/entwicklung/einrichtung-der-entwicklungsumgebung"},{"name":"Bedienung von Eclipse","index":7,"repo":"https://github.com/software-challenge/docs/tree/main/hyperbook/book/entwicklung/bedienung-von-eclipse.md","href":"/entwicklung/bedienung-von-eclipse"},{"name":"Spielervorlage erweitern","index":7,"repo":"https://github.com/software-challenge/docs/tree/main/hyperbook/book/entwicklung/simpleclient-erweitern.md","href":"/entwicklung/simpleclient-erweitern"},{"name":"Idee implementieren","index":8,"repo":"https://github.com/software-challenge/docs/tree/main/hyperbook/book/entwicklung/eine-idee-implementieren.md","href":"/entwicklung/eine-idee-implementieren"},{"name":"Computerspieler abgabefertig machen","index":9,"repo":"https://github.com/software-challenge/docs/tree/main/hyperbook/book/entwicklung/abgabe.md","href":"/entwicklung/abgabe"}],"sections":[],"repo":"https://github.com/software-challenge/docs/tree/main/hyperbook/book/entwicklung/index.md","href":"/entwicklung"},{"name":"Allgemeine XML-Dokumentation","index":4,"isEmpty":true,"pages":[{"name":"Einführung in XML","index":1,"repo":"https://github.com/software-challenge/docs/tree/main/hyperbook/book/xml/intro.md","href":"/xml/intro"},{"name":"XML-Protokoll","index":2,"repo":"https://github.com/software-challenge/docs/tree/main/hyperbook/book/xml/protokoll.md","href":"/xml/protokoll"},{"name":"Verwaltung von Spielen mittels authentifiziertem  Client","index":3,"repo":"https://github.com/software-challenge/docs/tree/main/hyperbook/book/xml/administration.md","href":"/xml/administration"}],"sections":[],"repo":"https://github.com/software-challenge/docs/tree/main/hyperbook/book/xml/index.md","href":"/xml"}],"pages":[{"name":"Überblick","index":1,"repo":"https://github.com/software-challenge/docs/tree/main/hyperbook/book/index.md","href":"/"},{"name":"Technische Grundlagen","index":2,"repo":"https://github.com/software-challenge/docs/tree/main/hyperbook/book/glossar.md","href":"/glossar"},{"name":"Die Software-Challenge","index":3,"expanded":true,"repo":"https://github.com/software-challenge/docs/tree/main/hyperbook/book/wettbewerb.md","href":"/wettbewerb"},{"name":"F.A.Q.","index":4,"repo":"https://github.com/software-challenge/docs/tree/main/hyperbook/book/faq.md","href":"/faq"}]}},"__N_SSG":true}