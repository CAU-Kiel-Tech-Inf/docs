{"pageProps":{"locale":"de","markdown":"\n# Der Spielleiter (Server)\n\nDie beiden [Computerspieler](player) kommunizieren nicht direkt miteinander,\nsondern spielen über einen Mittelsmann: den Spielleiter.\nDadurch ist zum einen sichergestellt,\ndass man seinen Gegner nicht mit invaliden Nachrichten belästigen kann,\nzum anderen sorgt der Spielleiter dafür,\ndass sich die Kontrahenten an die Spielregeln halten.\n\nDer Spielleiter ist direkt im [Wettkampfsystem](wettkampfsystem) integriert,\nso dass alle Turnierspiele regelkonform gespielt werden.\nZum Testen des eigenen Computerspielers gibt es eine spezielle Version des Spielleiters,\ndie im [Downloadbereich der Website](https://software-challenge.de/dokumentation-und-material) heruntergeladen werden kann.\nDiese Download-Version enthält eine grafische Oberfläche,\ndurch die man das Spiel gut verfolgen \nund sogar als Mensch mitspielen kann.\n\n## System vorbereiten und Spielleiter starten\n\nDie einzige Vorraussetzung ist, \ndass auf dem Rechner mindestens die Laufzeitumgebung für Java 9 installiert ist.\nSiehe [Installation von Java](/entwicklung/installation-von-java).\nDie herunter\n\nNach der erfolgreichen Installation kann man den Server \ndurch einen Doppelklick auf die Datei `software-challenge-gui` starten.\n\n## Die Programmoberfläche\n\nDie Programmoberfläche besteht aus einer Menüleiste oben \nsowie der Spielfläche darunter.\n\nUnter dem ersten Menüpunkt (Symbol der Software-Challenge) \nfindet man alle grundlegenden Aktionen.\n\n### Ein neues Spiel erstellen\n\nStarte ein neues Spiel mit Klick auf \"Neues Spiel starten\":\n\n![Dialog für ein neues Spiel](/images/gui/game-creation.png)\n\nIn diesem Fenster werden die Spieler ausgewählt, \ndie an dem Spiel teilnehmen sollen.\nFür jeden Spieler gibt es folgende Optionen:\n\n- **Text-Eingabefeld**: Hier kann für jeden Spieler ein Name eingegeben werden,\n  der dann im Spiel angezeigt wird.\n\n- **Spielertyp**: Es kann zwischen 4 verschiedenen Spielertypen gewählt werden:\n\n    - *Mensch*  \nEin menschlicher Spieler, der über die Programmoberfläche spielt.\n\n    - *Beispiel-Computerspieler*  \nEin Computerspieler, der im Server integriert ist.\n\n    - *Computerspieler, von GUI gestartet*  \nEin :t[Computerspieler]{#player} in Form eines separaten Programms, das beim Starten\ndes Spiels automatisch vom Server gestartet wird.\n\n    - *Manuell gestarteter Computerspieler*  \nEin :t[Computerspieler]{#player} in Form eines separaten Programms, das manuell durch\nden Benutzer gestartet werden muss.\n\nNach Eingabe der erforderlichen Werte kann das Spiel mithilfe des\nunteren Knopfs \"Erstellen\" erstellt werden.\n\n### Die Spielfeldoberfläche\n\n![Die Spielfeldoberfläche (hier mit dem Spiel \"Hey, Danke für den Fisch\")](/images/spiele/penguins/penguins_spielfeld.png \"Spielfeld\")\n\nAuf dem Spielbrett wird das eigentliche Spiel,\ndie Züge und weitere für das Spiel wichtige Informationen dargestellt.\nHier setzt der menschliche Spieler auch seine Züge.\n\nDie Steuerelemente unterscheiden sich je nach Spiel und Spielsituation.\nUnten gibt es immer die Schaltflächen \"Anhalten/Weiter\".\n\n## Spielwiederholungen (Replays)\n\n<!-- TODO Replay-Sektion im Glossar -->\n\nSpielwiederholungen oder Replay-Dateien sind aufgezeichnete frühere\nSpiele, die man sich beliebig oft wieder ansehen kann, um beispielsweise\neinen Fehler des eigenen Spielers zu analysieren oder eine Strategie zu\nverbessern.\n\nAktuell werden Replay-Dateien automatisch im Unterordner `replays`\nabgespeichert. Die im Folgenden genannten Anpassungsmöglichkeiten werden\nnoch implementiert.\n\nUm das aktuelle Spiel als Spielwiederholung zu speichern, klickt man auf\ndas Icon ganz rechts unten im Spielbereich. Dann kann man einen\nDateinamen und Speicherort festlegen.\n\nUm eine gespeicherte Spielwiederholung zu laden, verwendet man den\nEintrag \"Replay laden\" im linken Punkt der Menüleiste Nachdem man eine\nDatei ausgewählt hat, kann man das gespeicherte Spiel abspielen oder\nSchritt für Schritt durchgehen.\n\n### Spielsituation nachstellen\n\nDiese Funktionalität fehlt noch in der neuen GUI und wird dort bald auf\neinfacherem Wege verfügbar sein.\n\nWenn ein Fehlerverhalten des Computerspielers nur in einer bestimmten\nSituation in einem Spiel auftritt, kann es oft wünschenswert sein, diese\nSituation erneut nachzuspielen um den :t[Computerspieler]{#player} gezielt zu\nverbessern.\n\nDies ist zur Zeit nur auf etwas kompliziertem Wege möglich. Es folgt\neine Schritt-für-Schritt Anleitung:\n\n1.  Laden Sie das betreffende Replay aus dem :t[Wettkampfsystem]{#contest}herunter\n    (.xml.gz Datei).\n\n2.  Entpacken Sie das Replay, sodass sie eine .xml-Datei erhalten.\n\n3.  Starten Sie den Server und erstellen Sie ein neues Spiel. Wählen Sie\n    den Computerspieler, der für diese Spielsituation getestet werden\n    soll. Dieser Spieler muss als Spieler 1 gestartet werden und ist\n    dann direkt als erstes dran. Der Gegenspieler kann dann ein\n    beliebiger :t[Computerspieler]{#player} oder auch ein Mensch sein.\n\n4.  Setzen Sie einen Haken bei \"Spiel aus Datei laden\". Wählen Sie über\n    \"Datei wählen\" das entsprechende Replay aus und spezifizieren sie\n    den Zug in dem gestartet werden soll. Starten Sie dann das Spiel.\n    Das Spiel sollte sich nun in genau der Situation befinden, in der\n    das Fehlerverhalten aufgetreten ist. Dabei ist der Spieler, der nun\n    dran ist immer der rote Spieler. Falls der blaue Spieler eigentlich\n    dran war, werden die Farben der Spieler getauscht.\n\n5.  Nun kann der nächste Zug beim Spieler angefordert werden und dabei\n    durch Debugging kontrolliert werden, wo sich der Spieler falsch\n    verhalten hat. Achtung: Wenn weitere Züge angefordert werden, kann\n    das Verhalten vom normalen Spielverlauf abweichen, da evtl. nicht\n    alle Daten für das Spiel in der XML vorhanden sind.\n\n### Replay mit Server ohne graphische Oberfläche speichern\n\nWenn der Server ohne die graphische Oberfläche gestartet wird, kann das\n`--saveReplay` Attribut gesetzt werden, damit bei Ende jedes Spiels das\nReplay des Spiels unter `./replays` gespeichert wird.\n\n      java -Dfile.encoding=UTF-8 -Dlogback.configurationFile=logback.xml -jar softwarechallenge-server.jar --port 13051 --saveReplay true\n\n## Automatische Spiele: Der Testserver\n\nWenn man einen grundsätzlich funkionierenden Computerspieler\nprogrammiert hat, ist es sinnvoll, diesen mit vielen verschiedenen\nSpielsituationen zu konfrontieren. Dadurch lassen sich Fehler entdecken\nund die Spielstärke des Computerspielers beurteilen. Für solche\nTestdurchläufe wird ein Testserver und TestClient zur Verfügung\ngestellt.\n\nDer Testserver hat keine grafische Oberfläche und läuft, im Gegensatz\nzum Server mit graphischer Oberfläche (Port 13050), standardmäßig auf\nPort 13051. So kannst du ihn nutzen:\n\n1.  Lade den Testserver von der Download-Seite herunter.\n\n2.  Entpacken Sie das heruntergeladene Archiv.\n\n3.  Öffne eine Kommandozeilenumgebung (Terminal; auf Windows cmd oder\n    Powershell) im Verzeichnis des entpackten Archives.\n\n4.  Starte den Testserver auf Port 13051:\n\n        java -Dfile.encoding=UTF-8 -Dlogback.configurationFile=logback.xml -jar softwarechallenge-server.jar --port 13051\n\n5.  Starten die :t[Computerspieler]{#player} in weiteren Kommandozeilenumgebungen auf\n    Port 13051 (beim Zufallsspieler geht dies mit der Option\n    `--port 13051`). Die :t[Computerspieler]{#player} verbinden sich automatisch zum\n    Testserver und spielen ein Spiel. Danach sollten sich die\n    :t[Computerspieler]{#player} automatisch beenden.\n\n6.  Um weitere Testspiele zu spielen, starte die :t[Computerspieler]{#player} erneut.\n    Der Testserver muss dabei nicht neu gestartet werden.\n\nBeachte, dass der Testserver keine Spielaufzeichnungen anlegt, wie es\nder Server mit grafischer Oberfläche tut. Die Auswertung der Spiele muss\nin einem der teilnehmenden :t[Computerspieler]{#player} geschehen (z.B. durch\nLog-Ausgaben).\n\nEs ist ebenfalls möglich, statt eines zufällig generierten vollständigen\nSpielplanes eine Spielsituation zu laden und zu testen. Die\nSpielsituation muss vorher wie unter [Spielsituation\nnachstellen](#spielsituation-nachstellen) erzeugt werden. Dann kann die\nDatei mit dem Argument `--loadGameFile` geladen werden und optional mit\n`--turn` ein Zug spezifiziert werden.\n```shell\n      java -Dfile.encoding=UTF-8 -Dlogback.configurationFile=logback.xml -jar softwarechallenge-server.jar --port 13051 --loadGameFile ./replay.xml --turn 10\n\n```\n### Unerwartete Zugzeitüberschreitungen (Soft-Timeout)\n\nWenn Sie den Testserver einige Zeit laufen lassen, um eine größere\nAnzahl von Testspielen durchzuführen, kann es dazu kommen, dass\n:t[Computerspieler]{#player} wegen Zugzeitüberschreitungen vom Server disqualifiziert\nwerden (Soft-Timeout). Dies passiert, obwohl der Zug innerhalb der\nerlaubten Zugzeit (abhängig vom Spiel, bisher aber immer zwei Sekunden)\nan den Server geschickt wurde. Der Garbage Collector der Java Virtual\nMachine löst dieses Verhalten aus. Er pausiert die Anwendung, um nicht\nmehr genutzten Speicher freizugeben. Wenn der Server dadurch zu einem\nungünstigen Zeitpunkt angehalten wird, bemerkt er den Eingang des Zuges\nvom :t[Computerspieler]{#player} nicht rechtzeitig und disqualifiziert ihn daraufhin.\nDamit dieses Problem möglichst selten auftritt, haben sich die folgenden\nParameter beim Starten des Servers bewährt:\n\nUnter Linux:\n```shell\n    java -Dfile.encoding=UTF-8 \\\n         -Dlogback.configurationFile=logback.xml \\\n         -server \\\n         -XX:MaxGCPauseMillis=100 \\\n         -XX:GCPauseIntervalMillis=2050 \\\n         -XX:+UseConcMarkSweepGC -XX:+CMSParallelRemarkEnabled \\\n         -XX:+UseCMSInitiatingOccupancyOnly -XX:CMSInitiatingOccupancyFraction=70 \\\n         -XX:+ScavengeBeforeFullGC -XX:+CMSScavengeBeforeRemark \\\n         -jar softwarechallenge-server.jar --port 13051\n```\nUnter Windows (unterscheidet sich nur durch die Art, den langen Befehl\nauf mehrere Zeilen zu verteilen):\n```shell\n    java -Dfile.encoding=UTF-8 ^\n         -Dlogback.configurationFile=logback.xml ^\n         -server ^\n         -XX:MaxGCPauseMillis=100 ^\n         -XX:GCPauseIntervalMillis=2050 ^\n         -XX:+UseConcMarkSweepGC -XX:+CMSParallelRemarkEnabled ^\n         -XX:+UseCMSInitiatingOccupancyOnly -XX:CMSInitiatingOccupancyFraction=70 ^\n         -XX:+ScavengeBeforeFullGC -XX:+CMSScavengeBeforeRemark ^\n         -jar softwarechallenge-server.jar --port 13051\n```\nUm das Verhalten des Garbage Collectors noch weiter zu verbessern, kann\nman auch noch mittels der Optionen\n```shell\n    -XX:+PrintGCDateStamps -XX:+PrintGC -XX:+PrintGCDetails -Xloggc:\"pfad_zum_gc.log\"\n```\neine Logdatei über die Aktivitäten des Garbage Collectors anlegen. Darin\nsieht man genau, wann er wie lange lief. Man kann dann die Einstellungen\nverändern und testen, ob sich das Verhalten verbessert.\n\nDie Konfiguration des Garbage Collectors ist kein Allheilmittel \nund kann zu neuen Problemen führen, auf die man gefasst sein sollte.\nDazu gehören erhöhter Resourcenverbrauch und Instabilität der Anwendung.\n\nEine Auflistung möglicher nützlicher Parameter für :t[Computerspieler]{#player} findet sich unter\nhttps://stackoverflow.com/questions/48989515/java-garbage-collector-time-limit.\n\n### Massentests\n\nMassentests mit dem eigenen :t[Computerspieler]{#player} können sehr nützlich sein,\nbeispeilsweise um die Stärke gegenüber einer früheren Version zu Testen.\nDafür wird in jeder Saison ab Version XX.1.0 ein TestClient\nbereitgestellt.\n\nDer TestClient muss vom Terminal mit den entsprechenden Argumenten\naufgerufen werden. Diese werden unter den Beispielen näher erläutert.\n\nUnter Linux:\n```shell\n    java -jar -Dlogback.configurationFile=logback-tests.xml test-client.jar \\\n        --tests 4 \\\n        --name1 \"displayName1\" \\\n        --player1 \"./player1.jar\" \\\n        --name2 \"displayName2\" \\\n        --player2 \"./player2.jar\" \\\n        --start-server \\\n        --port 13051\n```\nUnter Windows (unterscheidet sich nur durch die Art, den langen Befehl\nauf mehrere Zeilen zu verteilen):\n\n```shell\n    java -jar -Dlogback.configurationFile=logback-tests.xml test-client.jar ^\n        --tests 4 ^\n        --name1 \"displayName1\" ^\n        --player1 \"./player1.jar\" ^\n        --name2 \"displayName2\" ^\n        --player2 \"./player2.jar\" ^\n        --start-server ^\n        --port 13051\n```\nDer TestClient kann sich auch mit einem bereits laufenden Server\nverbinden, bei Angabe des Arguments `--start-server` startet er jedoch\neinfach selbst einen. Wichtig ist, dass nicht versucht wird, zwei Server\nauf dem selben Port zu starten.\n\n#### Argumente des TestClients\n\n| Attribut       | Standardwert (Typ)                               | Beschreibung                                                                                                                     |\n| -------------- | ------------------------------------------------ | -------------------------------------------------------------------------------------------------------------------------------- |\n| `--tests`        | 100 (`int`)                                        | Anzahl der Tests, die gespielt werden sollen                                                                                     |\n| `--player1`      | \"./defaultplayer.jar\" (Dateipfad)                | Erster :t[Computerspieler]{#player}                                                                                                           |\n| `--player2`      | \"./defaultplayer.jar\" (Dateipfad)                | Zweiter :t[Computerspieler]{#player}                                                                                                          |\n| `--name1`        | \"player1\" (`String`)                               | Name des ersten Spielers                                                                                                         |\n| `--name2`        | \"player2\" (`String`)                               | Name des zweiten Spielers                                                                                                        |\n| `--no-timeout`   | false (`bool`)                                     | Deaktiviere ausscheiden durch Timeouts. Kann durch `--no-timeout1` bzw. `--no-timeout2` für beide Spieler unabhängig gesetzt werden. |\n| `--start-server` | false (`bool`)                                     | Starte einen Server auf dem angegebenen Port vor dem Starten der Clients.                                                        |\n| `--server`       | 'server.jar aus dem Classpath' (Dateipfad)       | Gib einen bestimmten server an, der für die tests gestartet werden soll.                                                         |\n| `--port`         | 13051 (`int`)                                      | Der Port, auf dem der Server läuft.                                                                                              |\n| `--host`         | localhost (IP)                                   | Die Adresse, auf dem der Server läuft.                                                                                           |\n| `--loglevel`     | INFO - ensprechend der logback-tests.xml (Level) | Setzt das Loglevel, um ausführliche oder besonders kompakte Ausgaben zu erhalten.                                                |\n\nBoolesche Parameter werden als true gewertet, sobald sie angegeben\nwerden. Ein Wert hinter dem Parameter hat keine Wirkung.\n\nBei Argumenten, die nicht angegeben wurden, werden die Standardwerte aus\nder Tabelle verwendet. Die Ausgabe der Daten erfolgt nach jedem Spiel\nanhand von gerundeten Werten. Der TestClient beendet sich selbst,\nnachdem alle Spiele gespielt wurden.\n\nDie Ergebnisse der Spiele werden für den jeweiligen Spielernamen vom\nServer zusammengezählt, auch über mehrere Starts des TestClients. Die\nErgebnisse werden erst zurückgesetzt, wenn der Server neu gestartet\nwird. Achte also nach einer Veränderung der Spieler darauf, den Server\nneu zu starten oder andere Spielernamen zu verwenden.\n\nDieses Verhalten wird wahrscheinlich bald verändert, \nwobei dann jeder TestClient unabhängig vom Server die Punkte zählt.\n","data":{"name":"Spielleiter","index":2},"references":[{"folder":"book","path":{"directory":"","absolute":"/home/runner/work/docs/docs/hyperbook/.hyperbook/book/glossar.md","relative":"glossar.md","href":"/glossar"},"extension":".md","name":"glossar","root":"/home/runner/work/docs/docs/hyperbook/.hyperbook","markdown":{"content":"\n## Spielinfrastruktur\n\n:t[Computerspieler]{#player}\n\n:t[Spielleiter]{#server}\n\n:t[Wettkampfsystem]{#contest}\n","data":{"name":"Technische Grundlagen","index":2}}},{"folder":"book","path":{"directory":"entwicklung","absolute":"/home/runner/work/docs/docs/hyperbook/.hyperbook/book/entwicklung/einrichtung-der-entwicklungsumgebung.md","relative":"entwicklung/einrichtung-der-entwicklungsumgebung.md","href":"/entwicklung/einrichtung-der-entwicklungsumgebung"},"extension":".md","name":"einrichtung-der-entwicklungsumgebung","root":"/home/runner/work/docs/docs/hyperbook/.hyperbook","markdown":{"content":"\n# Einrichtung der (Java-)Entwicklungsumgebung\n\nDie Aufgabe einer Entwicklungsumgebung (IDE) ist es, den Programmierer\nbei seiner Arbeit zu unterstützen. Dazu bietet sie neben dem Editor auch\nviele Tools, die das Entwickeln eigener Programme stark erleichtern.\nZwei große Vertreter an Entwicklungsumgebungen sind Eclipse und\nIntelliJ.\n\n**Hinweis:** Bevor man sich um die Einrichtung der Entwicklungsumgebung\nkümmert, muss unbedingt [Java installiert](installation-von-java) sein.\n\n## Spielervorlage beschaffen\n\nDie Spielervorlage ist schon ein fertiger Computerspieler. Den Quellcode kann man verwenden, \num seinen eigenen Spieler zu programmieren. \nDie Spielervorlage bekommt man im \n[Downloadbereich der Software-Challenge](https://software-challenge.de/dokumentation-und-material).\nMan braucht die Version\n*als Quellcode*.\n\n## Einrichtung von Eclipse\n\n#### Windows\n\nAm einfachsten ist die Installation von Eclipse unter Windows mittels des Eclipse Installer. \nDies ist auf der [Eclipse-Website](https://www.eclipse.org/downloads/packages/installer) gut erklärt.\n\n#### Debian\nUnter Debian basierenden Distributionen ist die Installation sehr einfach mit `snap`.\n```shell\n$ sudo snap install eclipse --classic\n```\n\n#### Arch\nMit einer Arch-Distribution lässt sich Eclipse ebenso einfach mit `snap` installieren. Allerdings ist oftmals `snap` noch nicht installiert.\n```shell\n$ sudo pacman -S snapd\n$ sudo systemctl enable --now snapd.socket\n$ sudo ln -s /var/lib/snapd/snap /snap\n$ sudo snap install eclipse --classic\n```\n\n### Spielervorlage in Eclipse einbinden\n\n![Spielervorlage in Eclipse importieren](/images/eclipse_import_project.jpg)\n\n1.  Im Menü auf \"File\" → \"Import…\" gehen\n\n2.  Im Dialogfenster unter \"General\" \"Projects from Folder or Archive\"\n    wählen, dann auf den \"Next\" Button klicken\n\n3.  Oben rechts auf \"Archive…\" klicken und die heruntergeladene\n    ZIP-Datei mit der Spielervorlage auswählen. Dann auf \"Finish\" klicken.\n\nNun muss noch das SDK und Spiel-Plugin eingebunden werden, damit\nFunktionen wie Autovervollständigung und Anzeige der Dokumentation\nrichtig arbeiten:\n\n1.  Im Package Explorer einen Rechtsklick auf den Eintrag sdk.jar unter\n    \"Referenced Libraries\" machen und Properties wählen\n\n2.  Links \"Java Source Attachment\" auswählen\n\n3.  Rechts \"Workspace location\" aktivieren und den Pfad zu\n    \"sdk-sources.jar\" (im Ordner \"lib\" des Spielervorlagequellcode\n    Paketes) einstellen\n\n4.  Den Dialog mit \"Apply and Close\" schließen\n\n5.  Im Package Explorer einen Rechtsklick auf den Eintrag für das\n    Spiel-Plugin unter \"Referenced Libraries\" machen (Spielname und\n    Jahreszahl, also z.B. \"piranhas\\_2019.jar\") und Properties wählen\n\n6.  Links \"Java Source Attachment\" auswählen\n\n7.  Rechts \"Workspace location\" aktivieren und den Pfad zur Source-Jar\n    (im Ordner \"lib\" des Spielervorlagen-Quellcode-Pakets) einstellen\n    (heißt genau wie das Spiel-Plugin, mit einem \"sources\" angehängt,\n    also z.B. \"piranhas\\_2019-sources.jar\")\n\n8.  Den Dialog mit \"Apply and Close\" schließen\n\n### Spielervorlage aus Eclipse starten\n\nDie Spielervorlage kann man starten, indem man im Project-Explorer einen\nRechtsklick auf die Datei `Starter.java` macht und dann \"Run As\" → \"Java\nApplication\" auswählt.\n\n:::alert{info}\nDamit die Spielervorlage erfolgreich startet, muss der\n:t[Spielleiter]{#server} laufen und auf eine Verbindung warten.\n:::\n\n## Weiterführende Links\n\n-   [Homepage der Eclipse-IDE](http://www.eclipse.org)\n","data":{"name":"Einrichtung der Entwicklungsumgebung","index":6}}},{"folder":"book","path":{"directory":"spiele/blokus/spielregeln","absolute":"/home/runner/work/docs/docs/hyperbook/.hyperbook/book/spiele/blokus/spielregeln/content.md","relative":"spiele/blokus/spielregeln/content.md","href":"/spiele/blokus/spielregeln/content"},"extension":".md","name":"content","root":"/home/runner/work/docs/docs/hyperbook/.hyperbook","markdown":{"content":"# Spielmaterial\n\nJeder Spieler verfügt über zwei Sätze von 21 Spielsteinen (Polyominos),\ndie sich aus kleinen Quadraten zusammensetzen. Der eine Spieler hat\nblaue und rote Steine, der andere gelbe und grüne. Dabei kommt jede\nForm, die aus 1–5 Quadraten besteht, in jeder Farbe genau einmal vor:\nalso 1 Monomino, 1 Domino, 2 Triominos, 5 Tetrominos und 12 Pentominos.\n\n![Anleitung Steinuebersicht](Anleitung_Steinuebersicht.png)\n\nDas Brett besteht aus 20 × 20 quadratischen Feldern, welche dieselbe\nGröße wie die Quadrate der Spielsteine haben.\n\nDie Koordinaten der Felder des Bretts beginnen in der linken oberen Ecke\nbei x=0, y=0 und folgen den Regeln des kartesischen Koordinatensystems,\nwobei die positive x-Achse nach rechts und die positive y-Achse nach\nunten verläuft.\n\n![anleitung beispielfeld](anleitung_beispielfeld.png)\n\n# Spielablauf\n\nDie Spielsteine werden abwechselnd gelegt, wobei in den Ecken begonnen\nwird. Die Reihenfolge ist: Blau – Gelb – Rot – Grün. Der erste Stein des\nzweiten Spielers darf auch diagonal gegenüber dem ersten Stein des\nersten Spielers gelegt werden.\n\nFür den ersten Stein jeder Farbe gelten besondere Regeln: Er muss so\ngesetzt werden, dass ein Eckfeld des Spielbretts (also (0,0), (19,0),\n(0,19) oder (19,19)) besetzt wird. Die Form des ersten Steins wird vom\nServer vorgegeben. Sie wird zufällig aus allen verfügbaren Formen\nausgewählt, die aus 5 Quadraten bestehen. In einem Spiel ist die Form\ndes ersten Steins für alle Farben gleich.\n\nFür die Platzierung aller weiteren Steine gilt: Zwei Steine derselben\nFarbe dürfen sich nur an den Ecken berühren. Wird ein neuer Stein\ngelegt, muss dieser mindestens einen Stein derselben Farbe an mindestens\neiner Ecke berühren. Dabei ist es egal, wie Steine anderer Farben\nberührt werden, solange diese nicht überdeckt werden.\n\nBeispielbilder mit gültigen und ungültigen Berührungen\n\n![anleitung beruehrungen](anleitung_beruehrungen.png)\n\nDie Steine dürfen umgedreht werden (die Oberseite nach unten) und sind\nfrei rotierbar (in 90° Schritten). Die Steine müssen vollständig auf dem\nFeld liegen und dürfen sich nicht mit anderen Steinen überlappen.\nGelegte Steine dürfen nicht mehr bewegt werden.\n\nZiel ist es, möglichst viele Felder auf dem Brett mit den eigenen Farben\nzu belegen.\n\nEs wird so lange gezogen, bis keine Steine mehr gesetzt werden können.\nWenn Steine einer Farbe nicht mehr gelegt werden können, wird diese\nFarbe im weiteren Verlauf des Spiels übersprungen (die gelegten Steine\nzählen aber mit in die Wertung). Kann kein Stein irgendeiner Farbe mehr\ngelegt werden, endet das Spiel.\n\nDer :t[Computerspieler]{#player} hat für das Legen eines Spielsteines zwei Sekunden\nZeit.\n\nDer :t[Spielleiter]{#server} ruft den :t[Computerspieler]{#player} nur dann zu einem Zug einer\nFarbe auf, wenn es auch noch mindestens einen möglichen Zug gibt. Der\n:t[Computerspieler]{#player} hat dann jedoch auch die Möglichkeit, mit einem\n\"Passen\"-Zug zu antworten. Dadurch wird die aktuelle Farbe in der\naktuellen Runde ausgelassen. \"Passen\" ist erst nach dem ersten Zug\nerlaubt.\n\nEine Runde besteht aus vier Zügen. Pro Zug kann eine Farbe einen Stein\nsetzen oder passen. Auch wenn eine Farbe übersprungen wird, zählt dies\nhierbei als Zug. Das Spiel endet, sobald alle Steine einer Farbe auf das\nSpielfeld gelegt wurden, spätestens aber nach 25 Runden. In jedem Fall\nwird die aktuelle Runde noch zu Ende gespielt.\n\n# Wertung\n\nJeder gelegte Stein zählt so viele Punkte, wie er Quadrate hat (ein\ngelegtes Pentomino zählt z.B. fünf Punkte). Wurden alle Steine einer\nFarbe gelegt, gibt es 15 zusätzliche Punkte. Wurden alle Steine einer\nFarbe gelegt und war zusätzlich der letzte gelegte Stein der Monomino,\ngibt es nochmal fünf zusätzliche Punkte (insgesamt also 20). Die Punkte\nder jeweiligen zwei Farben, die ein Spieler kontrolliert, werden\nzusammengezählt und sind die Gesamtpunkte des Spielers. Der Spieler mit\nden meisten Punkten gewinnt das Spiel.\n\nIn der Meisterschaftsphase ist die durchschnittliche Punktzahl\nnachrangiges Kriterium. D.h. haben zwei Teams gleich viele Siege,\nbekommt das Team mit der höheren durchschnittlichen Punktzahl den\nbesseren Tabellenplatz.\n","data":{}}},{"folder":"book","path":{"directory":"spiele/blokus/spielregeln","absolute":"/home/runner/work/docs/docs/hyperbook/.hyperbook/book/spiele/blokus/spielregeln/regeln.md","relative":"spiele/blokus/spielregeln/regeln.md","href":"/spiele/blokus/spielregeln/regeln"},"extension":".md","name":"regeln","root":"/home/runner/work/docs/docs/hyperbook/.hyperbook","markdown":{"content":"[PDF-Version dieses Dokumentes](regeln.pdf)\n\nWir freuen uns über sämtliche Verbesserungsvorschläge.  \nDie Dokumentation kann [direkt auf\nGitHub](https://github.com/software-challenge/docs) editiert werden,\neinzige Voraussetzung ist eine kostenlose Registrierung bei GitHub. Ist\nman angemeldet, kann man ein Dokument auswählen (ein guter Startpunkt\nist die Datei\n[index.md](https://github.com/software-challenge/docs/blob/main/index.md)\nwelche Verweise auf alle Sektionen der Dokumentation enthält) und dann\nauf den Stift oben rechts klicken. Damit wird von GitHub automatisch ein\nFork und ein Pull Request erstellt.  \nAlternativ auch gern eine E-Mail an <info@software-challenge.de> oder\neine Nachricht im [Discord](https://discord.gg/jhyF7EU).\n\n# Spielmaterial\n\nJeder Spieler verfügt über zwei Sätze von 21 Spielsteinen (Polyominos),\ndie sich aus kleinen Quadraten zusammensetzen. Der eine Spieler hat\nblaue und rote Steine, der andere gelbe und grüne. Dabei kommt jede\nForm, die aus 1–5 Quadraten besteht, in jeder Farbe genau einmal vor:\nalso 1 Monomino, 1 Domino, 2 Triominos, 5 Tetrominos und 12 Pentominos.\n\n![Anleitung Steinuebersicht](./images/Anleitung_Steinuebersicht.png)\n\nDas Brett besteht aus 20 × 20 quadratischen Feldern, welche dieselbe\nGröße wie die Quadrate der Spielsteine haben.\n\nDie Koordinaten der Felder des Bretts beginnen in der linken oberen Ecke\nbei x=0, y=0 und folgen den Regeln des kartesischen Koordinatensystems,\nwobei die positive x-Achse nach rechts und die positive y-Achse nach\nunten verläuft.\n\n![anleitung beispielfeld](./images/anleitung_beispielfeld.png)\n\n# Spielablauf\n\nDie Spielsteine werden abwechselnd gelegt, wobei in den Ecken begonnen\nwird. Die Reihenfolge ist: Blau – Gelb – Rot – Grün. Der erste Stein des\nzweiten Spielers darf auch diagonal gegenüber dem ersten Stein des\nersten Spielers gelegt werden.\n\nFür den ersten Stein jeder Farbe gelten besondere Regeln: Er muss so\ngesetzt werden, dass ein Eckfeld des Spielbretts (also (0,0), (19,0),\n(0,19) oder (19,19)) besetzt wird. Die Form des ersten Steins wird vom\nServer vorgegeben. Sie wird zufällig aus allen verfügbaren Formen\nausgewählt, die aus 5 Quadraten bestehen. In einem Spiel ist die Form\ndes ersten Steins für alle Farben gleich.\n\nFür die Platzierung aller weiteren Steine gilt: Zwei Steine derselben\nFarbe dürfen sich nur an den Ecken berühren. Wird ein neuer Stein\ngelegt, muss dieser mindestens einen Stein derselben Farbe an mindestens\neiner Ecke berühren. Dabei ist es egal, wie Steine anderer Farben\nberührt werden, solange diese nicht überdeckt werden.\n\nBeispielbilder mit gültigen und ungültigen Berührungen\n\n![anleitung beruehrungen](./images/anleitung_beruehrungen.png)\n\nDie Steine dürfen umgedreht werden (die Oberseite nach unten) und sind\nfrei rotierbar (in 90° Schritten). Die Steine müssen vollständig auf dem\nFeld liegen und dürfen sich nicht mit anderen Steinen überlappen.\nGelegte Steine dürfen nicht mehr bewegt werden.\n\nZiel ist es, möglichst viele Felder auf dem Brett mit den eigenen Farben\nzu belegen.\n\nEs wird so lange gezogen, bis keine Steine mehr gesetzt werden können.\nWenn Steine einer Farbe nicht mehr gelegt werden können, wird diese\nFarbe im weiteren Verlauf des Spiels übersprungen (die gelegten Steine\nzählen aber mit in die Wertung). Kann kein Stein irgendeiner Farbe mehr\ngelegt werden, endet das Spiel.\n\nDer :t[Computerspieler]{#player} hat für das Legen eines Spielsteines zwei Sekunden\nZeit.\n\nDer :t[Spielleiter]{#server} ruft den :t[Computerspieler]{#player} nur dann zu einem Zug einer\nFarbe auf, wenn es auch noch mindestens einen möglichen Zug gibt. Der\n:t[Computerspieler]{#player} hat dann jedoch auch die Möglichkeit, mit einem\n\"Passen\"-Zug zu antworten. Dadurch wird die aktuelle Farbe in der\naktuellen Runde ausgelassen. \"Passen\" ist erst nach dem ersten Zug\nerlaubt.\n\nEine Runde besteht aus vier Zügen. Pro Zug kann eine Farbe einen Stein\nsetzen oder passen. Auch wenn eine Farbe übersprungen wird, zählt dies\nhierbei als Zug. Das Spiel endet, sobald alle Steine einer Farbe auf das\nSpielfeld gelegt wurden, spätestens aber nach 25 Runden. In jedem Fall\nwird die aktuelle Runde noch zu Ende gespielt.\n\n# Wertung\n\nJeder gelegte Stein zählt so viele Punkte, wie er Quadrate hat (ein\ngelegtes Pentomino zählt z.B. fünf Punkte). Wurden alle Steine einer\nFarbe gelegt, gibt es 15 zusätzliche Punkte. Wurden alle Steine einer\nFarbe gelegt und war zusätzlich der letzte gelegte Stein der Monomino,\ngibt es nochmal fünf zusätzliche Punkte (insgesamt also 20). Die Punkte\nder jeweiligen zwei Farben, die ein Spieler kontrolliert, werden\nzusammengezählt und sind die Gesamtpunkte des Spielers. Der Spieler mit\nden meisten Punkten gewinnt das Spiel.\n\nIn der Meisterschaftsphase ist die durchschnittliche Punktzahl\nnachrangiges Kriterium. D.h. haben zwei Teams gleich viele Siege,\nbekommt das Team mit der höheren durchschnittlichen Punktzahl den\nbesseren Tabellenplatz.\n","data":{}}},{"folder":"book","path":{"directory":"spiele/penguins","absolute":"/home/runner/work/docs/docs/hyperbook/.hyperbook/book/spiele/penguins/xml.md","relative":"spiele/penguins/xml.md","href":"/spiele/penguins/xml"},"extension":".md","name":"xml","root":"/home/runner/work/docs/docs/hyperbook/.hyperbook","markdown":{"content":"\n# Die Schnittstelle zum Server (XML)\n\nDer :t[Spielleiter]{#server} kommuniziert mit den Computerspielern über eine Netzwerkverbindung. Dadurch ist man aus technischer Sicht komplett flexibel, was die Wahl der Programmiersprache angeht. Die :t[Computerspieler]{#player} müssen lediglich das Kommunikationsprotokoll erfüllen.\n\nAnfängern wird allerdings davon abgeraten, einen komplett eigenen :t[Computerspieler]{#player} zu schreiben. Es ist deutlich einfacher, auf einem bereitgestellten Zufallsspieler aufzubauen, da man sich dabei nur um die Strategie und nicht um die Kommunikation kümmern muss. Außerdem wird vom Institut für Informatik die beste Unterstützung für Java/Kotlin geboten.\n\n## Hinweise\n\nIm Verlauf des Wettbewerbes können Elemente zur Kommunikationsschnittstelle hinzugefügt werden, die in dieser Dokumentation nicht aufgeführt sind. Um auch bei solchen Änderungen sicher zu sein, dass ein :t[Computerspieler]{#player} fehlerfrei mit dem Server kommunizieren kann, sollten beim Auslesen des :t[XML]{#xml} jegliche Daten verworfen werden, die hier nicht weiter definiert sind.\n\nDie bereitgestellten Programme \n(:t[Server]{#server}, :t[Java-Spieler]{#player}) nutzen eine Bibliothek,\num Java-Objekte direkt in :t[XML]{#xml} zu konvertieren und umgekehrt.\nDabei werden XML-Nachrichten nicht unbedingt mit einem Zeilenumbruch abgeschlossen.\n\n## Das Spielprotokoll\n\nIn diesem Abschnitt wird die spielunabhängige Kommunikationsschnittstelle für Spieler festgehalten, um das Schreiben eines komplett eigenen Clients zu ermöglichen.\n\n### Spiel betreten\n\n```xml\n<protocol>\n```\n\nDieses Tag eröffnet die Kommunikation mit dem Server. Dann gibt es drei Möglichkeiten, einer Spielpartie beizutreten.\n\n#### Beliebige Partie\n\nBetritt eine beliebige offene Spielpartie:\n\n```xml\n<join />\n```\n\nSollte kein Spiel offen sein, wird automatisch ein neues erstellt. Abhängig von der Einstellung `paused` in `server.properties` wird das Spiel pausiert gestartet oder nicht.\n\n#### Bestimmte Partie\n\nEiner bestimmten, bereits offenen, aber noch nicht gestarteten Partie kann durch Angabe der `ROOM_ID` beigetreten werden:\n\n```xml\n<joinRoom roomId=\"ROOM_ID\" />\n```\n\n#### Mit Reservierung\n\nUnter Angabe eines Reservierungscodes kann man einen reservierten Platz in einer geplanten Partie einnehmen:\n\n```xml\n<joinPrepared reservationCode=\"RESERVATION\" />\n```\n\n#### Antwort nach der Verbindung\n\nDer Server antwortet auf einen erfolgreichen Spielbeitritt mit:\n\n```xml\n<joined roomId=\"ROOM_ID\" />\n```\n\n- **ROOM_ID**\n  - Identifikationscode der Spielpartie\n\n### Spielverlauf\n\n#### Start\n\nDer Server eröffnet das Spiel mit einer Begrüßung und dem initialen Spielstatus, sobald beide Spieler verbunden sind.\n\n- **ROOM_ID**\n  - Identifikationscode der Spielpartie\n\n- **TEAMNUMBER**\n  - Spielernummer, eg. `ONE`, `TWO`\n\n#### Syntax der Willkommensnachricht\n\n\n```xml\n<room roomId=\"ROOM_ID\">\n  <data class=\"welcomeMessage\" color=\"TEAMNUMBER\"></data>\n</room>\n<room roomId=\"ROOM_ID\">\n  <data class=\"memento\">\n    STATUS\n  </data>\n</room>\n```\n\n#### Status nach der Willkommensnachricht\n\nDer Status der oben in dem data memento Objekt enthalten ist, ist beispielsweise der folgenden Form:\n```xml\n<state turn=\"0\">\n  <startTeam>ONE</startTeam>\n  <board>\n\t<list>\n\t  <field>1</field>\n\t  <field>2</field>\n\t  <field>2</field>\n\t</list>\n\t<list>\n\t  <field>2</field>\n\t  <field>ONE</field>\n\t  <field>2</field>\n\t</list>\n\t<list>\n\t  <field>TWO</field>\n\t  <field>4</field>\n\t  <field>1</field>\n\t</list>\n  </board>\n  <fishes>\n\t<int>0</int>\n\t<int>0</int>\n  </fishes>\n</state>\n```\n\nEs enthält die Zugnummer in ``turn``, das anfangende Team in ``startTeam``, eine Liste an Feldern in ``board`` und die Anzahl Fische beider Spielers in ``fishes``, zuerst die von ONE und danach die von TWO.\n\nIn `board` entsprechen die Positionen der Felder auf dem Spielfeld in [odd-r Koordinaten](https://www.redblobgames.com/grids/hexagons/#neighbors-offset) ihrer Positionen in der XML Struktur. Von oben bei null anfangend werden die `<list>` Objekte in `<board>` durchgezählt. Die Nummer der List in dem das Field Objekt ist, ist seine `y` Koordinate.  Auf die gleiche Weise entspricht die `x` Koordinate eines Felds seiner Nummer innerhalb des `<list>` Objekts.  \nDer Inhalt der `field` Objekte steht für die Anzahl Fische auf dem Feld, oder für einen Pinguin eines Spielers. In ersterem Fall steht eine Zahl in dem XML-Objekt und in letzterem Fall der Name des Spielers der den Pinguin gehört. Auf einem Feld können 0 bis 4 Fische sein.\n\n`x`: `<field>` index in `<list>`\n\n`y`: `<list>` index in `<board>`\n\n##### Koordinatensysteme\n\nBeachtet, dass der XML-Status [odd-r Koordinaten](https://www.redblobgames.com/grids/hexagons/#neighbors-offset) nutzt, und dass die Koordinaten in Zügen als [doubled Koordinaten](https://www.redblobgames.com/grids/hexagons/#neighbors-doubled) interpretiert werden.\n\nDie Formeln für die Transformation von dem einen System in das andere sind folgendermaßen:\n\nodd-r zu doubled: ``(x, y) => (x * 2 + y % 2, y)``\n\ndoubled zu odd-r: ``(x, y) => (Ceiling(x / 2.0) - y % 2, y)``\n\nBeachtet, dass `x / 2` hier durch `Ceiling(x / 2.0)` aufgerundet wird.\n\n:::alert{warn}\nBeachtet weiter, dass im doubled Koordinatensystem unabhängig der Größe (0, 1), (0, 3), (0, 5), etc. immer out of bounds sind, da sie in odd-r zu (-1, y) übersetzt werden.\n:::\n\n#### Spielablauf\n\nDer erste Spieler erhält dann eine Zugaufforderung:\n\n```xml\n<room roomId=\"ROOM_ID\">\n  <data class=\"moveRequest\" />\n</room>\n```\n\nWorauf dieser innerhalb der gesetzten Zeitbeschränkung mit einem der folgenden Zug-Typen antwortet:\n\n##### Normaler Zug\n\n```xml\n<room roomId=\"ROOM_ID\">\n  <data class=\"move\">\n    <from x=\"0\" y=\"7\"/>\n    <to x=\"4\" y=\"5\"/>\n  </data>\n</room>\n```\n\nEin normaler Zug besteht aus einem ``from`` und einem ``to`` Vektor, welche beide `x` und `y` Werte in [doubled Koordinaten](https://www.redblobgames.com/grids/hexagons/#neighbors-doubled) enthalten.\n\n##### Lege Zug\n\n```xml\n<room roomId=\"ROOM_ID\">\n  <data class=\"move\">\n    <to x=\"1\" y=\"2\"/>\n  </data>\n</room>\n```\n\nEin Lege-Zug besteht aus einem ``to`` Vektor, welcher `x` und `y` Werte in [doubled Koordinaten](https://www.redblobgames.com/grids/hexagons/#neighbors-doubled) enthält.\n\n##### Weiteres\n\nNach Erhalt des Zuges sendet der Server den neuen Spielstatus an alle Spieler \nund dem nächsten Spieler eine Zugaufforderung.\nSo geht es hin und her bis zum [Spielergebnis](#spielergebnis).\n\n#### Ende der Kommunikation\n\nDie letzte Nachricht des Servers endet mit:\n\n```xml\n</protocol>\n```\n\nDanach wird die Verbindung geschlossen.\n\n### Spielergebnis\n\nZum Spielende erhält jeder Spieler das Ergebnis. Es beginnt mit einer `definition`, die die Interpretation der Ergebnisse erklärt. Für jeden Spieler gibt es einen Eintrag in `scores`. Der darin enthaltene `score` schlüsselt sich auf in:\n\n- **cause**\n  - Beitrag des Spielers zum Spielende (`REGULAR`, `LEFT`, `RULE_VIOLATION`, `SOFT_TIMEOUT`, `HARD_TIMEOUT`).\n- **reason**\n  - Erklärung zu `cause`.\n- **part**\n  - Siegpunkte des Spielers (0 verloren, 1 unentschieden, 2 gewonnen) und weitere Punkteinträge entsprechend `definition`.\n- **winner**\n  - Gibt das Gewinner-Team an, wenn es eines gibt.\n\nHier ein Beispiel:\n\n```xml\n<room roomId=\"ROOM_ID\">\n  <data class=\"result\">\n    <definition>\n      <fragment name=\"Siegpunkte\">\n        <aggregation>SUM</aggregation>\n        <relevantForRanking>true</relevantForRanking>\n      </fragment>\n      <fragment name=\"∅ Punkte\">\n        <aggregation>AVERAGE</aggregation>\n        <relevantForRanking>true</relevantForRanking>\n      </fragment>\n    </definition>\n    <scores>\n      <entry>\n        <player name=\"rad\" team=\"ONE\"/>\n        <score cause=\"REGULAR\" reason=\"\">\n          <part>2</part>\n          <part>27</part>\n        </score>\n      </entry>\n      <entry>\n        <player name=\"blues\" team=\"TWO\"/>\n        <score cause=\"LEFT\" reason=\"Player left\">\n          <part>0</part>\n          <part>15</part>\n        </score>\n      </entry>\n    </scores>\n    <winner team=\"ONE\"/>\n  </data>\n</room>\n```\n\n### Weiterführende Informationen\n\n:t[Einführung in XML]{#xml}\n\n:t[Administration der Spiele mit XML]{#xml-administration.md}","data":{"name":"XML-Schnittstelle"}}},{"folder":"book","path":{"directory":"xml","absolute":"/home/runner/work/docs/docs/hyperbook/.hyperbook/book/xml/protokoll.md","relative":"xml/protokoll.md","href":"/xml/protokoll"},"extension":".md","name":"protokoll","root":"/home/runner/work/docs/docs/hyperbook/.hyperbook","markdown":{"content":"\n# Die XML-Schnittstelle zum Server\n\nDer :t[Spielleiter]{#server} kommuniziert mit den Computerspielern über eine Netzwerkverbindung.\nDadurch ist man aus technischer Sicht komplett flexibel, was die Wahl der Programmiersprache angeht.\nDie :t[Computerspieler]{#player} müssen lediglich das Kommunikationsprotokoll erfüllen.\n\nAnfängern wird allerdings davon abgeraten, einen komplett eigenen Computerspieler zu schreiben.\nEs ist deutlich einfacher, auf einer bereitgestellten Spielervorlage aufzubauen,\nda man sich dabei nur um die Strategie und nicht um die Kommunikation kümmern muss.\nAußerdem wird vom Institut für Informatik die beste Unterstützung für Java/Kotlin geboten.\n\n:::alert{warn}\nIm Verlauf des Wettbewerbes können Elemente zur Kommunikationsschnittstelle hinzugefügt werden,\ndie in dieser Dokumentation nicht aufgeführt sind.\nDamit ein Computerspieler auch bei solchen Änderungen fehlerfrei mit dem Server kommunizieren kann,\nsollten beim Auslesen des :t[XML]{#xml} jegliche Daten verworfen werden,\ndie hier nicht weiter definiert sind.\n:::\n\n:::alert{info}\nDie bereitgestellten Programme\n(Server, Java-Spieler) nutzen eine Bibliothek namens XStream,\num Java-Objekte direkt in :t[XML]{#xml} zu konvertieren und umgekehrt.\nDabei werden XML-Nachrichten nicht unbedingt mit einem Zeilenumbruch abgeschlossen.\n:::\n\nSpielspezifische Elemente werden in der Dokumentation des jeweiligen Spiels dokumentiert.\n\n## Der Aufbau\n\n:::plantuml\n@startuml\nnode \"Server\" as server {\n    artifact \"Spielleiter\" as serverApp\n}\nnode \"Spieler 1\" as client1 {\n    artifact \"Spielervorlage\" as client1App\n}\nnode \"Spieler 2\" as client2 {\n    artifact \"Spielervorlage\" as client2App\n}\nserverApp --> client1App : Sendet Status und Anfragen in XML\nserverApp --> client2App : Sendet Status und Anfragen in XML\nclient1App --> serverApp : Sendet Zug in XML\nclient2App --> serverApp : Sendet Zug in XML\n@enduml\n:::\n\nDie Darstellung skizziert die Architektur unseres Spielsystems,\nbestehend aus dem Server als :t[Spielleiter]{#server} und zwei Spielern.\nDer Server verwaltet das Spielgeschehen\nund interagiert über das XML-Protokoll mit den beiden Spielern,\ndie jeweils auf einer Spielervorlage aufbauen.\n\n## Das Spielprotokoll\n\nIn diesem Abschnitt wird die spielunabhängige Kommunikationsschnittstelle für Spieler festgehalten,\num das Schreiben eines komplett eigenen Clients zu ermöglichen.\n\n### Spiel betreten\n\n```xml\n<protocol>\n```\n\nDieses Tag eröffnet die Kommunikation mit dem Server. Dann gibt es drei Möglichkeiten, einer Spielpartie beizutreten.\n\n#### Beliebige Partie\n\nBetritt eine beliebige offene Spielpartie:\n\n```xml\n<join />\n```\n\nSollte kein Spiel offen sein, wird automatisch ein neues erstellt. Abhängig von der Einstellung `paused` in `server.properties` wird das Spiel pausiert, gestartet oder nicht.\n\n#### Bestimmte Partie\n\nEiner bestimmten, bereits offenen, aber noch nicht gestarteten Partie kann durch Angabe der `ROOM_ID` beigetreten werden:\n\n```xml\n<joinRoom roomId=\"ROOM_ID\" />\n```\n\n#### Mit Reservierung\n\nUnter Angabe eines Reservierungscodes kann man einen reservierten Platz in einer geplanten Partie einnehmen:\n\n```xml\n<joinPrepared reservationCode=\"RESERVATION\" />\n```\n\n#### Antwort nach der Verbindung\n\nDer Server antwortet auf einen erfolgreichen Spielbeitritt mit:\n\n```xml\n<joined roomId=\"ROOM_ID\" />\n```\n\n- **ROOM_ID**\n  - Identifikationscode der Spielpartie\n\n### Spielverlauf\nFolgend werden die spiel spezifischen Punkte des XML-Protokolls erläutert, welche sich in jedem Jahr ändern und auch am Anfang der Saison noch Änderungen unterliegen kann.\n#### Start\n\nDer Server eröffnet das Spiel mit einer Begrüßung und dem initialen Spielstatus, sobald beide Spieler verbunden sind.\n\n- **ROOM_ID**\n  - Identifikationscode der Spielpartie\n\n- **TEAMNUMBER**\n  - Spielernummer, eg. `ONE`, `TWO`\n\n#### Syntax der Willkommensnachricht\n\n\n```xml\n<room roomId=\"ROOM_ID\">\n  <data class=\"welcomeMessage\" color=\"TEAMNUMBER\"></data>\n</room>\n<room roomId=\"ROOM_ID\">\n  <data class=\"memento\">\n    SPIELSTATUS\n  </data>\n</room>\n```\n\n#### Spielablauf\n\nDer erste Spieler erhält dann eine Zugaufforderung:\n\n```xml\n<room roomId=\"ROOM_ID\">\n  <data class=\"moveRequest\" />\n</room>\n```\n\nWorauf dieser innerhalb der erlaubten Zeitspanne mit einem spielspezifischen Zug antwortet.\n\n","data":{"name":"XML-Protokoll","index":2}}}],"navigation":{"next":{"name":"Überblick","index":1,"repo":"https://github.com/software-challenge/docs/tree/main/hyperbook/book/index.md","href":"/"},"current":null,"previous":null,"sections":[{"name":"Spiele","index":1,"virtual":true,"isEmpty":true,"pages":[],"sections":[{"name":"Blokus","hide":true,"isEmpty":false,"pages":[],"sections":[{"name":"Spielregeln","hide":true,"isEmpty":true,"pages":[{"name":"content","repo":"https://github.com/software-challenge/docs/tree/main/hyperbook/book/spiele/blokus/spielregeln/content.md","href":"/spiele/blokus/spielregeln/content"},{"name":"regeln","repo":"https://github.com/software-challenge/docs/tree/main/hyperbook/book/spiele/blokus/spielregeln/regeln.md","href":"/spiele/blokus/spielregeln/regeln"}],"sections":[],"repo":"https://github.com/software-challenge/docs/tree/main/hyperbook/book/spiele/blokus/spielregeln/index.md","href":"/spiele/blokus/spielregeln"},{"name":"XML-Dokumentation","hide":true,"isEmpty":true,"pages":[{"name":"einleitung-xml","repo":"https://github.com/software-challenge/docs/tree/main/hyperbook/book/spiele/blokus/xml-dokumentation/einleitung-xml.md","href":"/spiele/blokus/xml-dokumentation/einleitung-xml"},{"name":"spiel-betreten","repo":"https://github.com/software-challenge/docs/tree/main/hyperbook/book/spiele/blokus/xml-dokumentation/spiel-betreten.md","href":"/spiele/blokus/xml-dokumentation/spiel-betreten"},{"name":"spiel-verlassen","repo":"https://github.com/software-challenge/docs/tree/main/hyperbook/book/spiele/blokus/xml-dokumentation/spiel-verlassen.md","href":"/spiele/blokus/xml-dokumentation/spiel-verlassen"},{"name":"spielergebnis","repo":"https://github.com/software-challenge/docs/tree/main/hyperbook/book/spiele/blokus/xml-dokumentation/spielergebnis.md","href":"/spiele/blokus/xml-dokumentation/spielergebnis"},{"name":"spielstatus","repo":"https://github.com/software-challenge/docs/tree/main/hyperbook/book/spiele/blokus/xml-dokumentation/spielstatus.md","href":"/spiele/blokus/xml-dokumentation/spielstatus"},{"name":"spielsteine","repo":"https://github.com/software-challenge/docs/tree/main/hyperbook/book/spiele/blokus/xml-dokumentation/spielsteine.md","href":"/spiele/blokus/xml-dokumentation/spielsteine"},{"name":"spielverlauf","repo":"https://github.com/software-challenge/docs/tree/main/hyperbook/book/spiele/blokus/xml-dokumentation/spielverlauf.md","href":"/spiele/blokus/xml-dokumentation/spielverlauf"},{"name":"xml-dokumentation","repo":"https://github.com/software-challenge/docs/tree/main/hyperbook/book/spiele/blokus/xml-dokumentation/xml-dokumentation.md","href":"/spiele/blokus/xml-dokumentation/xml-dokumentation"},{"name":"zuege-senden","repo":"https://github.com/software-challenge/docs/tree/main/hyperbook/book/spiele/blokus/xml-dokumentation/zuege-senden.md","href":"/spiele/blokus/xml-dokumentation/zuege-senden"},{"name":"zug-anforderung","repo":"https://github.com/software-challenge/docs/tree/main/hyperbook/book/spiele/blokus/xml-dokumentation/zug-anforderung.md","href":"/spiele/blokus/xml-dokumentation/zug-anforderung"}],"sections":[],"repo":"https://github.com/software-challenge/docs/tree/main/hyperbook/book/spiele/blokus/xml-dokumentation/index.md","href":"/spiele/blokus/xml-dokumentation"}],"repo":"https://github.com/software-challenge/docs/tree/main/hyperbook/book/spiele/blokus/index.md","href":"/spiele/blokus"},{"name":"Hase und Igel","hide":true,"isEmpty":false,"pages":[],"sections":[{"name":"Spielregeln","hide":true,"isEmpty":true,"pages":[{"name":"beispiel","repo":"https://github.com/software-challenge/docs/tree/main/hyperbook/book/spiele/hase-und-igel/spielregeln/beispiel.md","href":"/spiele/hase-und-igel/spielregeln/beispiel"},{"name":"felder","repo":"https://github.com/software-challenge/docs/tree/main/hyperbook/book/spiele/hase-und-igel/spielregeln/felder.md","href":"/spiele/hase-und-igel/spielregeln/felder"},{"name":"regeln","repo":"https://github.com/software-challenge/docs/tree/main/hyperbook/book/spiele/hase-und-igel/spielregeln/regeln.md","href":"/spiele/hase-und-igel/spielregeln/regeln"},{"name":"spielbeginn","repo":"https://github.com/software-challenge/docs/tree/main/hyperbook/book/spiele/hase-und-igel/spielregeln/spielbeginn.md","href":"/spiele/hase-und-igel/spielregeln/spielbeginn"},{"name":"spielende","repo":"https://github.com/software-challenge/docs/tree/main/hyperbook/book/spiele/hase-und-igel/spielregeln/spielende.md","href":"/spiele/hase-und-igel/spielregeln/spielende"},{"name":"zuege","repo":"https://github.com/software-challenge/docs/tree/main/hyperbook/book/spiele/hase-und-igel/spielregeln/zuege.md","href":"/spiele/hase-und-igel/spielregeln/zuege"}],"sections":[],"repo":"https://github.com/software-challenge/docs/tree/main/hyperbook/book/spiele/hase-und-igel/spielregeln/index.md","href":"/spiele/hase-und-igel/spielregeln"},{"name":"Tutorial","hide":true,"isEmpty":true,"pages":[{"name":"board","repo":"https://github.com/software-challenge/docs/tree/main/hyperbook/book/spiele/hase-und-igel/tutorial/board.md","href":"/spiele/hase-und-igel/tutorial/board"},{"name":"game-rule-logic","repo":"https://github.com/software-challenge/docs/tree/main/hyperbook/book/spiele/hase-und-igel/tutorial/game-rule-logic.md","href":"/spiele/hase-und-igel/tutorial/game-rule-logic"},{"name":"player","repo":"https://github.com/software-challenge/docs/tree/main/hyperbook/book/spiele/hase-und-igel/tutorial/player.md","href":"/spiele/hase-und-igel/tutorial/player"},{"name":"start","repo":"https://github.com/software-challenge/docs/tree/main/hyperbook/book/spiele/hase-und-igel/tutorial/start.md","href":"/spiele/hase-und-igel/tutorial/start"},{"name":"tutorial","repo":"https://github.com/software-challenge/docs/tree/main/hyperbook/book/spiele/hase-und-igel/tutorial/tutorial.md","href":"/spiele/hase-und-igel/tutorial/tutorial"}],"sections":[],"repo":"https://github.com/software-challenge/docs/tree/main/hyperbook/book/spiele/hase-und-igel/tutorial/index.md","href":"/spiele/hase-und-igel/tutorial"},{"name":"XML-Dokumentation","hide":true,"isEmpty":true,"pages":[{"name":"einleitung-xml","repo":"https://github.com/software-challenge/docs/tree/main/hyperbook/book/spiele/hase-und-igel/xml-dokumentation/einleitung-xml.md","href":"/spiele/hase-und-igel/xml-dokumentation/einleitung-xml"},{"name":"fehler","repo":"https://github.com/software-challenge/docs/tree/main/hyperbook/book/spiele/hase-und-igel/xml-dokumentation/fehler.md","href":"/spiele/hase-und-igel/xml-dokumentation/fehler"},{"name":"spiel-betreten","repo":"https://github.com/software-challenge/docs/tree/main/hyperbook/book/spiele/hase-und-igel/xml-dokumentation/spiel-betreten.md","href":"/spiele/hase-und-igel/xml-dokumentation/spiel-betreten"},{"name":"spiel-verlassen","repo":"https://github.com/software-challenge/docs/tree/main/hyperbook/book/spiele/hase-und-igel/xml-dokumentation/spiel-verlassen.md","href":"/spiele/hase-und-igel/xml-dokumentation/spiel-verlassen"},{"name":"spielergebnis","repo":"https://github.com/software-challenge/docs/tree/main/hyperbook/book/spiele/hase-und-igel/xml-dokumentation/spielergebnis.md","href":"/spiele/hase-und-igel/xml-dokumentation/spielergebnis"},{"name":"spielstatus","repo":"https://github.com/software-challenge/docs/tree/main/hyperbook/book/spiele/hase-und-igel/xml-dokumentation/spielstatus.md","href":"/spiele/hase-und-igel/xml-dokumentation/spielstatus"},{"name":"spielverlauf","repo":"https://github.com/software-challenge/docs/tree/main/hyperbook/book/spiele/hase-und-igel/xml-dokumentation/spielverlauf.md","href":"/spiele/hase-und-igel/xml-dokumentation/spielverlauf"},{"name":"xml-dokumentation","repo":"https://github.com/software-challenge/docs/tree/main/hyperbook/book/spiele/hase-und-igel/xml-dokumentation/xml-dokumentation.md","href":"/spiele/hase-und-igel/xml-dokumentation/xml-dokumentation"},{"name":"zuege-senden","repo":"https://github.com/software-challenge/docs/tree/main/hyperbook/book/spiele/hase-und-igel/xml-dokumentation/zuege-senden.md","href":"/spiele/hase-und-igel/xml-dokumentation/zuege-senden"},{"name":"zug-anforderung","repo":"https://github.com/software-challenge/docs/tree/main/hyperbook/book/spiele/hase-und-igel/xml-dokumentation/zug-anforderung.md","href":"/spiele/hase-und-igel/xml-dokumentation/zug-anforderung"}],"sections":[],"repo":"https://github.com/software-challenge/docs/tree/main/hyperbook/book/spiele/hase-und-igel/xml-dokumentation/index.md","href":"/spiele/hase-und-igel/xml-dokumentation"}],"repo":"https://github.com/software-challenge/docs/tree/main/hyperbook/book/spiele/hase-und-igel/index.md","href":"/spiele/hase-und-igel"},{"name":"Hey, Danke für den Fisch!","hide":true,"expanded":true,"isEmpty":false,"pages":[{"name":"Spielregeln","index":1,"repo":"https://github.com/software-challenge/docs/tree/main/hyperbook/book/spiele/penguins/regeln.md","href":"/spiele/penguins/regeln"},{"name":"XML-Schnittstelle","repo":"https://github.com/software-challenge/docs/tree/main/hyperbook/book/spiele/penguins/xml.md","href":"/spiele/penguins/xml"}],"sections":[],"repo":"https://github.com/software-challenge/docs/tree/main/hyperbook/book/spiele/penguins/index.md","href":"/spiele/penguins"},{"name":"Hive","hide":true,"isEmpty":false,"pages":[],"sections":[{"name":"Spielregeln","hide":true,"isEmpty":true,"pages":[{"name":"regeln","repo":"https://github.com/software-challenge/docs/tree/main/hyperbook/book/spiele/hive/spielregeln/regeln.md","href":"/spiele/hive/spielregeln/regeln"}],"sections":[],"repo":"https://github.com/software-challenge/docs/tree/main/hyperbook/book/spiele/hive/spielregeln/index.md","href":"/spiele/hive/spielregeln"},{"name":"XML-Dokumention","hide":true,"isEmpty":true,"pages":[{"name":"einleitung-xml","repo":"https://github.com/software-challenge/docs/tree/main/hyperbook/book/spiele/hive/xml-dokumentation/einleitung-xml.md","href":"/spiele/hive/xml-dokumentation/einleitung-xml"},{"name":"fehler","repo":"https://github.com/software-challenge/docs/tree/main/hyperbook/book/spiele/hive/xml-dokumentation/fehler.md","href":"/spiele/hive/xml-dokumentation/fehler"},{"name":"spiel-betreten","repo":"https://github.com/software-challenge/docs/tree/main/hyperbook/book/spiele/hive/xml-dokumentation/spiel-betreten.md","href":"/spiele/hive/xml-dokumentation/spiel-betreten"},{"name":"spiel-verlassen","repo":"https://github.com/software-challenge/docs/tree/main/hyperbook/book/spiele/hive/xml-dokumentation/spiel-verlassen.md","href":"/spiele/hive/xml-dokumentation/spiel-verlassen"},{"name":"spielergebnis","repo":"https://github.com/software-challenge/docs/tree/main/hyperbook/book/spiele/hive/xml-dokumentation/spielergebnis.md","href":"/spiele/hive/xml-dokumentation/spielergebnis"},{"name":"spielstatus","repo":"https://github.com/software-challenge/docs/tree/main/hyperbook/book/spiele/hive/xml-dokumentation/spielstatus.md","href":"/spiele/hive/xml-dokumentation/spielstatus"},{"name":"spielverlauf","repo":"https://github.com/software-challenge/docs/tree/main/hyperbook/book/spiele/hive/xml-dokumentation/spielverlauf.md","href":"/spiele/hive/xml-dokumentation/spielverlauf"},{"name":"xml-dokumentation","repo":"https://github.com/software-challenge/docs/tree/main/hyperbook/book/spiele/hive/xml-dokumentation/xml-dokumentation.md","href":"/spiele/hive/xml-dokumentation/xml-dokumentation"},{"name":"zuege-senden","repo":"https://github.com/software-challenge/docs/tree/main/hyperbook/book/spiele/hive/xml-dokumentation/zuege-senden.md","href":"/spiele/hive/xml-dokumentation/zuege-senden"},{"name":"zug-anforderung","repo":"https://github.com/software-challenge/docs/tree/main/hyperbook/book/spiele/hive/xml-dokumentation/zug-anforderung.md","href":"/spiele/hive/xml-dokumentation/zug-anforderung"}],"sections":[],"repo":"https://github.com/software-challenge/docs/tree/main/hyperbook/book/spiele/hive/xml-dokumentation/index.md","href":"/spiele/hive/xml-dokumentation"}],"repo":"https://github.com/software-challenge/docs/tree/main/hyperbook/book/spiele/hive/index.md","href":"/spiele/hive"},{"name":"Mississippi Queen","expanded":true,"isEmpty":false,"pages":[{"name":"Spielregeln","index":1,"repo":"https://github.com/software-challenge/docs/tree/main/hyperbook/book/spiele/mississippi-queen/regeln.md","href":"/spiele/mississippi-queen/regeln"},{"name":"XML-Elemente","index":2,"repo":"https://github.com/software-challenge/docs/tree/main/hyperbook/book/spiele/mississippi-queen/xml.md","href":"/spiele/mississippi-queen/xml"}],"sections":[],"repo":"https://github.com/software-challenge/docs/tree/main/hyperbook/book/spiele/mississippi-queen/index.md","href":"/spiele/mississippi-queen"},{"name":"Ostseeschach","hide":true,"isEmpty":false,"pages":[{"name":"regeln","repo":"https://github.com/software-challenge/docs/tree/main/hyperbook/book/spiele/ostseeschach/regeln.md","href":"/spiele/ostseeschach/regeln"},{"name":"xml-dokumentation","repo":"https://github.com/software-challenge/docs/tree/main/hyperbook/book/spiele/ostseeschach/xml-dokumentation.md","href":"/spiele/ostseeschach/xml-dokumentation"}],"sections":[],"repo":"https://github.com/software-challenge/docs/tree/main/hyperbook/book/spiele/ostseeschach/index.md","href":"/spiele/ostseeschach"},{"name":"Piranhas","hide":true,"isEmpty":false,"pages":[],"sections":[{"name":"Spielregeln","hide":true,"isEmpty":true,"pages":[{"name":"regeln","repo":"https://github.com/software-challenge/docs/tree/main/hyperbook/book/spiele/piranhas/spielregeln/regeln.md","href":"/spiele/piranhas/spielregeln/regeln"}],"sections":[],"repo":"https://github.com/software-challenge/docs/tree/main/hyperbook/book/spiele/piranhas/spielregeln/index.md","href":"/spiele/piranhas/spielregeln"},{"name":"XML-Dokumentation","hide":true,"isEmpty":true,"pages":[{"name":"einleitung-xml","repo":"https://github.com/software-challenge/docs/tree/main/hyperbook/book/spiele/piranhas/xml-dokumentation/einleitung-xml.md","href":"/spiele/piranhas/xml-dokumentation/einleitung-xml"},{"name":"fehler","repo":"https://github.com/software-challenge/docs/tree/main/hyperbook/book/spiele/piranhas/xml-dokumentation/fehler.md","href":"/spiele/piranhas/xml-dokumentation/fehler"},{"name":"spiel-betreten","repo":"https://github.com/software-challenge/docs/tree/main/hyperbook/book/spiele/piranhas/xml-dokumentation/spiel-betreten.md","href":"/spiele/piranhas/xml-dokumentation/spiel-betreten"},{"name":"spiel-verlassen","repo":"https://github.com/software-challenge/docs/tree/main/hyperbook/book/spiele/piranhas/xml-dokumentation/spiel-verlassen.md","href":"/spiele/piranhas/xml-dokumentation/spiel-verlassen"},{"name":"spielergebnis","repo":"https://github.com/software-challenge/docs/tree/main/hyperbook/book/spiele/piranhas/xml-dokumentation/spielergebnis.md","href":"/spiele/piranhas/xml-dokumentation/spielergebnis"},{"name":"spielstatus","repo":"https://github.com/software-challenge/docs/tree/main/hyperbook/book/spiele/piranhas/xml-dokumentation/spielstatus.md","href":"/spiele/piranhas/xml-dokumentation/spielstatus"},{"name":"spielverlauf","repo":"https://github.com/software-challenge/docs/tree/main/hyperbook/book/spiele/piranhas/xml-dokumentation/spielverlauf.md","href":"/spiele/piranhas/xml-dokumentation/spielverlauf"},{"name":"xml-dokumentation","repo":"https://github.com/software-challenge/docs/tree/main/hyperbook/book/spiele/piranhas/xml-dokumentation/xml-dokumentation.md","href":"/spiele/piranhas/xml-dokumentation/xml-dokumentation"},{"name":"zuege-senden","repo":"https://github.com/software-challenge/docs/tree/main/hyperbook/book/spiele/piranhas/xml-dokumentation/zuege-senden.md","href":"/spiele/piranhas/xml-dokumentation/zuege-senden"},{"name":"zug-anforderung","repo":"https://github.com/software-challenge/docs/tree/main/hyperbook/book/spiele/piranhas/xml-dokumentation/zug-anforderung.md","href":"/spiele/piranhas/xml-dokumentation/zug-anforderung"}],"sections":[],"repo":"https://github.com/software-challenge/docs/tree/main/hyperbook/book/spiele/piranhas/xml-dokumentation/index.md","href":"/spiele/piranhas/xml-dokumentation"}],"repo":"https://github.com/software-challenge/docs/tree/main/hyperbook/book/spiele/piranhas/index.md","href":"/spiele/piranhas"}],"repo":"https://github.com/software-challenge/docs/tree/main/hyperbook/book/spiele/index.md","href":"/spiele"},{"name":"Entwicklung eines Computerspielers","index":2,"isEmpty":false,"pages":[{"name":"Das Spiel kennenlernen","index":1,"repo":"https://github.com/software-challenge/docs/tree/main/hyperbook/book/entwicklung/kennenlernen.md","href":"/entwicklung/kennenlernen"},{"name":"Objektorientierte Programmierung","index":3,"repo":"https://github.com/software-challenge/docs/tree/main/hyperbook/book/entwicklung/einfuehrung-oop.md","href":"/entwicklung/einfuehrung-oop"},{"name":"Sauberer Programmierstil","index":4,"repo":"https://github.com/software-challenge/docs/tree/main/hyperbook/book/entwicklung/sauberer-programmierstil.md","href":"/entwicklung/sauberer-programmierstil"},{"name":"Installation von Java","index":5,"repo":"https://github.com/software-challenge/docs/tree/main/hyperbook/book/entwicklung/installation-von-java.md","href":"/entwicklung/installation-von-java"},{"name":"Einrichtung der Entwicklungsumgebung","index":6,"repo":"https://github.com/software-challenge/docs/tree/main/hyperbook/book/entwicklung/einrichtung-der-entwicklungsumgebung.md","href":"/entwicklung/einrichtung-der-entwicklungsumgebung"},{"name":"Bedienung von Eclipse","index":7,"repo":"https://github.com/software-challenge/docs/tree/main/hyperbook/book/entwicklung/bedienung-von-eclipse.md","href":"/entwicklung/bedienung-von-eclipse"},{"name":"Spielervorlage erweitern","index":7,"repo":"https://github.com/software-challenge/docs/tree/main/hyperbook/book/entwicklung/simpleclient-erweitern.md","href":"/entwicklung/simpleclient-erweitern"},{"name":"Idee implementieren","index":8,"repo":"https://github.com/software-challenge/docs/tree/main/hyperbook/book/entwicklung/eine-idee-implementieren.md","href":"/entwicklung/eine-idee-implementieren"},{"name":"Computerspieler abgabefertig machen","index":9,"repo":"https://github.com/software-challenge/docs/tree/main/hyperbook/book/entwicklung/abgabe.md","href":"/entwicklung/abgabe"}],"sections":[],"repo":"https://github.com/software-challenge/docs/tree/main/hyperbook/book/entwicklung/index.md","href":"/entwicklung"},{"name":"Allgemeine XML-Dokumentation","index":4,"isEmpty":true,"pages":[{"name":"Einführung in XML","index":1,"repo":"https://github.com/software-challenge/docs/tree/main/hyperbook/book/xml/intro.md","href":"/xml/intro"},{"name":"XML-Protokoll","index":2,"repo":"https://github.com/software-challenge/docs/tree/main/hyperbook/book/xml/protokoll.md","href":"/xml/protokoll"},{"name":"Verwaltung von Spielen mittels authentifiziertem  Client","index":3,"repo":"https://github.com/software-challenge/docs/tree/main/hyperbook/book/xml/administration.md","href":"/xml/administration"}],"sections":[],"repo":"https://github.com/software-challenge/docs/tree/main/hyperbook/book/xml/index.md","href":"/xml"}],"pages":[{"name":"Überblick","index":1,"repo":"https://github.com/software-challenge/docs/tree/main/hyperbook/book/index.md","href":"/"},{"name":"Technische Grundlagen","index":2,"repo":"https://github.com/software-challenge/docs/tree/main/hyperbook/book/glossar.md","href":"/glossar"},{"name":"Die Software-Challenge","index":3,"expanded":true,"repo":"https://github.com/software-challenge/docs/tree/main/hyperbook/book/wettbewerb.md","href":"/wettbewerb"},{"name":"Wettkampfmodalitäten","index":3,"repo":"https://github.com/software-challenge/docs/tree/main/hyperbook/book/wettkampf.md","href":"/wettkampf"},{"name":"F.A.Q.","index":4,"repo":"https://github.com/software-challenge/docs/tree/main/hyperbook/book/faq.md","href":"/faq"}]}},"__N_SSG":true}