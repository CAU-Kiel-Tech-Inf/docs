{"pageProps":{"locale":"de","markdown":"[PDF-Version dieses Dokumentes](tutorial.pdf)\n\n# Start zum Schreiben einer KI\n\nAm einfachsten ist es die KI auf Grundlage des Zufallsspielers zu\nschreiben:\n\n-   Als erstes muss der Zufallsspieler heruntergeladen werden\n    (<http://www.software-challenge.de/downloads/> bitte den\n    Zufallsspieler als „Quellcode“ downloaden)\n\n-   Dieser muss nun in Eclips eingebunden werden:\n    <https://docs.software-challenge.de/#einrichtung-von-eclipse>\n\n## Wo schreibe ich die KI?\n\nIst dies getan befindet sich im entsprechenden Projekt das Package\n„sc.player2018.logic“ mit einer Datei namens **„RandomLogic.java“**.\nDiese Datei müssen wir nun editieren.\n\nIn der Datei gibt es eine Funktion mit der Bezeichnung *public void\nonRequestAction()*. Diese ist wie Folgt aufgebaut:\n\n    public void onRequestAction(){\n      // optional: Laufzeitmessung\n      long startTime = System.nanoTime();\n\n\n      // Quellcode der KI, welche eine Zug (move) erstellt\n\n\n      long nowTime = System.nanoTime();\n\n      // sende Move. Danach gibt es kein zurück mehr:\n      sendAction(move);\n\n      // optional: LOG-Eintrag mit Zeit:\n      log.warn(\"Time needed for turn: {}\", (nowTime - startTime) / 1000000);\n    }\n\nEs ist sehr wichtig, dass alle Funktionen, welche die KI verwendet,\nihren ursprünglichen Aufruf in der Funktion onRequestAction haben.\nDadurch wird sichergestellt, dass alle Membervariablen aktuell sind.\n\n## Wichtige Membervariablen\n\nIn der Klasse befinden sich auch drei sehr wichtige Membervariablen:\n\n    private Starter client; // Intern für den Server wichtig. Bitte nicht modifizieren\n\n    private GameState gameState; // Gibt u.a Infos über mögliche Züge und das Spielbrett\n\n    private Player currentPlayer; // Infos über den aktuellen Spieler, welchen man steuert\n\nIn den Folgenden Dokumenten werden Grundlagen zum erstellen einer KI\ngezeigt. Hierbei werden wir oft die Variablen **gameState** und\n**currentPlayer** verwenden.\n\nDie **API-Dokumentation** befindet sich im Ordner „doc“ im Verzeichnis\ndes Zufallsspielers.\n\n## Aufgaben\n\n1.  Arbeite alle anderen Dokumente durch.\n\n2.  Analysiere die Herangehensweise der Zufallsspieler-KI.\n\n3.  Schreibe eine KI.\n\n# Spielbrett Informationen\n\n## Die Klasse „FieldType“\n\nBevor wir mit der Klasse Board also dem Spielbrett arbeiten können,\nmüssen wir das Enum „FieldType“ kennenlernen. Dieses Enum definiert die\neinzelnen Felder des Bretts. Es gibt:\n\n<table>\n<colgroup>\n<col style=\"width: 50%\" />\n<col style=\"width: 50%\" />\n</colgroup>\n<tbody>\n<tr class=\"odd\">\n<td style=\"text-align: left;\"><p>CARROT</p></td>\n<td style=\"text-align: left;\"><p>Karottenfeld</p></td>\n</tr>\n<tr class=\"even\">\n<td style=\"text-align: left;\"><p>GOAL</p></td>\n<td style=\"text-align: left;\"><p>Zielfeld</p></td>\n</tr>\n<tr class=\"odd\">\n<td style=\"text-align: left;\"><p>HARE</p></td>\n<td style=\"text-align: left;\"><p>Hasenfeld</p></td>\n</tr>\n<tr class=\"even\">\n<td style=\"text-align: left;\"><p>HEDGEHOG</p></td>\n<td style=\"text-align: left;\"><p>Igelfeld</p></td>\n</tr>\n<tr class=\"odd\">\n<td style=\"text-align: left;\"><p>SALAD</p></td>\n<td style=\"text-align: left;\"><p>Salatfeld</p></td>\n</tr>\n<tr class=\"even\">\n<td style=\"text-align: left;\"><p>START</p></td>\n<td style=\"text-align: left;\"><p>Start</p></td>\n</tr>\n<tr class=\"odd\">\n<td style=\"text-align: left;\"><p>POSITION_1</p></td>\n<td style=\"text-align: left;\"><p>Positionsfelder</p></td>\n</tr>\n<tr class=\"even\">\n<td style=\"text-align: left;\"><p>POSITION_2</p></td>\n<td style=\"text-align: left;\"></td>\n</tr>\n<tr class=\"odd\">\n<td style=\"text-align: left;\"><p>INVALID</p></td>\n<td style=\"text-align: left;\"><p>Ungültig</p></td>\n</tr>\n</tbody>\n</table>\n\nDie Dokumentation für FieldType ist in /doc/sc/plugin2018/FieldType.html\nzu finden.\n\n## Funktionen der Klasse „Board“\n\nDas Spielbrett kann man sich wie einer Art modifizieren „Array“ [1]\nvorstellen. Mithilfe der FieldTypes können wir die Funktionen des Boards\nverwenden. Zunächst stellt sich allerdings die Frage, wie wir überhaupt\ndas Spielbrett bekommen können. Das Spielbrett bekommen wir durch den\nGameState. Mit Hilfe der Methode *gameState.getBoard()*.\n\nUnsere Eigene Position können wir mithilfe von **currentPlayer** oder\n**gameState** herausfinden:\n\n    // Es wird immer ein Integer zwischen 0 bis 64 zurückgegeben:\n    currentPlayer.getFieldIndex();\n    // dasselbe wie oben:\n    gameState.getCurrentPlayer().getFieldIndex();\n\n    if (currentPlayer.getFieldIndex() == gameState.getCurrentPlayer().getFieldIndex()) {\n      //wird immer ausgeführt\n    }\n\n### public final int getNextFieldByType(FieldType type,int pos)\n\nDieser Funktion übergeben wir eine Position und ein FieldType. Es gibt\ndie Position des nächsten FieldType an, welches **nach** der angegeben\nPosition liegt. Hat das Feld mit der angegeben Position, den gleichen\nFieldType, so wird dennoch die Position des nächsten Felds angegeben\n(siehe zweites Beispiel). Gibt es diesen FieldType nicht mehr wird -1\nzurückgegeben.\n\n    gameState.getBoard().getNextFieldByType(FieldType.GOAL,\n                                            currentPlayer.getFieldIndex());\n\nDies würde in einem normalen Spiel immer 64 zurückgeben, außer man\nbefindet sich auf dem Ziel. Im diesem Fall wäre das Ergebnis -1.\n\n    // Damit man nicht immer gameState.getBoard() schreiben muss:\n    Board b = gameState.getBoard();\n    final int index = currentPlayer.getFieldIndex(); // Index des Spielers\n\n    if (index == b.getNextFieldByType(b.getTypeAt(index), index)) {\n      System.out.println(\"Geht nicht\");\n    }\n\nDies liegt daran, dass der verwendete Index nie der Rückgabewert von\n**getNextFieldByType** sein kann.\n\n    int next_hedgehog = b.getNextFieldByType(FieldType.HEDGEHOG,\n                                             currentPlayer.getFieldIndex());\n    int next_next_hedgehog = b.getNextFieldByType(FieldType.HEDGEHOG, next_hedgehog);\n\nDies würde die Postion des nächste und vom übernächste Igelfeld\nbestimmen. Achtung es wird hierbei nicht überprüft, ob es so ein Feld\nüberhaupt gibt. Dies kann zu Fehlern führen. Steht man z.B auf dem\nletzten Igelfeld, so hat **next\\_next\\_hedgehog** den Wert 11, anstelle\nvon -1 (Siehe Übung 2).\n\n### public final int getPreviousFieldByType(FieldType type,int pos)\n\nAnalog zu getNextFieldByType. Allerdings bezieht sich die Funktion auf\ndas vorherige Feld mit dem entsprechenden FieldType.\n\n### public final FieldType getTypeAt(int pos)\n\nMit dieser Funktionen kann man den FieldType eines bestimmten Feldes\nermitteln.\n\n    FieldType my_field = gameState.getBoard().getTypeAt(currentPlayer.getFieldIndex());\n    FieldType field_42 = gameState.getBoard().getTypeAt(42);\n\nSpeichert den aktuelle FieldType auf welchen man steht und den FieldType\ndes Feldes 42.\n\n    if (gameState.getBoard().getTypeAt(-1) == FieldType.INVALID) {\n      // Wird immer ausgeführt, da es das Feld an der Position -1 nicht gibt\n    }\n\nDieses Beispiel zeigt auf, dass es durch getTypeAt nie zu einer\nIndexOutOfBoundsException kommen kann. Es gibt nur Felder im Intervall\nvon 0 – 64. Sollte man nach einem Feld außerhalb diese Intervalls\nfragen, so wird immer INVALID zurückgegeben.\n\nDie komplette API-Dokumentation ist in /doc/sc/plugin2018/Board.html zu\nfinden.\n\n## Aufgaben\n\n1.  Gib die Entfernung des Gegners zum Startfeld aus. Verwende dabei\n    keine Variablen oder Literale. Die Ausnahme ist der Rückgabewert.\n    Dieser darf eine Literale sein (z.B. return 127;). Tipp: Suche in\n    der API von GameState nach einer Funktion, welchen den anderen\n    Spieler zurückgibt oder lese das Dokument „Hase\\_Igel\\_Player“.\n\n2.  Erkläre warum **next\\_next\\_hedgehog** den Wert 11 hätte, wenn wir\n    auf den letzten Igelfeld stehen würden.\n\n        int next_hedgehog = b.getNextFieldByType(FieldType.HEDGEHOG,\n                                                 currentPlayer.getFieldIndex());\n        int next_next_hedgehog = b.getNextFieldByType(FieldType.HEDGEHOG, next_hedgehog);\n\n3.  Schreibe eine Funktion, welche das übernächste Igelfeld ausgibt.\n    Gibt es solch ein Feld nicht, so soll immer -1 zurückgegeben werden.\n\n# Die Klasse Player\n\nDie Klasse Player repräsentiert einen Spieler. Der eigene Spieler kann\nin der RandomLogic durch die Variable **currentPlayer** oder mithilfe\nder GameState Funktion *getCurrentPlayer()* abgefragt werden. Der\ngegnerische Spieler kann ebenfalls mithilfe einer Methode von GameState\nbestimmt werden (*gameState.getOtherPlayer()*).\n\nDie Klasse Player besitzt viele Funktionen, welche einen Informationen\nüber den Spieler geben:\n\n<table>\n<colgroup>\n<col style=\"width: 50%\" />\n<col style=\"width: 50%\" />\n</colgroup>\n<tbody>\n<tr class=\"odd\">\n<td style=\"text-align: left;\"><p>java.util.List&lt;CardType&gt;</p></td>\n<td style=\"text-align: left;\"><p><em>getCards()</em><br />\nGibt die für diesen Spieler verfügbaren Hasenkarten zurück.</p></td>\n</tr>\n<tr class=\"even\">\n<td style=\"text-align: left;\"><p>java.util.List&lt;CardType&gt;</p></td>\n<td style=\"text-align: left;\"><p><em>getCardsWithout(CardType\ntype)</em><br />\nGibt Karten ohne bestimmten Typ zurück.</p></td>\n</tr>\n<tr class=\"odd\">\n<td style=\"text-align: left;\"><p>int</p></td>\n<td style=\"text-align: left;\"><p><em>getCarrots()</em><br />\nDie Anzahl an Karotten die der Spieler zur Zeit auf der Hand\nhat.</p></td>\n</tr>\n<tr class=\"even\">\n<td style=\"text-align: left;\"><p>int</p></td>\n<td style=\"text-align: left;\"><p><em>getFieldIndex()</em><br />\nDie aktuelle Position der Figur auf dem Spielfeld.</p></td>\n</tr>\n<tr class=\"odd\">\n<td style=\"text-align: left;\"><p>Action</p></td>\n<td style=\"text-align: left;\"><p><em>getLastNonSkipAction</em><br />\nGibt letzte Aktion des Spielers zurück.</p></td>\n</tr>\n<tr class=\"even\">\n<td style=\"text-align: left;\"><p>sc.shared.PlayerColor</p></td>\n<td style=\"text-align: left;\"><p><em>getPlayerColor()</em><br />\nDie Farbe dieses Spielers auf dem Spielbrett</p></td>\n</tr>\n<tr class=\"odd\">\n<td style=\"text-align: left;\"><p>int</p></td>\n<td style=\"text-align: left;\"><p><em>getSalads()</em><br />\nDie Anzahl der Salate, die dieser Spieler noch verspeisen muss.</p></td>\n</tr>\n<tr class=\"even\">\n<td style=\"text-align: left;\"><p>boolean</p></td>\n<td style=\"text-align: left;\"><p><em>inGoal()</em><br />\nÜberprüft, ob Spieler im Ziel.</p></td>\n</tr>\n<tr class=\"odd\">\n<td style=\"text-align: left;\"><p>boolean</p></td>\n<td style=\"text-align: left;\"><p><em>ownsCardOfType(CardType\ntype)</em><br />\nÜberprüft ob Spieler bestimmte Karte noch besitzt</p></td>\n</tr>\n</tbody>\n</table>\n\nDie Vollständige API ist in /doc/sc/plugin2018/Player.html zu finden.\n\nDie Meisten dieser Funktionen sind selbsterklärend. Dennoch sind hier\neinige Beispiele angegeben:\n\n    System.out.print(\"Du hast noch folgende Karten: \");\n    for (CardType c : currentPlayer.getCards()) {\n        System.out.print(c + \" \");\n    }\n    System.out.println();\n\nDies würde alle Karten ausgeben, welche man noch hat.\n\n    if (currentPlayer.inGoal() && !currentPlayer.getCards().isEmpty()) {\n        System.out.println(\"Was fuer eine Verschwendung.\");\n    }\n\nDie If-Bedingung würde dann ausgeführt werden, wenn man im Ziel ist,\nallerdings noch Karten hat.\n\nEine weitere wichtige Funktion ist *getFieldIndex*. Diese Funktion wird\nhäufig im Dokument „Hase\\_Igel\\_Spielbrett“ verwendet.\n\nNeben diesen Funktionen existieren noch einige „Setter“. Diese sind\nallerdings hauptsächlich für den Server notwendig und haben einen\ngeringen praktischen Nutzten für uns.\n\n## Aufgabe\n\nSchreibe eine If-Bedingung, welche abfragt, ob beide Spieler auf dem\nselben Feld sind. Da dies nur möglich ist, wenn man auf dem Start-\nZielfeld ist, soll zunächst abgefragt werden, ob der aktuelle Spieler\nauf dem Start- Zielfeld ist. Tipp: Es gibt die Funktion getTypeAt der\nKlasse Board. Weiter Informationen sind im Dokument\n„Hase\\_Igel\\_Spielbrett“ zu finden.\n\n# GameRuleLogic: Hilfreiche Hilfsfunktionen\n\nDie Klasse GameRuleLogic hat viele Hilfsfunktionen, mit welchen man die\nRegeln des Spieles überprüfen kann. Hierbei sind alle Funktionen static.\nD.h., dass man sie ohne eine Instanz aufrufen kann.\n\n<table>\n<colgroup>\n<col style=\"width: 50%\" />\n<col style=\"width: 50%\" />\n</colgroup>\n<tbody>\n<tr class=\"odd\">\n<td style=\"text-align: left;\"><p>static int</p></td>\n<td style=\"text-align: left;\"><p><em>calculateCarrots(int\nmoveCount)</em><br />\nBerechnet wie viele Karotten für einen Zug der Länge moveCount benötigt\nwerden.</p></td>\n</tr>\n<tr class=\"even\">\n<td style=\"text-align: left;\"><p>static int</p></td>\n<td style=\"text-align: left;\"><p><em>calculateMoveableFields(int\ncarrots)</em><br />\nBerechnet, wie weit man mit carrots Karotten gehen kann. Beispiel: Mit\n68 Karotten kann man 11 Felder weit gehen.</p></td>\n</tr>\n<tr class=\"odd\">\n<td style=\"text-align: left;\"><p>static boolean</p></td>\n<td style=\"text-align: left;\"><p><em>canPlayCard(GameState\nstate)*</em><br />\nGibt zurück, ob der derzeitige Spieler eine Karte spielen kann.</p></td>\n</tr>\n<tr class=\"even\">\n<td style=\"text-align: left;\"><p>static boolean</p></td>\n<td style=\"text-align: left;\"><p><em>isValidToAdvance(GameState state,\nint distance)</em><br />\nÜberprüft <em>Advance</em> Aktionen auf ihre Korrektheit.\n<em>Distance</em> steht für die Distanz die man zurücklegen\nwill.Three</p></td>\n</tr>\n<tr class=\"odd\">\n<td style=\"text-align: left;\"><p>static boolean</p></td>\n<td style=\"text-align: left;\"><p><em>isValidToEat(GameState\nstate)</em><br />\nÜberprüft <em>EatSalad</em> Züge auf Korrektheit. Diese Funktion bezieht\nsich <strong>nicht</strong> auf die Karte\n<em>TAKE_OR_DROP_CARROTS</em></p></td>\n</tr>\n<tr class=\"even\">\n<td style=\"text-align: left;\"><p>static boolean</p></td>\n<td style=\"text-align: left;\"><p><em>isValidToExchangeCarrots(GameState\nstate, int n)</em><br />\nÜberprüft ob der derzeitige Spieler 10 Karotten nehmen oder abgeben\nkann. „n“ kann entweder 10 oder -10 sein. Je nachdem ob man annehmen\noder abgeben will. Diese Funktion bezieht sich <strong>nicht</strong>\nauf die Karte <em>EAT_SALAD</em>.</p></td>\n</tr>\n<tr class=\"odd\">\n<td style=\"text-align: left;\"><p>static boolean</p></td>\n<td style=\"text-align: left;\"><p><em>isValidToFallBack(GameState\nstate)</em><br />\nÜberprüft <em>FallBack</em> Züge auf Korrektheit</p></td>\n</tr>\n<tr class=\"even\">\n<td style=\"text-align: left;\"><p>static boolean</p></td>\n<td style=\"text-align: left;\"><p><em>isValidToPlayCard(GameState state,\nCardType c,int n)*</em><br />\nÜberprüft ob der derzeitige Spieler die Karte spielen kann. „n“ wird für\ndie <em>TAKE_OR_DROP_CARROTS</em> Karte benötigt (s.u). „n“ kann die\nWert 0, 20 oder -20 annehmen.</p></td>\n</tr>\n<tr class=\"odd\">\n<td style=\"text-align: left;\"><p>static boolean</p></td>\n<td style=\"text-align: left;\"><p><em>isValidToPlayEatSalad(GameState\nstate)*</em><br />\nÜberprüft ob der derzeitige Spieler die <em>EAT_SALAD</em> Karte spielen\ndarf.</p></td>\n</tr>\n<tr class=\"even\">\n<td style=\"text-align: left;\"><p>static boolean</p></td>\n<td style=\"text-align: left;\"><p><em>isValidToPlayFallBack(GameState\nstate)*</em><br />\nÜberprüft ob der derzeitige Spieler die <em>FALL_BACK</em> Karte spielen\ndarf.</p></td>\n</tr>\n<tr class=\"odd\">\n<td style=\"text-align: left;\"><p>static boolean</p></td>\n<td style=\"text-align: left;\"><p><em>isValidToPlayHurryAhead(GameState\nstate) *</em><br />\nÜberprüft ob der derzeitige Spieler die <em>HURRY_AHEAD</em> Karte\nspielen darf.</p></td>\n</tr>\n<tr class=\"even\">\n<td style=\"text-align: left;\"><p>static boolean</p></td>\n<td\nstyle=\"text-align: left;\"><p><em>isValidToPlayTakeOrDropCarrots(GameState\nstate,int n)*</em><br />\nÜberprüft ob der derzeitige Spieler die <em>TAKE_OR_DROP_CARROTS</em>\nKarte spielen darf. „n“ kann entweder 0, 20 oder -20 sein.</p></td>\n</tr>\n<tr class=\"odd\">\n<td style=\"text-align: left;\"><p>static boolean</p></td>\n<td style=\"text-align: left;\"><p><em>isValidToSkip(GameState\nstate)</em><br />\nÜberprüft, ob der derzeitige Spieler aussetzen darf.</p></td>\n</tr>\n<tr class=\"even\">\n<td style=\"text-align: left;\"><p>static boolean</p></td>\n<td style=\"text-align: left;\"><p><em>mustEatSalad(GameState\nstate)</em><br />\nÜberprüft ob man einen Salat fressen muss. Dies ist immer der Fall, wenn\nman in der vorherigen Runde ein Salatfeld betreten hat.</p></td>\n</tr>\n<tr class=\"odd\">\n<td style=\"text-align: left;\"><p>static boolean</p></td>\n<td style=\"text-align: left;\"><p><em>mustPlayCard(GameState state)\n*</em><br />\nÜberprüft ob eine Karte gespielt werden muss.</p></td>\n</tr>\n<tr class=\"even\">\n<td style=\"text-align: left;\"><p>static boolean</p></td>\n<td style=\"text-align: left;\"><p><em>playerMustAdvance(GameState\nstate)</em><br />\nÜberprüft ab der derzeitige Spieler im nächsten Zug einen Vorwärtszug\nmachen muss.</p></td>\n</tr>\n</tbody>\n</table>\n\n\\*Diese Funktionen werden im Kapitel „Erweiterte Beispiele“ besprochen.\n\nDie komplette API-Dokumentation ist in\ndoc/sc/plugin2018/util/GameRuleLogic.html zu finden.\n\n## Simulation des Gegners\n\nNatürlich kann man alle diese Funktionen auch auf den Gegenspieler\nanwenden. Dafür müssen wir allerdings eine Kopie des GameState\nerstellen:\n\n    try {\n      GameState otherGame = gameState.clone(); // Deep-Copy\n      // Rundenanzahl hochsetzten für switch Befehl:\n      otherGame.setTurn(gameState.getTurn()+1);\n      // Tausche currentPlayer (hängt von der Rundenanzahl ab):\n      otherGame.switchCurrentPlayer();\n      // Gib Informationen über den Gegner aus:\n      System.out.println(\"CurrentPlayer von otherGame:\" + otherGame.getCurrentPlayer());\n    } catch (CloneNotSupportedException e1) { // Fehlerbehandlung\n      e1.printStackTrace();\n    }\n\nAlle Funktionen von GameRuleLogic können wir nun, mithilfe der Variable\notherGame, auf den Gegner anwenden.\n\n## Einführende Beispiele\n\nDie meisten Funktionen dieser Klasse sind selbsterklärend. Dennoch\nwerden einige der häufig verwendeten Funktionen mit kleinen Beispielen\nvorgestellt.\n\n    if (GameRuleLogic.isValidToEat(gameState) != GameRuleLogic.mustEatSalad(gameState)) {\n      System.out.println(\"Unmöglich\");\n    }\n\nNach den Regeln muss man immer ein Salat essen, wenn man im vorherigen\nZug ein Salatfeld betreten hat. Außerdem ist dies die einzige\nMöglichkeit die Aktion EatSalad auszuführen (nicht mit dem Spielen der\nEAT\\_SALAD Karte verwechseln).\n\nDadurch wird auch die Unerfüllbarkeit des folgenden Ausdrucks\nimpliziert:\n\n    if (GameRuleLogic.isValidToEat(gameState) &&\n        (GameRuleLogic.isValidToFallBack(gameState) || GameRuleLogic.canMove(gameState))) {\n      System.out.println(\"Unmöglich\");\n    }\n\nEine weiter hilfreiche Funktion ist *isValidToAdvance*. Mit dieser\nFunktion wird überprüft, ob ein Vorwärtszug mit der übergeben Distanz\nüberhaupt möglich ist:\n\n    // berechne die maximale Entfernung, welche man laufen darf\n    int max_move = GameRuleLogic.calculateMoveableFields(currentPlayer.getCarrots());\n\n    if (GameRuleLogic.isValidToAdvance(gameState, max_move +1)) {\n      System.out.println(\"Unmöglich\");\n    }\n\nDie Funktion *calculateMoveableFields* gibt hierbei die maximale\nEntfernung zurück, welche man mit den übergebenen Karotten laufen darf.\nDiese maximale Entfernung wird immer um 1 erhöht, was dazu führt, dass\nder Zug immer unmöglich ist.\n\n## Erweitertes Beispiel\n\nAlle Funktionen die mit einem \\* markiert wurden (s.o) haben eine\nGemeinsamkeit. Sie beziehen sich auf das Spielen von Karten. Das Spielen\nvon Karten ist allerdings nur erlaubt, wenn man das entsprechende\nHasenfeld in der selben Zug betreten hat. Deshalb müssen wir GameState\nbearbeiten, damit diese Funktionen überhaupt Sinn haben. Das folgende\nBeispiel gibt eine Möglichkeit an, wie man diese Funktionen einsetzten\nkann:\n\n    int nextHareFieldIndex = gameState.getNextFieldByType(FieldType.HARE,\n                                                          currentPlayer.getFieldIndex())\n    // wenn es ein nächstes Hasenfeld gibt\n    if (nextHareFieldIndex > 0) {\n      try {\n\n        GameState gameHare = gameState.clone(); // erstelle Deep-Copy\n        Player harePlayer = gameHare.getCurrentPlayer(); // erstelle Shallow-Copy\n\n        //setzte den aktuellen Spieler auf ein Hasenfeld\n        harePlayer.setFieldIndex(nextHareFieldIndex);\n        System.out.println(gameHare.getCurrentPlayer().getCards()); // gib alle Karten aus\n\n        // Welche Karten kann man spielen?\n        System.out.println(\"Play EatSalad: \" +\n                           GameRuleLogic.isValidToPlayEatSalad(gameHare));\n        System.out.println(\"Play TakeOrDropCarrots: \" +\n                           GameRuleLogic.isValidToPlayTakeOrDropCarrots(gameHare,20));\n        System.out.println(\"Play HurryAhead: \" +\n                           GameRuleLogic.isValidToPlayHurryAhead(gameHare));\n        System.out.println(\"Play FallBack: \" +\n                           GameRuleLogic.isValidToPlayFallBack(gameHare));\n\n      } catch (CloneNotSupportedException e1) {\n        e1.printStackTrace();\n      }\n    }\n\nHierfür müssen wir den Spieler einfach nur auf das Hasenfeld setzten.\nAllerdings wird nicht überprüft, ob der Spieler überhaupt bis zum\nnächsten Hasenfeld laufen kann.\n\n## Aufgaben\n\n1.  Ist das Ausführen der inneren If-Bedingung wirklich unmöglich.\n    Erkläre warum oder gib ein Gegenbeispiel an:\n\n<!-- -->\n\n    int dif = gameState.getOtherPlayer().getFieldIndex() - currentPlayer.getFieldIndex();\n\n    if (dif >= 0 &&\n        dif <= GameRuleLogic.calculateMoveableFields(currentPlayer.getCarrots())) {\n      if (GameRuleLogic.isValidToAdvance(gameState, dif)) {\n        System.out.println(\"Unmöglich\");\n      }\n    }\n\n1.  Erweiterte das Beispiel aus dem Kapitel „Erweitertes Beispiel“ so,\n    dass sicher gestellt wird, dass der aktuelle Spieler auf ein\n    Hasenfeld gesetzt wird, welches er wirklich erreichen kann.\n\n[1] Technisch gesehen hat die Klasse eine private Liste von Feldern.\nAllerdings ähnelt ein Aufruf der Funktion getTypeAt sehr den Aufruf\neines Arrays. Auch wenn der Rückgabewert kein Feld sonder ein FieldType\nist.\n","data":{},"toc":{"headings":[{"level":1,"label":"Start zum Schreiben einer KI","anchor":"start-zum-schreiben-einer-ki"},{"level":2,"label":"Wo schreibe ich die KI?","anchor":"wo-schreibe-ich-die-ki"},{"level":2,"label":"Wichtige Membervariablen","anchor":"wichtige-membervariablen"},{"level":2,"label":"Aufgaben","anchor":"aufgaben"},{"level":1,"label":"Spielbrett Informationen","anchor":"spielbrett-informationen"},{"level":2,"label":"Die Klasse „FieldType“","anchor":"die-klasse-fieldtype"},{"level":2,"label":"Funktionen der Klasse „Board“","anchor":"funktionen-der-klasse-board"},{"level":3,"label":"public final int getNextFieldByType(FieldType type,int pos)","anchor":"public-final-int-getnextfieldbytypefieldtype-typeint-pos"},{"level":3,"label":"public final int getPreviousFieldByType(FieldType type,int pos)","anchor":"public-final-int-getpreviousfieldbytypefieldtype-typeint-pos"},{"level":3,"label":"public final FieldType getTypeAt(int pos)","anchor":"public-final-fieldtype-gettypeatint-pos"},{"level":2,"label":"Aufgaben","anchor":"aufgaben"},{"level":1,"label":"Die Klasse Player","anchor":"die-klasse-player"},{"level":2,"label":"Aufgabe","anchor":"aufgabe"},{"level":1,"label":"GameRuleLogic: Hilfreiche Hilfsfunktionen","anchor":"gamerulelogic-hilfreiche-hilfsfunktionen"},{"level":2,"label":"Simulation des Gegners","anchor":"simulation-des-gegners"},{"level":2,"label":"Einführende Beispiele","anchor":"einfhrende-beispiele"},{"level":2,"label":"Erweitertes Beispiel","anchor":"erweitertes-beispiel"},{"level":2,"label":"Aufgaben","anchor":"aufgaben"}]},"navigation":{"next":{"name":"einleitung-xml","repo":"https://github.com/software-challenge/docs/tree/main/hyperbook/book/spiele/hase-und-igel/xml-dokumentation/einleitung-xml.md","href":"/spiele/hase-und-igel/xml-dokumentation/einleitung-xml"},"current":{"name":"tutorial","repo":"https://github.com/software-challenge/docs/tree/main/hyperbook/book/spiele/hase-und-igel/tutorial/tutorial.md","href":"/spiele/hase-und-igel/tutorial/tutorial"},"previous":{"name":"start","repo":"https://github.com/software-challenge/docs/tree/main/hyperbook/book/spiele/hase-und-igel/tutorial/start.md","href":"/spiele/hase-und-igel/tutorial/start"},"sections":[{"name":"Die Software-Challenge","index":0,"isEmpty":false,"pages":[{"name":"Wettkampfmodalitäten","index":2,"repo":"https://github.com/software-challenge/docs/tree/main/hyperbook/book/allgemein/wettkampf.md","href":"/allgemein/wettkampf"},{"name":"Das Spiel kennenlernen","index":3,"repo":"https://github.com/software-challenge/docs/tree/main/hyperbook/book/allgemein/spiel.md","href":"/allgemein/spiel"}],"sections":[],"repo":"https://github.com/software-challenge/docs/tree/main/hyperbook/book/allgemein/index.md","href":"/allgemein"},{"name":"Spiele","index":1,"virtual":true,"isEmpty":true,"pages":[],"sections":[{"name":"Hey, Danke für den Fisch!","index":1,"isEmpty":false,"pages":[{"name":"Spielregeln","index":1,"repo":"https://github.com/software-challenge/docs/tree/main/hyperbook/book/spiele/penguins/regeln.md","href":"/spiele/penguins/regeln"},{"name":"XML-Schnittstelle","repo":"https://github.com/software-challenge/docs/tree/main/hyperbook/book/spiele/penguins/xml.md","href":"/spiele/penguins/xml"}],"sections":[],"repo":"https://github.com/software-challenge/docs/tree/main/hyperbook/book/spiele/penguins/index.md","href":"/spiele/penguins"},{"name":"Blokus","hide":true,"isEmpty":false,"pages":[],"sections":[{"name":"Spielregeln","hide":true,"isEmpty":true,"pages":[{"name":"content","repo":"https://github.com/software-challenge/docs/tree/main/hyperbook/book/spiele/blokus/spielregeln/content.md","href":"/spiele/blokus/spielregeln/content"},{"name":"regeln","repo":"https://github.com/software-challenge/docs/tree/main/hyperbook/book/spiele/blokus/spielregeln/regeln.md","href":"/spiele/blokus/spielregeln/regeln"}],"sections":[],"repo":"https://github.com/software-challenge/docs/tree/main/hyperbook/book/spiele/blokus/spielregeln/index.md","href":"/spiele/blokus/spielregeln"},{"name":"XML-Dokumentation","hide":true,"isEmpty":true,"pages":[{"name":"einleitung-xml","repo":"https://github.com/software-challenge/docs/tree/main/hyperbook/book/spiele/blokus/xml-dokumentation/einleitung-xml.md","href":"/spiele/blokus/xml-dokumentation/einleitung-xml"},{"name":"spiel-betreten","repo":"https://github.com/software-challenge/docs/tree/main/hyperbook/book/spiele/blokus/xml-dokumentation/spiel-betreten.md","href":"/spiele/blokus/xml-dokumentation/spiel-betreten"},{"name":"spiel-verlassen","repo":"https://github.com/software-challenge/docs/tree/main/hyperbook/book/spiele/blokus/xml-dokumentation/spiel-verlassen.md","href":"/spiele/blokus/xml-dokumentation/spiel-verlassen"},{"name":"spielergebnis","repo":"https://github.com/software-challenge/docs/tree/main/hyperbook/book/spiele/blokus/xml-dokumentation/spielergebnis.md","href":"/spiele/blokus/xml-dokumentation/spielergebnis"},{"name":"spielstatus","repo":"https://github.com/software-challenge/docs/tree/main/hyperbook/book/spiele/blokus/xml-dokumentation/spielstatus.md","href":"/spiele/blokus/xml-dokumentation/spielstatus"},{"name":"spielsteine","repo":"https://github.com/software-challenge/docs/tree/main/hyperbook/book/spiele/blokus/xml-dokumentation/spielsteine.md","href":"/spiele/blokus/xml-dokumentation/spielsteine"},{"name":"spielverlauf","repo":"https://github.com/software-challenge/docs/tree/main/hyperbook/book/spiele/blokus/xml-dokumentation/spielverlauf.md","href":"/spiele/blokus/xml-dokumentation/spielverlauf"},{"name":"xml-dokumentation","repo":"https://github.com/software-challenge/docs/tree/main/hyperbook/book/spiele/blokus/xml-dokumentation/xml-dokumentation.md","href":"/spiele/blokus/xml-dokumentation/xml-dokumentation"},{"name":"zuege-senden","repo":"https://github.com/software-challenge/docs/tree/main/hyperbook/book/spiele/blokus/xml-dokumentation/zuege-senden.md","href":"/spiele/blokus/xml-dokumentation/zuege-senden"},{"name":"zug-anforderung","repo":"https://github.com/software-challenge/docs/tree/main/hyperbook/book/spiele/blokus/xml-dokumentation/zug-anforderung.md","href":"/spiele/blokus/xml-dokumentation/zug-anforderung"}],"sections":[],"repo":"https://github.com/software-challenge/docs/tree/main/hyperbook/book/spiele/blokus/xml-dokumentation/index.md","href":"/spiele/blokus/xml-dokumentation"}],"repo":"https://github.com/software-challenge/docs/tree/main/hyperbook/book/spiele/blokus/index.md","href":"/spiele/blokus"},{"name":"Hase und Igel","hide":true,"isEmpty":false,"pages":[],"sections":[{"name":"Spielregeln","hide":true,"isEmpty":true,"pages":[{"name":"beispiel","repo":"https://github.com/software-challenge/docs/tree/main/hyperbook/book/spiele/hase-und-igel/spielregeln/beispiel.md","href":"/spiele/hase-und-igel/spielregeln/beispiel"},{"name":"felder","repo":"https://github.com/software-challenge/docs/tree/main/hyperbook/book/spiele/hase-und-igel/spielregeln/felder.md","href":"/spiele/hase-und-igel/spielregeln/felder"},{"name":"regeln","repo":"https://github.com/software-challenge/docs/tree/main/hyperbook/book/spiele/hase-und-igel/spielregeln/regeln.md","href":"/spiele/hase-und-igel/spielregeln/regeln"},{"name":"spielbeginn","repo":"https://github.com/software-challenge/docs/tree/main/hyperbook/book/spiele/hase-und-igel/spielregeln/spielbeginn.md","href":"/spiele/hase-und-igel/spielregeln/spielbeginn"},{"name":"spielende","repo":"https://github.com/software-challenge/docs/tree/main/hyperbook/book/spiele/hase-und-igel/spielregeln/spielende.md","href":"/spiele/hase-und-igel/spielregeln/spielende"},{"name":"zuege","repo":"https://github.com/software-challenge/docs/tree/main/hyperbook/book/spiele/hase-und-igel/spielregeln/zuege.md","href":"/spiele/hase-und-igel/spielregeln/zuege"}],"sections":[],"repo":"https://github.com/software-challenge/docs/tree/main/hyperbook/book/spiele/hase-und-igel/spielregeln/index.md","href":"/spiele/hase-und-igel/spielregeln"},{"name":"Tutorial","hide":true,"isEmpty":true,"pages":[{"name":"board","repo":"https://github.com/software-challenge/docs/tree/main/hyperbook/book/spiele/hase-und-igel/tutorial/board.md","href":"/spiele/hase-und-igel/tutorial/board"},{"name":"game-rule-logic","repo":"https://github.com/software-challenge/docs/tree/main/hyperbook/book/spiele/hase-und-igel/tutorial/game-rule-logic.md","href":"/spiele/hase-und-igel/tutorial/game-rule-logic"},{"name":"player","repo":"https://github.com/software-challenge/docs/tree/main/hyperbook/book/spiele/hase-und-igel/tutorial/player.md","href":"/spiele/hase-und-igel/tutorial/player"},{"name":"start","repo":"https://github.com/software-challenge/docs/tree/main/hyperbook/book/spiele/hase-und-igel/tutorial/start.md","href":"/spiele/hase-und-igel/tutorial/start"},{"name":"tutorial","repo":"https://github.com/software-challenge/docs/tree/main/hyperbook/book/spiele/hase-und-igel/tutorial/tutorial.md","href":"/spiele/hase-und-igel/tutorial/tutorial"}],"sections":[],"repo":"https://github.com/software-challenge/docs/tree/main/hyperbook/book/spiele/hase-und-igel/tutorial/index.md","href":"/spiele/hase-und-igel/tutorial"},{"name":"XML-Dokumentation","hide":true,"isEmpty":true,"pages":[{"name":"einleitung-xml","repo":"https://github.com/software-challenge/docs/tree/main/hyperbook/book/spiele/hase-und-igel/xml-dokumentation/einleitung-xml.md","href":"/spiele/hase-und-igel/xml-dokumentation/einleitung-xml"},{"name":"fehler","repo":"https://github.com/software-challenge/docs/tree/main/hyperbook/book/spiele/hase-und-igel/xml-dokumentation/fehler.md","href":"/spiele/hase-und-igel/xml-dokumentation/fehler"},{"name":"spiel-betreten","repo":"https://github.com/software-challenge/docs/tree/main/hyperbook/book/spiele/hase-und-igel/xml-dokumentation/spiel-betreten.md","href":"/spiele/hase-und-igel/xml-dokumentation/spiel-betreten"},{"name":"spiel-verlassen","repo":"https://github.com/software-challenge/docs/tree/main/hyperbook/book/spiele/hase-und-igel/xml-dokumentation/spiel-verlassen.md","href":"/spiele/hase-und-igel/xml-dokumentation/spiel-verlassen"},{"name":"spielergebnis","repo":"https://github.com/software-challenge/docs/tree/main/hyperbook/book/spiele/hase-und-igel/xml-dokumentation/spielergebnis.md","href":"/spiele/hase-und-igel/xml-dokumentation/spielergebnis"},{"name":"spielstatus","repo":"https://github.com/software-challenge/docs/tree/main/hyperbook/book/spiele/hase-und-igel/xml-dokumentation/spielstatus.md","href":"/spiele/hase-und-igel/xml-dokumentation/spielstatus"},{"name":"spielverlauf","repo":"https://github.com/software-challenge/docs/tree/main/hyperbook/book/spiele/hase-und-igel/xml-dokumentation/spielverlauf.md","href":"/spiele/hase-und-igel/xml-dokumentation/spielverlauf"},{"name":"xml-dokumentation","repo":"https://github.com/software-challenge/docs/tree/main/hyperbook/book/spiele/hase-und-igel/xml-dokumentation/xml-dokumentation.md","href":"/spiele/hase-und-igel/xml-dokumentation/xml-dokumentation"},{"name":"zuege-senden","repo":"https://github.com/software-challenge/docs/tree/main/hyperbook/book/spiele/hase-und-igel/xml-dokumentation/zuege-senden.md","href":"/spiele/hase-und-igel/xml-dokumentation/zuege-senden"},{"name":"zug-anforderung","repo":"https://github.com/software-challenge/docs/tree/main/hyperbook/book/spiele/hase-und-igel/xml-dokumentation/zug-anforderung.md","href":"/spiele/hase-und-igel/xml-dokumentation/zug-anforderung"}],"sections":[],"repo":"https://github.com/software-challenge/docs/tree/main/hyperbook/book/spiele/hase-und-igel/xml-dokumentation/index.md","href":"/spiele/hase-und-igel/xml-dokumentation"}],"repo":"https://github.com/software-challenge/docs/tree/main/hyperbook/book/spiele/hase-und-igel/index.md","href":"/spiele/hase-und-igel"},{"name":"Hive","hide":true,"isEmpty":false,"pages":[],"sections":[{"name":"Spielregeln","hide":true,"isEmpty":true,"pages":[{"name":"regeln","repo":"https://github.com/software-challenge/docs/tree/main/hyperbook/book/spiele/hive/spielregeln/regeln.md","href":"/spiele/hive/spielregeln/regeln"}],"sections":[],"repo":"https://github.com/software-challenge/docs/tree/main/hyperbook/book/spiele/hive/spielregeln/index.md","href":"/spiele/hive/spielregeln"},{"name":"XML-Dokumention","hide":true,"isEmpty":true,"pages":[{"name":"einleitung-xml","repo":"https://github.com/software-challenge/docs/tree/main/hyperbook/book/spiele/hive/xml-dokumentation/einleitung-xml.md","href":"/spiele/hive/xml-dokumentation/einleitung-xml"},{"name":"fehler","repo":"https://github.com/software-challenge/docs/tree/main/hyperbook/book/spiele/hive/xml-dokumentation/fehler.md","href":"/spiele/hive/xml-dokumentation/fehler"},{"name":"spiel-betreten","repo":"https://github.com/software-challenge/docs/tree/main/hyperbook/book/spiele/hive/xml-dokumentation/spiel-betreten.md","href":"/spiele/hive/xml-dokumentation/spiel-betreten"},{"name":"spiel-verlassen","repo":"https://github.com/software-challenge/docs/tree/main/hyperbook/book/spiele/hive/xml-dokumentation/spiel-verlassen.md","href":"/spiele/hive/xml-dokumentation/spiel-verlassen"},{"name":"spielergebnis","repo":"https://github.com/software-challenge/docs/tree/main/hyperbook/book/spiele/hive/xml-dokumentation/spielergebnis.md","href":"/spiele/hive/xml-dokumentation/spielergebnis"},{"name":"spielstatus","repo":"https://github.com/software-challenge/docs/tree/main/hyperbook/book/spiele/hive/xml-dokumentation/spielstatus.md","href":"/spiele/hive/xml-dokumentation/spielstatus"},{"name":"spielverlauf","repo":"https://github.com/software-challenge/docs/tree/main/hyperbook/book/spiele/hive/xml-dokumentation/spielverlauf.md","href":"/spiele/hive/xml-dokumentation/spielverlauf"},{"name":"xml-dokumentation","repo":"https://github.com/software-challenge/docs/tree/main/hyperbook/book/spiele/hive/xml-dokumentation/xml-dokumentation.md","href":"/spiele/hive/xml-dokumentation/xml-dokumentation"},{"name":"zuege-senden","repo":"https://github.com/software-challenge/docs/tree/main/hyperbook/book/spiele/hive/xml-dokumentation/zuege-senden.md","href":"/spiele/hive/xml-dokumentation/zuege-senden"},{"name":"zug-anforderung","repo":"https://github.com/software-challenge/docs/tree/main/hyperbook/book/spiele/hive/xml-dokumentation/zug-anforderung.md","href":"/spiele/hive/xml-dokumentation/zug-anforderung"}],"sections":[],"repo":"https://github.com/software-challenge/docs/tree/main/hyperbook/book/spiele/hive/xml-dokumentation/index.md","href":"/spiele/hive/xml-dokumentation"}],"repo":"https://github.com/software-challenge/docs/tree/main/hyperbook/book/spiele/hive/index.md","href":"/spiele/hive"},{"name":"Ostseeschach","hide":true,"isEmpty":false,"pages":[{"name":"regeln","repo":"https://github.com/software-challenge/docs/tree/main/hyperbook/book/spiele/ostseeschach/regeln.md","href":"/spiele/ostseeschach/regeln"},{"name":"xml-dokumentation","repo":"https://github.com/software-challenge/docs/tree/main/hyperbook/book/spiele/ostseeschach/xml-dokumentation.md","href":"/spiele/ostseeschach/xml-dokumentation"}],"sections":[],"repo":"https://github.com/software-challenge/docs/tree/main/hyperbook/book/spiele/ostseeschach/index.md","href":"/spiele/ostseeschach"},{"name":"Piranhas","hide":true,"isEmpty":false,"pages":[],"sections":[{"name":"Spielregeln","hide":true,"isEmpty":true,"pages":[{"name":"regeln","repo":"https://github.com/software-challenge/docs/tree/main/hyperbook/book/spiele/piranhas/spielregeln/regeln.md","href":"/spiele/piranhas/spielregeln/regeln"}],"sections":[],"repo":"https://github.com/software-challenge/docs/tree/main/hyperbook/book/spiele/piranhas/spielregeln/index.md","href":"/spiele/piranhas/spielregeln"},{"name":"XML-Dokumentation","hide":true,"isEmpty":true,"pages":[{"name":"einleitung-xml","repo":"https://github.com/software-challenge/docs/tree/main/hyperbook/book/spiele/piranhas/xml-dokumentation/einleitung-xml.md","href":"/spiele/piranhas/xml-dokumentation/einleitung-xml"},{"name":"fehler","repo":"https://github.com/software-challenge/docs/tree/main/hyperbook/book/spiele/piranhas/xml-dokumentation/fehler.md","href":"/spiele/piranhas/xml-dokumentation/fehler"},{"name":"spiel-betreten","repo":"https://github.com/software-challenge/docs/tree/main/hyperbook/book/spiele/piranhas/xml-dokumentation/spiel-betreten.md","href":"/spiele/piranhas/xml-dokumentation/spiel-betreten"},{"name":"spiel-verlassen","repo":"https://github.com/software-challenge/docs/tree/main/hyperbook/book/spiele/piranhas/xml-dokumentation/spiel-verlassen.md","href":"/spiele/piranhas/xml-dokumentation/spiel-verlassen"},{"name":"spielergebnis","repo":"https://github.com/software-challenge/docs/tree/main/hyperbook/book/spiele/piranhas/xml-dokumentation/spielergebnis.md","href":"/spiele/piranhas/xml-dokumentation/spielergebnis"},{"name":"spielstatus","repo":"https://github.com/software-challenge/docs/tree/main/hyperbook/book/spiele/piranhas/xml-dokumentation/spielstatus.md","href":"/spiele/piranhas/xml-dokumentation/spielstatus"},{"name":"spielverlauf","repo":"https://github.com/software-challenge/docs/tree/main/hyperbook/book/spiele/piranhas/xml-dokumentation/spielverlauf.md","href":"/spiele/piranhas/xml-dokumentation/spielverlauf"},{"name":"xml-dokumentation","repo":"https://github.com/software-challenge/docs/tree/main/hyperbook/book/spiele/piranhas/xml-dokumentation/xml-dokumentation.md","href":"/spiele/piranhas/xml-dokumentation/xml-dokumentation"},{"name":"zuege-senden","repo":"https://github.com/software-challenge/docs/tree/main/hyperbook/book/spiele/piranhas/xml-dokumentation/zuege-senden.md","href":"/spiele/piranhas/xml-dokumentation/zuege-senden"},{"name":"zug-anforderung","repo":"https://github.com/software-challenge/docs/tree/main/hyperbook/book/spiele/piranhas/xml-dokumentation/zug-anforderung.md","href":"/spiele/piranhas/xml-dokumentation/zug-anforderung"}],"sections":[],"repo":"https://github.com/software-challenge/docs/tree/main/hyperbook/book/spiele/piranhas/xml-dokumentation/index.md","href":"/spiele/piranhas/xml-dokumentation"}],"repo":"https://github.com/software-challenge/docs/tree/main/hyperbook/book/spiele/piranhas/index.md","href":"/spiele/piranhas"}],"repo":"https://github.com/software-challenge/docs/tree/main/hyperbook/book/spiele/index.md","href":"/spiele"},{"name":"Entwicklung","index":2,"isEmpty":false,"pages":[{"name":"Objektorientierte Programmierung","index":3,"repo":"https://github.com/software-challenge/docs/tree/main/hyperbook/book/entwicklung/einfuehrung-oop.md","href":"/entwicklung/einfuehrung-oop"},{"name":"Sauberer Programmierstil","index":4,"repo":"https://github.com/software-challenge/docs/tree/main/hyperbook/book/entwicklung/sauberer-programmierstil.md","href":"/entwicklung/sauberer-programmierstil"},{"name":"Installation von Java","index":5,"repo":"https://github.com/software-challenge/docs/tree/main/hyperbook/book/entwicklung/installation-von-java.md","href":"/entwicklung/installation-von-java"},{"name":"Einrichtung der Entwicklungsumgebung","index":6,"repo":"https://github.com/software-challenge/docs/tree/main/hyperbook/book/entwicklung/einrichtung-der-entwicklungsumgebung.md","href":"/entwicklung/einrichtung-der-entwicklungsumgebung"},{"name":"Bedienung von Eclipse","index":7,"repo":"https://github.com/software-challenge/docs/tree/main/hyperbook/book/entwicklung/bedienung-von-eclipse.md","href":"/entwicklung/bedienung-von-eclipse"},{"name":"Spielervorlage erweitern","index":7,"repo":"https://github.com/software-challenge/docs/tree/main/hyperbook/book/entwicklung/simpleclient-erweitern.md","href":"/entwicklung/simpleclient-erweitern"},{"name":"Idee implementieren","index":8,"repo":"https://github.com/software-challenge/docs/tree/main/hyperbook/book/entwicklung/eine-idee-implementieren.md","href":"/entwicklung/eine-idee-implementieren"},{"name":"Computerspieler abgabefertig machen","index":9,"repo":"https://github.com/software-challenge/docs/tree/main/hyperbook/book/entwicklung/abgabe.md","href":"/entwicklung/abgabe"}],"sections":[],"repo":"https://github.com/software-challenge/docs/tree/main/hyperbook/book/entwicklung/index.md","href":"/entwicklung"}],"pages":[{"name":"Start","index":1,"repo":"https://github.com/software-challenge/docs/tree/main/hyperbook/book/index.md","href":"/"},{"name":"Technische Grundlagen","index":2,"repo":"https://github.com/software-challenge/docs/tree/main/hyperbook/book/glossar.md","href":"/glossar"},{"name":"Lesezeichen","index":3,"repo":"https://github.com/software-challenge/docs/tree/main/hyperbook/book/bookmark.md","href":"/bookmark"},{"name":"F.A.Q.","index":4,"repo":"https://github.com/software-challenge/docs/tree/main/hyperbook/book/faq.md","href":"/faq"}]}},"__N_SSG":true}